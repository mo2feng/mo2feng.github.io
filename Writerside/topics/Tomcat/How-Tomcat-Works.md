

## 第五章 容器

  容器是一个处理用户servlet请求并返回对象给web用户的模块。org.apache.catalina.Container接口定义了容器的形式，有四种容器：Engine（引擎）, Host（主机）, Context（上下文）, 和 Wrapper（包装器）。这一章将会介绍context和wrapper，而Engine和Host会留到第十三章介绍。这一章首先介绍容器接口，然后介绍容器的工作流程。然后介绍的内容是Wrapper和Context接口。然后用两个例子来总结wrapper和context容器。
  容器接口 一个容器必须实现org.apache.catalina.Container接口。就如在第四章中看到的，传递一个Container实例给Connector对象的setContainer方法，然后Connector对象就可以使用container的invoke方法，重新看第四章中Bootstrap类的代码如下： HttpConnector connector = new HttpConnector(); SimpleContainer container = new SimpleContainer(); connector.setContainer(container); 对于Catalina的容器首先需要注意的是它一共有四种不同的容器： · Engine：表示整个Catalina的servlet引擎 · Host：表示一个拥有数个上下文的虚拟主机 · Context：表示一个Web应用，一个context包含一个或多个wrapper · Wrapper：表示一个独立的servlet 每一个概念之上是用org.apache.catalina包来表示的。Engine、Host、Context和Wrapper接口都实现了Container即可。它们的标准实现是StandardEngine, StandardHost, StandardContext, and StandardWrapper，它们都是org.apache.catalina.core包的一部分。 图5.1表示了Container接口和它的子接口的结构图。注意接口都是org.apache.catalina包的，而所有的类都是org.apache.catalina.core包的。
  Figure 5.1: The class diagram of Container and its related types
  注意
  所有的类都扩展自抽象类ContainerBase.
  一个Catalina功能部署不一定需要所有的四种类型的容器。例如本章的第一个应用程序仅仅包括一个wrapper，而第二个应用程序是一个包含Context和wrapper的容器模块。 一个容器可以有一个或多个低层次上的子容器。例如，一个Context有一个或多个wrapper，而wrapper作为容器层次中的最底层，不能包含子容器。讲一个容器添加到另一容器中可以使用在Container接口中定义的addChild()方法，如下定义： public void addChild(Container child); 删除一个容器可以使用Container接口中定义的removeChild()方法，删除方法如下表示：
  public void removeChild(Container child); 另外容器接口支持子接口查找和获得所有子接口集合的方法findChild和findChildren方法。如下表示： public Container findChild(String name); public Container[] findChildren(); 一个容器还包含一系列的部分如Lodder、Loggee、Manager、Realm和Resources。 这些组成部分将会在后边章节中进行讨论。需要注意的一点是Container接口对于这些组件都定义了set和get方法包括：getLoader and setLoader, getLogger and setLogger, getManager and setManager, getRealm and setRealm, and getResources and setResources.
  更有意思的是Container接口被设计成Tomcat管理员可以通过server.xml文件配置来决定其工作方式的模式。它通过一个pipeline（流水线）和一系列的阀门来实现，这些内容将会在下一节Pipelining Task中讨论。
  注意
  Tomcat4中的Container接口和Tomcat5中的接口有稍许不同。例如第四种有一个map方法，但是在Tomcat5中，该方法被删除了。
  Pipelining Tasks（流水线任务）
  这一章介绍了connector调用容器的Invoke方法后做的工作，然后讨论了org.apache.catalina中四个相关的接口：Pipeline, Valve, ValveContext, 和 Contained。 一个pipeline包含了改容器要唤醒的所有任务。每一个阀门表示了一个特定的任务。一个容器的流水线有一个基本的阀门，但是你可以添加任意你想要添加的阀门。阀门的数目定义为添加的阀门的个数（不包括基本阀门）。有趣的是，阀门可以痛苦编辑Tomcat的配置文件server.xml来动态的添加。
  Figure 5.2: Pipeline and valves
  如果你已经理解了servlet过滤器，那么流水线和它的阀门的工作方式不难想象。一个流水线就像一个过滤链，每一个阀门像一个过滤器。跟过滤器一样，一个阀门可以操作传递给它的request和response方法。让一个阀门完成了处理，则进一步处理流水线中的下一个阀门，基本阀门总是在最后才被调用。 一个容器可以有一个流水线。当容器的invoke方法被调用的时候，容器将会处理流水线中的阀门，并一个接一个的处理，直到所有的阀门都被处理完毕。可以想象流水线的invoke方法的伪代码如下所示： // invoke each valve added to the pipeline for (int n=0; n<valves.length; n++) { valve[n].invoke( ... ); } // then, invoke the basic valve basicValve.invoke( ... ); 但是，Tomcat的设计者选择了一种不同的通过org.apache.catalina.ValveContext定义的方式来处理，这里介绍它如何工作的： 容器的invoke方法在被connector调用的时候所作的工作不难进行编码。容器调用的是流水线的invoke方法。流水线接口的invoke方法前面跟容器接口的invoke方法签名相同 public void invoke(Request request, Response response) throws IOException, ServletException;
  Here is the implementation of the Container interface's invoke method in the org.apache.catalina.core.ContainerBase class.
  这里是Container接口中invoke方法在org.apache.catalina.core.ContainerBase的实现： public void invoke(Request request, Response response) throws IOException, ServletException { pipeline.invoke(request, response); } Pipeline是容器中Pipeline接口的一个实例。
  现在，流水线必须保证说要添加给它的阀门必须被调用一次，流水线通过创建一个ValveContext接口的实例来实现它。ValveContext是流水线的的内部类，这样ValveContext就可以访问流水线中所有的成员。ValveContext中最重要的方法是invokeNext方法： public void invokeNext(Request request, Response response) throws IOException, ServletException 在创建一个ValveContext实例之后，流水线调用ValveContext的invokeNext方法。ValveContext会先唤醒流水线的第一个阀门，然后第一个阀门会在完成它的任务之前唤醒下一个阀门。ValveContext将它自己传递给每一个阀门，那么该阀门就可以调用ValveContext的invokeNext方法。Valve接口的invoke签名如下： public void invoke(Request request, Response response, ValveContext ValveContext) throws IOException, ServletException 一个阀门的invoke方法可以如下实现： public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException { // Pass the request and response on to the next valve in our pipeline valveContext.invokeNext(request, response); // now perform what this valve is supposed to do ... }
  org.apache.catalina.core.StandardPipeline类是容器流水线的实现。在Tomcat4中，这个类中有一个内部类StandardPipelineValveContext实现了ValveContext接口，Listing5.1展示了StandardPipelineValveContext类：
  Listing 5.1: The StandardPipelineValveContext class in Tomcat 4
  protected class StandardPipelineValveContext implements ValveContext { protected int stage = 0; public String getInfo() { return info; } public void invokeNext(Request request, Response response) throws IOException, ServletException { int subscript = stage;
  stage = stage + 1;
  // Invoke the requested Valve for the current request thread if (subscript < valves.length) { valves[subscript].invoke(request, response, this); } else if ((subscript == valves.length) && (basic != null)) { basic.invoke(request, response, this); } else { throw new ServletException (sm.getString("standardPipeline.noValve")); } } }
  InvokeNext方法使用下标（subscript）和级别（stage）记住哪个阀门被唤醒。当第一次唤醒的时候，下标的值是0，级的值是1。以你次，第一个阀门被唤醒，流水线的阀门获得ValveContext实例调用它的invokeNext方法。这时下标的值是1所以下一个阀门被唤醒，然后一步步的进行。 Tomcat5从StandardPipeline中删除了StandardPipelineValveContext类，而是使用rg.apache.catalina.core.StandardValveContext类来代替，如Listing 5.2所示：
  Listing 5.2: The StandardValveContext class in Tomcat 5 package org.apache.catalina.core; import java.io.IOException; import javax.servlet.ServletException; import org.apache.catalina.Request; import org.apache.catalina.Response; import org.apache.catalina.Valve; import org.apache.catalina.ValveContext; import org.apache.catalina.util.StringManager; public final class StandardValveContext implements ValveContext { protected static StringManager sm = StringManager.getManager(Constants.Package); protected String info = "org.apache.catalina.core.StandardValveContext/1.0"; protected int stage = 0; protected Valve basic = null; protected Valve valves[] = null; public String getInfo() {
  return info;
  } public final void invokeNext(Request request, Response response) throws IOException, ServletException { int subscript = stage; stage = stage + 1; // Invoke the requested Valve for the current request thread if (subscript < valves.length) { valves[subscript].invoke(request, response, this); } else if ((subscript == valves.length) && (basic != null)) { basic.invoke(request, response, this); } else { throw new ServletException (sm.getString("standardPipeline.noValve")); } } void set(Valve basic, Valve valves[]) { stage = 0; this.basic = basic; this.valves = valves; } }
  你能看到Tomcat4中StandardPipelineValveContext和Tomcat 5中StandardValveContext相似的地方吗？ 接下来我们会讨论流水线、阀门和阀门上下文Pipeline, Valve, and ValveContext的更多细节。
  The Pipeline Interface流水线接口
  我们提到的流水线的第一个方法是它的Pipeline接口的invoke方法，该方法会开始唤醒流水线的阀门。流水线接口允许你添加一个新的阀门或者删除一个阀门。最后，可以使用setBasic方法来分配一个基本阀门给流水线，getBasic方法会得到基本阀门。最后被唤醒的基本阀门，负责处理request和回复response。Pipeline接口如Listing5.3
  Listing 5.3: The Pipeline interface package org.apache.catalina; import java.io.IOException;
  import javax.servlet.ServletException; public interface Pipeline { public Valve getBasic(); public void setBasic(Valve valve); public void addValve(Valve valve); public Valve[] getValves(); public void invoke(Request request, Response response) throws IOException, ServletException; public void removeValve(Valve valve);
  }
  The Valve Interface阀门接口
  阀门接口表示一个阀门，该组件负责处理请求。该接口有两个方法，invoke和getInfo方法。Invoke方法如上所述，getInfo方法返回阀门的信息。阀门接口如Listing5.4
  Listing 5.4: The Valve interface package org.apache.catalina; import java.io.IOException; import javax.servlet.ServletException; public interface Valve { public String getInfo(); public void invoke(Request request, Response response, ValveContext context) throws IOException, ServletException;
  }
  The ValveContext Interface阀门上下文接口
  阀门上下文接口有两个方法，invokeNext方法如上所述，getInfo方法会返回阀门上下文的信息。ValveContext接口如下：
  Listing 5.5: The ValveContext interface package org.apache.catalina; import java.io.IOException; import javax.servlet.ServletException; public interface ValveContext { public String getInfo(); public void invokeNext(Request request, Response response)
  throws IOException, ServletException;
  }
  The Contained Interface Contained接口
  一个阀门可以选择性的实现org.apache.catalina.Contained接口。该接口定义了其实现类跟一个容器相关联。Contained如Listing5.6
  Listing 5.6: The Contained interface package org.apache.catalina; public interface Contained { public Container getContainer(); public void setContainer(Container container);
  the Wrapper Interface Wrapper接口
  org.apache.catalina.Wrapper接口表示了一个包装器。一个包装器是表示一个独立servlet定义的容器。包装器继承了Container接口，并且添加了几个方法。包装器的实现类负责管理其下层servlet的生命中期，包括servlet的init,service,和destroy方法。由于包装器是最底层的容器，所以不可以将子容器添加给它。如果addChild方法被调用的时候会产生IllegalArgumantException异常。 包装器接口中重要方法有allocate和load方法。allocate方法负责定位该包装器表示的servlet的实例。Allocate方法必须考虑一个servlet是否实现了avax.servlet.SingleThreadModel接口，该部分内容将会在11章中进行讨论。Load方法负责load和初始化servlet的实例。它们的签名如下： public javax.servlet.Servlet allocate() throws javax.servlet.ServletException; public void load() throws javax.servlet.ServletException; 其它的方法将会在第11章中介绍org.apache.catalina.core.StandardWrapper类的时候涉及到。 The Context Interface上下文（Context）接口
  一个context在容器中表示一个web应用。一个context通常含有一个或多个包装器作为其子容器。 重要的方法包括addWrapper, createWrapper等方法。该接口将会在第12章中详细介绍。
  The Wrapper Application（包装器应用程序）
  这个应用程序展示了如何写一个简单的容器模型。该应用程序的核心类是ex05.pyrmont.core.SimpleWrapper，它实现了Wrapper接口。SimpleWrapper类包括一个Pipeline（由ex05.pyrmont.core.SimplePipeline实现）和一个
  Loader类（ex05.pyrmont.core.SimpeLoader）来加载一个servlet。流水线包括一个基本阀门（ex05.pyrmont.core.SimpleWrapperValve）和两个另外的阀门(ex05.pyrmont.core.ClientIPLoggerValve 和 ex05.pyrmont.core.HeaderLoggerValve).该应用的类结构图如图5.3所示：
  Figure 5.3: The Class Diagram of the Wrapper Application
  Note
  The container uses Tomcat 4's default connector.
  包装器包装签名使用的ModernServlet。这个应用程序表示一个servlet容器可以由一个单一的包装器构成。这些类都没有完整的实现，只是实现了必须的方法。接下来看程序的具体实现。
  ex05.pyrmont.core.SimpleLoader
  容器中加载servlet的任务被分配给了Loader实现。在该程序中SimpleLoader就是一个Loader实现。它知道如何定位一个servlet，并且通过getClassLoader获得一个java.lang.ClassLoader实例用来查找servlet类位置。SimpleLoader定义了3个变量，第一个是WEB_ROOT用来指明在哪里查找servlet类。
  public static final String WEB_ROOT = System.getProperty("user.dir") + File.separator + "webroot"; The other two variables are object references of type ClassLoader and Container: 另外两个变量时ClassLoader和Container： ClassLoader classLoader = null; Container container = null; SimpleLoader类的构造器初始化类加载器，那样准备返回一个SimpleWrapper实例。
  public SimpleLoader() { try { URL[] urls = new URL[l]; URLStreamHandler streamHandler = null; File classPath = new File(WEB_ROOT);
  String repository = (new URL("file", null, classPath.getCanonicalPath() + File.separator)).toString() ; urls[0] = new URL(null, repository, streamHandler); classLoader = new URLClassLoader(urls); } catch (IOException e) { System.out.println(e.toString() ); } } 该程序的构造器用于初始化一个类加载器如前面章节所用的。容器变量表示容器跟该加载器是相关联的。
  Note
  Loaders will be discussed in detail in Chapter 8.
  ex05.pyrmont.core.SimplePipeline
  SimplePipeline实现了org.apache.catalina.Pipeline接口。该类中最重要的方法是invoke方法，其中包括了一个内部类SimplePipelineValveContext。SimplePipelineValveContext实现了org.apache.catalina.ValveContext接口如上面章节所介绍的。
  ex05.pyrmont.core.SimpleWrapper
  该类实现了org.apache.catalina.Wrapper接口并且实现了allocate方法和load方法，该类声明了如下变量： private Loader loader; protected Container parent = null; loader变量用于加载一个servlet类。Parent变量表示该包装器的父容器。这意味着，该容器可以是其它容器的子容器，例如Context。 需要特别注意getLoader方法，如Listing5.7所示：
  Listing 5.7: The SimpleWrapper class's getLoader method public Loader getLoader() { if (loader != null) return (loader); if (parent != null) return (parent.getLoader()); return (null);
  }
  getLoader方法用于返回一个Loader对象用于加载一个servlet类。如果一个包装器跟一个加载器相关联，会返回该加载器。否则返回其父容器的加载器，如果没有父容器，则返回null。
  SimpleWrapper类有一个流水线和该流水线的基本阀门。这些工作在SimpleWrapper的构造函数中完成。
  Listing 5.8: The SimpleWrapper class's constructor public SimpleWrapper() {
  pipeline.setBasic(new SimpleWrapperValve()); }
  其中，ipeline是SimplePipeline类的一个实例。 private SimplePipeline pipeline = new SimplePipeline(this);
  ex05.pyrmont.core.SimpleWrapperValve
  SimpleWrapperValve类是一个给SimpleWrapper类专门处理请求的基本阀门。它实现了org.apache.catalina.Valve接口和org.apache.catalina.Contained接口。最重要的方法是invoke方法如Listing5.9所示
  Listing 5.9: The SimpleWrapperValve class's invoke method public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException { SimpleWrapper wrapper = (SimpleWrapper) getContainer(); ServletRequest sreq = request.getRequest(); ServletResponse sres = response.getResponse(); Servlet servlet = null; HttpServletRequest hreq = null; if (sreq instanceof HttpServletRequest) hreq = (HttpServletRequest) sreq; HttpServletResponse hres = null; if (sres instanceof HttpServletResponse) hres = (HttpServletResponse) sres; // Allocate a servlet instance to process this request try { servlet = wrapper.allocate(); if (hres!=null && hreq!=null) { servlet.service(hreq, hres); } else { servlet.service(sreq, sres); } } catch (ServletException e) {
  }
  }
  由于SimpleWrapperValve被当做一个基本阀门来使用，它的invoke方法不需要invokeNext方法。Invoke方法调用SimpleWrapper的allocate方法获得servlet的一个实例。然后调用servlet的service方法。注意包装器流水线的基本阀门唤醒的是servlet的service方法，而不是wrapper方法自己的。
  ex05.pyrmont.valves.ClientIPLoggerValve
  ClientIPLoggerValve是一个阀门，它打印出客户端的IP地址到控制台。该类如Listing5.10
  Listing 5.10: The ClientIPLoggerValve class package ex05.pyrmont.valves; import java.io.IOException; import javax.servlet.ServletRequest; import javax.servlet.ServletException; import org.apache.catalina.Request; import org.apache.catalina.Response; import org.apache.catalina.Valve; import org.apache.catalina.ValveContext; import org.apache.catalina.Contained; import org.apache.catalina.Container; public class ClientIPLoggerValve implements Valve, Contained { protected Container container; public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException { // Pass this request on to the next valve in our pipeline valveContext.invokeNext(request, response); System.out.println("Client IP Logger Valve"); ServletRequest sreq = request.getRequest(); System.out.println(sreq.getRemoteAddr()); System, out.println("-----------------------------------"); } public String getInfo() { return null; } public Container getContainer() { return container; }
  public void setContainer(Container container) { this.container = container; } }
  注意invoke方法，它的第一件事情是调用阀门上下文invokeNext方法来唤醒下一个阀门，然后它会打印出请求对象的getRemoteAddr方法的输出。
  ex05.pyrmont.valves.HeaderLoggerValve
  该类跟ClientIPLoggerValve类非常相似。HeaderLoggerValve是一个阀门打印请求头部到控制台上。该类如Listing5.11
  Listing 5.11: The HeaderLoggerValve class package ex05.pyrmont.valves; import java.io.IOException; import java.util.Enumeration; import javax.servlet.ServletRequest; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import org.apache.catalina.Request; import org.apache.catalina.Response; import org.apache.catalina.Valve; import org.apache.catalina.ValveContext; import org.apache.catalina.Contained; import org.apache.catalina.Container; public class HeaderLoggerValve implements Valve, Contained { protected Container container; public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException { // Pass this request on to the next valve in our pipeline valveContext.invokeNext(request, response); System.out.println("Header Logger Valve"); ServletRequest sreq = request.getRequest(); if (sreq instanceof HttpServletRequest) { HttpServletRequest hreq = (HttpServletRequest) sreq; Enumeration headerNames = hreq.getHeaderNames(); while (headerNames.hasMoreElements()) { String headerName = headerNames.nextElement().toString(); String headerValue = hreq.getHeader(headerName);
  System.out.println(headerName + ":" + headerValue); } } else System.out.println("Not an HTTP Request"); System.out.println ("-----------------------------------"); } public String getInfo() { return null; } public Container getContainer() { return container; } public void setContainer(Container container) {
  this.container = container; } }
  注意其invoke方法，该方法首先调用阀门的invokeNext方法唤醒下一个阀门。然后打印出头部的值。
  ex05.pyrmont.startup.Bootstrap1
  Bootstrap1用于启动这个应用程序。
  Listing 5.12: The Bootstrap1 class package ex05.pyrmont.startup; import ex05.pyrmont.core.SimpleLoader; import ex05.pyrmont.core.SimpleWrapper; import ex05.pyrmont.valves.ClientlPLoggerValve; import ex05.pyrmont.valves.HeaderLoggerValve; import org.apache.catalina.Loader; import org.apache.catalina.Pipeline; import org.apache.catalina.Valve; import org.apache.catalina.Wrapper; import org.apache.catalina.connector.http.HttpConnector; public final class Bootstrap1 { public static void main(String[] args) { HttpConnector connector = new HttpConnector();
  Wrapper wrapper = new SimpleWrapper(); wrapper.setServletClass("ModernServlet"); Loader loader = new SimpleLoader(); Valve valve1 = new HeaderLoggerValve(); Valve valve2 = new ClientIPLoggerValve(); wrapper.setLoader(loader); ((Pipeline) wrapper).addValve(valve1); ((Pipeline) wrapper).addValve(valve2); connector.setContainer(wrapper); try { connector.initialize(); connector.start(); // make the application wait until we press a key. System.in.read(); } catch (Exception e) { e.printStackTrace(); } } }
  创建HttpConnector 和SimpleWrapper类的实例以后，主方法里分配ModernServlet给SimpleWrapper的setServletClass方法，告诉包装器要加载的类的名字以便于加载。 wrapper.setServletClass("ModernServlet"); 然后它创建了加载器和两个阀门然后将把加载器给包装器： Loader loader = new SimpleLoader(); Valve valve1 = new HeaderLoggerValve(); Valve valve2 = new ClientIPLoggerValve(); wrapper.setLoader(loader); The two valves are then added to the wrapper's pipeline. 然后把两个阀门添加到包装器流水线中。 ((Pipeline) wrapper).addValve(valve1); ((Pipeline) wrapper).addValve(valve2); 最后，把包装器当做容器添加到连接器中，然后初始化并启动连接器。 connector.setContainer(wrapper);
  try { connector.initialize(); connector.start(); 下一行允许用户在控制台键入回车键以停止程序。 // make the application wait until we press Enter. System.in.read();
  Running the Application
  运行程序 在windows下面可以在工作目录下面如下运行该程序： java -classpath ./lib/servlet.jar;./ ex05.pyrmont.startup.Bootstrap1 在Linux下面使用冒号分开两个库 java -classpath ./lib/servlet.jar:./ ex05.pyrmont.startup.Bootstrap1 可以使用下面的URL来唤醒servlet http://localhost:8080
  浏览器将会显示从ModernServlet得到的回复。跟下面内容相似的内容会显示在控制台上。 ModernServlet -- init Client IP Logger Valve 127.0.0.1 ----------------------------------- Header Logger Valve accept:image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms- powerpoint, */* accept-language:en-us accept-encoding:gzip, deflate user-agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.1.4322) host:localhost:8080 connection:Keep-Alive -----------------------------------
  The Context Application
  在本章的第一个程序中，介绍了如何部署一个仅仅包括一个包装器的简单的web应用。该程序仅仅包括一个servlet，也许会有一些应用仅仅需要一个servlet名单是大多数的网络应用需要多个servlet。在这些应用中，你需要一个跟包装器不同的容器：上下文。
  第二个应用程序将会示范如何使用一个包含两个包装器的上下文来包装两个servlet类。当有多于一个得包装器的时候，需要一个map来处理这些子容器，对于特殊的请求可以使用特殊的子容器来处理。
  Note
  A mapper can only be found in Tomcat 4. Tomcat 5 uses another approach to finding a child container.
  注意
  使用map方法是在Tomcat4中，Tomcat 5使用了另一种机制来查找子容器
  在这个程序中，mapper是ex05.pyrmont.core.SimpleContextMapper类的一个实例，它继承了Tomcat 4中的org.apache.catalina.Mapper接口。一个容器也可以有多个mapper来支持多协议。例如容器可以用一个mapper来支持HTTP协议，而使用另一个mapper来支持HTTPS协议。Listing5.13提供了Tomcat4中的Mapper接口。
  Listing 5.13: The Mapper interface package org.apache.catalina; public interface Mapper {
  public Container getContainer(); public void setContainer(Container container); public String getProtocol(); public void setProtocol(String protocol); public Container map(Request request, boolean update); }
  getContainer返回该容器的mapper，setContainer方法用于联系一个容器到mapper。 getProtocol返回该mapper负责处理的协议，setProtocol用于分配该容器要处理的协议。map方法返回处理一个特殊请求的子容器。
  Figure 5.4 presents the class diagram of this application. 图5.4是该程序的类结构图
  Figure 5.4: The Context application class diagram. SimpleContext表示一个上下文，它使用SimpleContextMapper作为它的mapper，SimpleContextValve作为它的基本阀门。该上下文包括两个阀门ClientIPLoggerValve和HeaderLoggerValve。用SimpleWrapper表示的两个包装器作为该上下文的子容器被添加。包装器吧SimpleWrapperValve作为它的基本阀门，但是没有其它的阀门了。 该上下文应用程序使用同一个加载器、两个阀门。但是加载器和阀门时跟该上下文关联的，而不是跟包装器关联。这样，两个加载器就可以都使用该加载器。该上下文被当做连接器的容器。因此，连接器每次收到一个HTTP请求可以使用上下文的invoke方法。根据前面介绍的内容，其余的工作不难理解。 1. 一个容器有一个流水线，容器的invoke方法会调用流水线的invoke方法。 2. 流水线的invoke方法会调用添加到容器中的阀门的invoke方法，然后调用基本阀门的invoke方法。 3. 在一个包装器中，基本阀门负责加载相关的servlet类并对请求作出相应。 4. 在一个有子容器的上下文中，基本法门使用mapper来查找负责处理请求的子容器。如果一个子容器被找到，子容器的invoke方法会被调用，然后返回步骤1。 接下来看处理的流程是如何实现的。 SimpleContext的invoke方法调用流水线的invoke方法。 public void invoke(Request request, Response response) throws IOException, ServletException { pipeline.invoke(request, response); }
  SimplePipeline类用来表示流水线，它的invoke方法如下所示： public void invoke(Request request, Response response) throws IOException, ServletException { // Invoke the first Valve in this pipeline for this request (new SimplePipelineValveContext()).invokeNext(request, response); } 如流水下任务一节中介绍的，该段代码唤醒所有的阀门然后调用基本阀门的

  ## 第六章 生命周期

  综述
  Catalina由多个组件组成，当Catalina启动的时候，这些组件也会启动。当Catalina停止的时候，这些组件也必须有机会被清除。例如，当一个容器停止工作的时候，它必须唤醒所有加载的servlet的destroy方法，而session管理器要保存session到二级存储器中。保持组件启动和停止一致的的机制通过实现org.apache.catalina.Lifecycle接口来实现。 一个实现了Lifecycle接口的组件同是会触发一个或多个下列事件：BEFORE_START_EVENT, START_EVENT, AFTER_START_EVENT, BEFORE_STOP_EVENT, STOP_EVENT, and AFTER_STOP_EVENT。当组件被启动的时候前三个事件会被触发，而组件停止的时候会触发后边三个事件。另外，如果一个组件可以触发事件，那么必须存在相应的监听器来对触发的事件作出回应。监听器使用org.apache.catalina.LifecycleListener来表示。 本章会对Lifecycle, LifecycleEvent, and LifecycleListener进行讨论。另外，还会解释一个公用类LifecycleSupport，它给组件提供了一个简单方式来触发生命周期事件和处理事件监听器。在本章中，会建立一个有实现了Lifecycle接口的类的工程。该程序时基于第五章的应用程序的。 Lifecycle接口
  Catalina的设计允许一个组件包含其它的组件。例如一个容器可以包含一系列的组件如加载器、管理器等。一个父组件负责启动和停止其子组件。Catalina的设计成所有的组件被一个父组件来管理（in custody），所以启动bootstrap
  类只需启动一个组件即可。这种单一的启动停止机制通过继承Lifecycle来实现。看Listing6.1所示的Lifecycle接口。
  Listing 6.1: The Lifecycle interface package org.apache.catalina; public interface Lifecycle { public static final String START_EVENT = "start"; public static final String BEFORE_START_EVENT = "before_start"; public static final String AFTER_START_EVENT = "after_start"; public static final String STOP_EVENT = "stop"; public static final String BEFORE_STOP_EVENT = "before_stop"; public static final String AFTER_STOP_EVENT = "after_stop"; public void addLifecycleListener(LifecycleListener listener); public LifecycleListener[] findLifecycleListeners(); public void removeLifecycleListener(LifecycleListener listener); public void start() throws LifecycleException; public void stop() throws LifecycleException; }
  Lifecycle中最重要的方法是start和stop方法。一个组件提供了这些方法的实现，所以它的父组件可以通过这些方法来启动和停止他们。另外3个方法addLifecycleListener, findLifecycleListeners, 和 removeLifecycleListener事跟监听器相关的类。组件的监听器对组件可能触发的时间“感兴趣”，当一个事件被触发的时候，相应监听器会被通知。一个Lifecycle实例可以触发使用静态最终字符串定义的六个事件。 LifecycleEvent类 org.apache.catalina.LifecycleEvent表示一个生命周期事件，如Listing6.2所示：
  Listing 6.2: The org.apache.catalinaLifecycleEvent interface package org.apache.catalina; import java.util.EventObject; public final class LifecycleEvent extends EventObject { public LifecycleEvent(Lifecycle lifecycle, String type) { this(lifecycle, type, null); } public LifecycleEvent(Lifecycle lifecycle, String type, Object data) {
  super(lifecycle); this.lifecycle = lifecycle; this.type = type;
  this.data = data; } private Object data = null; private Lifecycle lifecycle = null; private String type = null; public Object getData() { return (this.data); } public Lifecycle getLifecycle() { return (this.lifecycle); } public String getType() { return (this.type); } } LifecycleListener接口 org.apache.catalina.LifecycleListener接口可以表示生命周期监听器，如Listing6.3所示：
  Listing 6.3: The org.apache.catalina.LifecycleListener interface package org.apache.catalina; import java.util.EventObject; public interface LifecycleListener { public void lifecycleEvent(LifecycleEvent event); }
  在该接口中，只有一个方法lifecycleEvent，该方法在事件触发的时候唤醒对其“感兴趣”的监听器。 LifecycleSupport类
  org.apache.catalina.util.LifecycleSupport. The LifecycleSupport class is given in Listing 6.4. 一个实现了Lifecycle接口的组件并且允许监听器注册其“感兴趣”的事件必须Lifecycle接口提供跟事件相关的方法的代码（addLifecycleListener, findLifecycleListeners, 和removeLifecycleListener）。这样就可以将组件的监听器添加到ArrayList或者其他相似的对象中。Catalina提供了一个公用类org.apache.catalina.util.LifecycleSupport来简化组件处理监听器和触发生命周期事件。LifecycleSupport如Listing6.4所示
  Listing 6.4: The LifecycleSupport class package org.apache.catalina.util; import org.apache.catalina.Lifecycle;
  import org.apache.catalina.LifecycleEvent; import org.apache.catalina.LifecycleListener; public final class LifecycleSupport { public LifecycleSupport(Lifecycle lifecycle) { super(); this.lifecycle = lifecycle; } private Lifecycle lifecycle = null; private LifecycleListener listeners[] = new LifecycleListener[0]; public void addLifecycleListener(LifecycleListener listener) { synchronized (listeners) { LifecycleListener results[] = new LifecycleListener[listeners.length + 1]; for (int i = 0; i < listeners.length; i++) results[i] = listeners[i]; results[listeners.length] = listener; listeners = results; } } public LifecycleListener[] findLifecycleListeners() { return listeners; } public void fireLifecycleEvent(String type, Object data) { LifecycleEvent event = new LifecycleEvent(lifecycle, type, data); LifecycleListener interested[] = null; synchronized (listeners) { interested = (LifecycleListener[]) listeners.clone(); } for (int i = 0; i < interested.length; i++) interested[i].lifecycleEvent(event); } public void removeLifecycleListener(LifecycleListener listener) { synchronized (listeners) { int n = -1; for (int i = 0; i < listeners.length; i++) { if (listeners[i] == listener) { n = i; break; }
  } if (n < 0) return; LifecycleListener results[] = new LifecycleListener[listeners.length - 1];
  int j = 0; for (int i = 0; i < listeners.length; i++) { if (i != n) results[j++] = listeners[i]; } listeners = results; } } }
  如Listing 6.4所示，LifecycleSupport类存储所有的生命周期监听器到一个数组中，该数组为listenens，它初始化的时候没有任何成员。 private LifecycleListener listeners[] = new LifecycleListener[0]; 当一个监听器通过addLifecycleListener方法被添加的时候，一个新的数组（长度比旧数组大1）会被创建。然后就数组中的元素会被拷贝到新数组中并把新事件添加到数组中。当一个事件被删除的时候，一个新的数组（长度为旧数组-1）的数组会被创建并将所有的元素存储到其中。 fireLifecycleEvent方法触发一个生命周期事件。首先，它会克隆整个监听器数组，然后它调用每个成员的lifecycleEvent方法，传递被触发的事件。 一个实现了Lifecycle的组件可以使用LifecycleSupport类。例如，该程序的SimpleContext类声明了如下变量 protected LifecycleSupport lifecycle = new LifecycleSupport(this); SimpleContext调用LifecycleSupport 的addLifecycleListener方法添加一个生命周期事件： public void addLifecycleListener(LifecycleListener listener) { lifecycle.addLifecycleListener(listener); } 要删除一个生命周期监听事件，SimpleContext调用LifecycleSupport类的removeLifecycleListener方法。 public void removeLifecycleListener(LifecycleListener listener) { lifecycle.removeLifecycleListener(listener); } 要触发一个事件，SimpleContext需要调用LifecycleSupport的fireLifecycleEvent方法：
  lifecycle.fireLifecycleEvent(START_EVENT, null);
  The Application
  本章的应用程序构建在第五章的程序之上，用来说明Lifecycle接口以及与生命周期相关的其他类型。它包括一个上下文和两个包装器以及一个加载器和一个映射。该应用程序中的组件实现了Lifecycle接口，上下文有一个监听器。为了使程序简便，第五章中的阀门并没有使用。该程序的结构如图6.1所示。注意一些接口（Container, Wrapper, Context, Loader, Mapper）一些类（SimpleContextValve, SimpleContextMapper, and SimpleWrapperValve）并没有出现在该结构图中。
  Figure 6.1: The class diagram of the accompanying application 注意SimpleContextLifecycleListener类表示了SimpleContext的监听器。SimpleContextValve, SimpleContextMapper, 和 SimpleWrapperValve类跟第五章的程序相同，这里不再涉及。
  ex06.pyrmont.core.SimpleContext
  该程序中的SimpleContext类跟第五章中的相似，不同的是它实现了Lifecycle接口。SimpleContext类使用如下变量来引用一个LifecycleSupport实例。 protected LifecycleSupport lifecycle = new LifecycleSupport(this); 它还使用一个名为started的变量来标记该SimpleContext实例是否已经启动。SimpleContext类实现了Lifecycle接口中的方法，这些方法如Listing6.5所示
  Listing 6.5: Methods from the Lifecycle interface. public void addLifecycleListener(LifecycleListener listener) { lifecycle.addLifecycleListener(listener); } public LifecycleListener[] findLifecycleListeners() { return null; } public void removeLifecycleListener(LifecycleListener listener) { lifecycle.removeLifecycleListener(listener);
  } public synchronized void start() throws LifecycleException { if (started) throw new LifecycleException("SimpleContext has already started"); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); started = true; try { // Start our subordinate components, if any if ((loader != null) && (loader instanceof Lifecycle)) ((Lifecycle) loader).start(); // Start our child containers, if any Container Children[] = findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Lifecycle) ((Lifecycle) children[i]).start(); } // Start the Valves in our pipeline (including the basic), // if any if (pipeline instanceof Lifecycle) ((Lifecycle) pipeline).start(); // Notify our Interested LifecycleListeners lifecycle.firelifecycleEvent(START_EVENT, null); } catch (Exception e) { e.printStackTrace(); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null); } public void stop() throws LifecycleException { if (!started) throw new LifecycleException("SimpleContext has not been started"); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; try { // Stop the Valves in our pipeline (including the basic), if any if (pipeline instanceof Lifecycle) (
  ((Lifecycle) pipeline).stop(); } // Stop our child containers, if any Container children[] = findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Lifecycle) ((Lifecycle) children[i]).stop(); } if ((loader != null) && (loader instanceof Lifecycle)) { ((Lifecycle) loader).stop(); } } catch (Exception e) { e.printStackTrace(); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null); }
  注意start方法是如何启动所有子容器以及其相关组件（容易加载器、流水线和映射器）的，以及stop方法是如何停止这些组件的。使用该机制，可以启动容器模型中所有的组件，你只需要启动最高层的组件即可（在该例子中SimpleContext实例）。而停止它们的时候只需简单停止相同的组件即可。 SimpleContext的start方法首先会检查是否已经启动，如果已经启动了，方法会抛出LifecycleException异常。 if (started) throw new LifecycleException( "SimpleContext has already started"); It then raises the BEFORE_START_EVENT event. 然后它产生了BEFORE_START_EVENT事件。 // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); 其结果就是SimpleContext实例中注册的监听器都会被唤醒，一个SimpleContextLifecycleListener类型的监听器会注册它“感兴趣”的事件。接下来会看监听器会发生什么事。 接下来，start方法设置started布尔变量为真来标记该组件已经启动。 started = true;
  start方法接下来会启动所有组件以及其子容器。现在有两个组件实现了Lifecycle接口：SimpleLoader 和 SimplePipeline。SimpleContext有两个包装器作为其子容器。这些包装器也实现了Lifecycle接口。 try {
  // Start our subordinate components, if any if ((loader != null) && (loader instanceof Lifecycle)) ((Lifecycle) loader).start(); // Start our child containers, if any Container children[] = findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Lifecycle) ((Lifecycle) children[i]).start(); } // Start the Valves in our pipeline (including the basic), // if any if (pipeline instanceof Lifecycle) ((Lifecycle) pipeline).start(); 组件和子容器都被启动之后，start方法产生两个事件START_EVENT 和 AFTER_START_EVENT。 // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(START_EVENT, null); . . . // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null); stop方法首先检查该实例是否已经启动。如果没有启动会产生一个LifecycleException类型的异常。 if (!started) throw new LifecycleException( "SimpleContext has not been started"); 接下来会触发BEFORE_STOP_EVENT 和 STOP_EVENT事件，并重置started变量。 // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; 接下来stop方法会停止所有相关组件以及SimpleContext的子容器。 try {
  // Stop the Valves in our pipeline (including the basic), if any if (pipeline instanceof Lifecycle) { ((Lifecycle) pipeline).stop(); }
  // Stop our child containers, if any Container children[] = findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Lifecycle) ((Lifecycle) children[i]).stop(); } if ((loader != null) && (loader instanceof Lifecycle)) { ((Lifecycle) loader).stop(); } } 最后，产生AFTER_STOP_EVENT事件。 // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);
  ex06.pyrmont.core.SimpleContextLifecycleListener
  SimpleContextLifecycleListener表示SimpleContext实例的监听器。
  Listing 6.6: The SimpleContextLifecycleListener class package ex06.pyrmont.core; import org.apache.catalina.Context; import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleEvent; import org.apache.catalina.LifecycleListener; public class SimpleContextLifecycleListener implements LifecycleListener { public void lifecycleEvent(LifecycleEvent event) { Lifecycle lifecycle = event.getLifecycle(); System.out.println("SimpleContextLifecycleListener's event " + event.getType().toString()); if (Lifecycle.START_EVENT.equals(event.getType())) {
  System.out.println("Starting context."); } else if (Lifecycle.STOP_EVENT.equals(event.getType())) { System.out.println("Stopping context."); } } }
  SimpleContextLifecycleListener 类中lifecycleEvent方法的实现很简单。只是打印出触发的时间，如果事件为START_EVENT事件，则打印出“Starting context.”，如果事件为STOP_EVENTT，则打印出“Stopping contex”。
  ex06.pyrmont.core.SimpleLoader
  SimpleLoader跟第五章中相似，不同之处在于它实现了Lifecycle接口，所实现的方法什么都没做只是打印出一些字符串到控制台上。更重要的是，实现了Lifecycle接口，一个SimpleLoader实例就可以通过其相关容器启动它。 从Lifecycle接口的来得到方法如Listing6.7所示。
  Listing 6.7: The methods from Lifecycle in the SimpleLoader class public void addLifecycleListener(LifecycleListener listener) { } public LifecycleListener[] findLifecycleListeners() { return null; } public void removeLifecycleListener(LifecycleListener listener) { } public synchronized void start() throws LifecycleException { System.out.println("Starting SimpleLoader"); } public void stop() throws LifecycleException { }
  ex06.pyrmont.core.SimplePipeline
  另外Pipeline接口和SimplePipeline类也实现了Lifecycle接口。从Lifecycle接口的来的方法被留空，现在这个类的的实例可以由其相关容器来启动，该类的其他的部分跟第五章中的相似。
  ex06.pyrmont.core.SimpleWrapper
  该类跟ex05.pyrmont.core.SimpleWrapper很相似。在该应用中，它实现了Lifecycle接口，所以它可以由其父容器来启动。在该程序中，出start和stop方法之外的大多数从Lifecycle接口获得的方法被留空。Listing6.8展示了这些方法的实现。
  Listing 6.8: The methods from the Lifecycle interface public void addLifecycleListener(LifecycleListener listener) { } public LifecycleListener[] findLifecycleListeners() { return null; } public void removeLifecycleListener(LifecycleListener listener) ( } public synchronized void start() throws LifecycleException {
  System.out.println("Starting Wrapper " + name); if (started) throw new LifecycleException("Wrapper already started"); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); started = true; // Start our subordinate components, if any if ((loader != null) && (loader instanceof Lifecycle)) ((Lifecycle) loader).start(); // Start the Valves in our pipeline (including the basic), if any if (pipeline instanceof Lifecycle) ((Lifecycle) pipeline).start(); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(START_EVENT, null); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null); } public void stop() throws LifecycleException { System.out.println("Stopping wrapper " + name); // Shut down our servlet instance (if it has been initialized) try { instance.destroy(); } catch (Throwable t) { } instance = null; if (!started) throw new LifecycleException("Wrapper " + name + " not started"); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; // Stop the Valves in our pipeline (including the basic), if any if (pipeline instanceof Lifecycle) { ((Lifecycle) pipeline).stop(); } // Stop our subordinate components, if any if ((loader != null) && (loader instanceof Lifecycle)) { ((Lifecycle) loader).stop(); }
  // Notify our interested LifecycleListeners
  lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null); }
  SimpleWrapper 中的start方法跟SimpleContext类中的start方法相似。它启动所有的组件并触发BEFORE_START_EVENT, START_EVENT,和 AFTER_START_EVENT事件。 SimpleWrapper的stop方法更有趣，它打印出一个简单的字符串，并唤醒servlet实例的destroy方法。 System.out.println("Stopping wrapper " + name); // Shut down our servlet instance (if it has been initialized) try { instance.destroy(); } catch (Throwable t) { } instance = null; 然后它检查该包装器是否被启动了，如果没有会抛出LifecycleException。 if (!started) throw new LifecycleException("Wrapper " + name + " not started"); 接下来，它触发BEFORE_STOP_EVENT 和 STOP_EVENT事件并重置started布尔变量。 // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; 接下来它停止跟其相关的流水线组件和加载器。在该应用程序中，SimpleWrapper实例没有加载器。 // Stop the Valves in our pipeline (including the basic), if any if (pipeline instanceof Lifecycle) { ((Lifecycle) pipeline).stop(); } // Stop our subordinate components, if any if ((loader != null) && (loader instanceof Lifecycle)) { ((Lifecycle) loader).stop(); } 最后，它触发了AFTER_STOP_EVENT事件。 // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);
  Running the Application
  运行程序 在windows下面，可以在工作目录下面键入如下命令启动程序： java -classpath ./lib/servlet.jar;./ ex06.pyrmont.startup.Bootstrap

  ## 第七章：日志系统

  综述
  日志系统是一个记录信息的组件。在Catalina中，日志系统是一个相对简单的跟容器相关联的组件。Tomcat在org.apache.catalina.logger包中提供了多个不同的日志系统。本章的应用程序在ex07.pyrmont包中。SimpleContext 和 Bootstrap是从第六章中修改得到的。 本章有三节组成，第一节介绍了org.apache.catalina.Logger接口，该接口是所有的日志系统都要实现的。第二节介绍了Tomcat中的日志系统，第三节详细讲解了本章的例子，该例子基于Tomcat的日志系统。 Logger接口 一个日志系统必须实现org.apache.catalina.Logger接口，该接口如Listing7.1所示
  Listing 7.1: The Logger interface package org.apache.catalina; import java.beans.PropertyChangeListener; public interface Logger { public static final int FATAL = Integer.MIN_VALUE; public static final int ERROR = 1; public static final int WARNING = 2; public static final int INFORMATION = 3; public static final int DEBUG = 4; public Container getContainer(); public void setContainer(Container container); public String getInfo(); public int getVerbosity(); public void setVerbosity(int verbosity); public void addPropertyChangeListener(PropertyChangeListener listener); public void log(String message);
  public void log(Exception exception, String msg); public void log(String message, Throwable throwable); public void log(String message, int verbosity); public void log(String message, Throwable throwable, int verbosity); public void removePropertyChangeListener(PropertyChangeListener listener); }
  日志接口提供了日志系统要实现的方法，最简单的方法是接受一个字符串并将其记录， 最后两个方法会接受一个冗余级别（verbosity level），如果传递的数字低于该类的实例设置的冗余级别，就将信息记录下来，否则就忽略信息。使用静态变量定义了五个冗余级别：FATAL, ERROR, WARNING, INFORMATION,和 DEBUG。getVerbosity和setVerbosity分别用来获得和设置冗余级别。 另外，日志接口还有getContainer 和 setContainer方法用来将日志系统跟容器关联起来。还有addPropertyChangeListener和removePropertyChangeListener方法删除和添加PropertyChangeListener。 看了Tomcat中日志系统的实现之后你就会清楚这些方法了。
  Tomcat日志系统
  Tomcat提供了三种日志系统，它们分别是FileLogger, SystemErrLogger, 和 SystemOutLogger。这些类可以在org.apache.catalina.logger包中找到，它们都继承了org.apache.catalina.logger.LoggerBase类。在Tomcat 4中LoggerBase实现了org.apache.catalina.Logger接口，在Tomcat 5中，它还实现了Lifecycle接口（第六章）和MBeanRegistration接口（20章介绍）。
  The UML diagram of these classes is shown in Figure 7.1. 它们的UML结果图如图7.1所示
  Figure 7.1: Tomcat's Loggers
  LoggerBase类
  在Tomcat5中，LoggerBase类由于集成了MBeans而比较复杂，所以本章看的是Tomcat4中的LoggerBase类。等讨论完20章后，就可以理解Tomcat5中的LoggerBase类。 在Tomcat 4中，LoggerBase类是一个抽象类，它实现了Logger接口中除log(String msg)之外的所有方法。 public abstract void log(String msg);
  该方法需要在子类ongoing进行覆盖（overload），所有的其他的log方法都调用了该方法。因为每一个子类都将信息记录到不同的地方，所以该方法在LoggerBase中北留空。 现在来看该类的冗余级别。它被定义为一个protected的名为verbosity的变量，默认值为ERROR。 protected int verbosity = ERROR; 冗余级别可以使用setVerbosity方法改变，传递这些字符串给方法即可FATAL, ERROR, WARNING, INFORMATION, 或 DEBUG。Listing7.2展示了LoggerBase类中setVobosity方法的实现。
  Listing 7.2: The setVerbosity method public void setVerbosityLevel(String verbosity) { if ("FATAL".equalsIgnoreCase(verbosity)) this.verbosity = FATAL; else if ("ERROR".egualsIgnoreCase(verbosity)) this.verbosity = ERROR; else if ("WARNING".equalsIgnoreCase(verbosity)) this.verbosity = WARNING; else if ("INFORMATION".equalsIgnoreCase(verbosity)) this.verbosity = INFORMATION; else if ("DEBUG".equalsIgnoreCase(verbosity)) this.verbosity = DEBUG; }
  有两个log方法会接受一个整型参数作为它的冗余级别。log(String message)的覆盖如Listing7.3
  Listing 7.3: The log method overloads that accept verbosity public void log(String message, int verbosity) { if (this.verbosity >= verbosity) log(message); } public void log(String message, Throwable throwable, int verbosity) { if (this.verbosity >= verbosity) log(message, throwable); }
  在后边介绍的LoggerBase的三个子类中，可以看到log(String message)方法的实现。
  SystemOutLogger类
  SystemOutLogger作为LoggerBase的子类提供了log(String message)方法的实现。每一个收到的信息都被传递给System.out.println方法，SystemOutLogger类如Listing7.4所示。
  Listing 7.4: The SystemOutLogger Class package org.apache.catalina.logger; public class SystemOutLogger extends LoggerBase { protected static final String info = "org.apache.catalina.logger.SystemOutLogger/1.0";
  public void log(String msg) { System.out.println(msg); } }
  SystemErrLogger类
  This class is very similar to the SystemOutLogger class, except that the message argument to the log(String message) method overload calls the System.err.println() method. The SystemErrLogger class is given in Listing 7.5. SystemErrLogger类跟SystemOutLogger类十分相似，只是它覆盖log(String message)方法的时候使用的是System.erro.println()方法。SystemErrLogger类如Listing7.5
  Listing 7.5: The SystemErrLogger class package org.apache.catalina.logger; public class SystemErrLogger extends LoggerBase { protected static final String info = "org.apache.catalina.logger.SystemErrLogger/1.0"; public void log(String msg) { System.err.println(msg); } }
  The FileLogger Class
  FileLogger类
  FileLogger是LoggerBase类中最复杂的。它将从关联容器收到的信息写到文件中，每个信息可以选择性的加上时间戳。在第一次实例化的时候，该类的实例会创建一个文件，该文件的名字带有日期信息。如果日期改变了，它会创建一个新的文件并把信息写在里面。类的实例允许在日志文件的名字上添加前缀和后缀。 在Tomcat4中，FileLogger类实现了Lifecycle接口，所以它可以跟其它实现org.apache.catalina.Lifecycle接口的组件一样启动和停止。在Tomcat5中，它是实现了Lifecycle接口的LoggerBase类的子类。 Tomcat 4中LoggerBase类的start和stop方法实现仅仅触发了监听器“感兴趣的”文件日志的开始和停止事件。这两个方法如Listing7.6所示，注意stop方法调用了该类的关闭日志文件的私有方法（close方法）。关闭方法会在本节后边的内容中介绍。
  Listing 7.6: The start and stop methods public void start() throws LifecycleException { // Validate and update our current component state if (started) throw new LifecycleException (sm.getString("fileLogger.alreadyStarted")); lifecycle.fireLifecycleEvent(START_EVENT, null); started = true; } public void stop() throws LifecycleException { // Validate and update our current component state if (!started) throw new LifecycleException (sm.getString("fileLogger.notStarted")); lifecycle.fireLifecycleEvent(STOP__EVENT, null); started = false; close (); }
  FileLogger类中最重要的方法是log方法，如Listing7.7所示。
  Listing 7.7: The log method public void log(String msg) { // Construct the timestamp we will use, if reguested Timestamp ts = new Timestamp(System.currentTimeMillis()); String tsString = ts.toString().substring(0, 19); String tsDate = tsString.substring(0, 10); // If the date has changed, switch log files if (!date.equals(tsDate)) { synchronized (this) { if (!date.equals(tsDate)) {
  close (); date = tsDate; open (); } } } // Log this message, timestamped if necessary if (writer != null) { if (timestamp) { writer.println(tsString + " " + msg); } else { writer.println(msg); } } }
  log方法接受一个消息并把消息写到日志文件中。在FileLogger实例的生命周期中，log方法可以打开或关闭多个日志文件。如果日期改变了的话，log方法关闭当前文件并打开一个新文件。接下来看看open、close和log这些方法是如何工作的。
  open方法
  如Listing7.8所示，open方法在指定目录中创建一个新日志文件。
  Listing 7.8: The open method private void open() { // Create the directory if necessary File dir = new File(directory); if (!dir.isAbsolute()) dir = new File(System.getProperty("catalina.base"), directory); dir.mkdirs(); // Open the current log file try { String pathname = dir.getAbsolutePath() + File.separator + prefix + date + suffix; writer = new PrintWriter(new FileWriter(pathname, true), true); } catch (IOException e) { writer = null; }
  }
  open方法首先应该创建日志的目录是否存在，如果目录不存在，则首先创建目录。目录存放在该类的变量中。 File dir = new File(directory); if (!dir.isAbsolute()) dir = new File(System.getProperty("catalina.base"), directory); dir.mkdirs(); 然后组成该文件的路径名，由目录路径、前缀、日期和后缀组成。 try ( String pathname = dir.getAbsolutePath() + File.separator + prefix + date + suffix; 接下来构造java.io.PrintWriter类的一个实例，然后将该PringWriter实例给改了的变量writer。log方法使用writer来记录信息。 writer = new PrintWriter(new FileWriter(pathname, true), true);
  The close method
  Close方法清空PrintWriter变量writer，然后关闭PrintWriter并将writer设置为null，并将date设置为空字符串。该方法如Listing7.9。
  Listing 7.9: The close method private void close() { if (writer == null) return; writer.flush(); writer.close(); writer = null; date = ""; }
  log方法
  Log方法首先创建一个java.sql.Timestamp类的实例，该类是java.util.Date的瘦包装器 (thin wrapper)。初始化时间戳的目的是更容易的得到当前时间。在该方法中，将当前时间的long格式传递给Timestamp类并构建Timestamp类实例。 Timestamp ts = new Timestamp(System.currentTimeMillis()); 使用Timestamp类的toString方法，可以得到当前时间的字符串表示形式，字符串输出的形式如下格式：
  yyyy-mm-dd hh:mm: SS.fffffffff 其中fffffffff表示从00:00:00开始的毫微秒。在方法中使用subString方法得到日期和小时。 String tsString = ts.toString().substring(0, 19); 接下来使用如下语句得到日期： String tsDate = tsString.substring(0, 10);
  接下来log方法比较tsData和String变量date的值，如果tsDate和date的值不同，它关闭当前日志文件，将tsDate的值赋给date并打开一个新日志文件。 // If the date has changed, switch log files if (!date.equals(tsDate)) { synchronized (this) { if (!date.equals(tsDate)) { close(); date = tsDate; open(); } } } 最后，日志方法将PrintWriter实例的输出流写入到日志文件中。如果布尔变量timestamp的值为真，将timestamp(tsString)的值作为前缀，否则不使用前缀。 // Log this message, timestamped if necessary if (writer != null) { if (timestamp) { writer.println(tsString + " " + msg); } else { writer.println(msg); } } The Application 该章的应用程序跟第六章的程序很相似，只是多了个跟SimpleContext对象相关的FileLogger。程序的改变可以在ex07.pyrmont.startup.Bootstrap类的主方法里找到，如Listing7.10所示。注意要仔细看高亮的代码。
  Listing 7.10: The Bootstrap class package ex07.pyrmont.startup; import ex07.pyrmont.core.SimpleContext; import ex07.pyrmont.core.SimpleContextLifecycleListener; import ex07.pyrmont.core.SimpleContextMapper; import ex07.pyrmont.core.SimpleLoader;
  import ex07.pyrmont.core.SimpleWrapper; import org.apache.catalina.Connector; import org.apache.catalina.Context;
  import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleListener; import org.apache.catalina.Loader; import org.apache.calalina.loggor.FileLogger; import org.apache.catalina.Mapper; import org.apache.catalina.Wrapper; import org.apache.catalina.connector.http.HttpConnector; public final class Bootstrap { public static void main(String[] args) { Connector connector = new HttpConnector(); Wrapper Wrapper1 = new SimpleWrapper(); Wrapper1.setName("Primitive"); Wrapper1.setServletClass("PrimitiveServlet"); Wrapper wrapper2 = new SimpleWrapper(); wrapper2.setName("Modern"); Wrapper2.setServletClass("ModernServlet"); Loader loader = new SimpleLoader(); Context context = new SimpleContext(); context.addChild(wrapper1); context.addChild(wrapper2); Mapper mapper = new SimpleContextMapper(); mapper.setProtocol("http"); LifecycleListener listener = new SimpleContextLifecycleListener(); ((Lifecycle) context).addLifecycleListener(listener); context.addMapper(mapper); context.setLoader(loader); // context.addServletMapping(pattern, name); context.addServletMapping("/Primitive", "Primitive"); context.addServletMapping("/Modern", "Modern"); // ------ add logger -------- System.setProperty("catalina.base", System.getProperty("user.dir")); FileLogger logger = new FileLogger(); logger.setPrefix("FileLog_"); logger.setSuffix(".txt"); logger.setTimestamp(true);
  logger.setDirectory("webroot"); context.setLogger(logger); //-------------------------- connector.setContainer(context); try { connector.initialize(); ((Lifecycle) connector).start(); ((Lifecycle) context).start(); // make the application wait until we press a key. System.in.read(); ((Lifecycle) context).stop(); } catch (Exception e) {
  e.printStackTrace(); } } }
  总结
  在本章中，学习了日志组件，并介绍了org.apache.catalina.Logger接口，并仔细的分析了Tomcat中对于Logger接口中的三个实现类。另外，使用应用程序来说明了FileLogger类的使用。

  ## 第八章：加载器

  综述
  在前面的章节中已经介绍了一个简单的加载器，用它来加载servlet类。这一章会介绍标准网络应用加载器(standard web application loader)，简单的说就是加载器。一个servlet容器需要一个定制的容器，而不是简单的使用系统的加载器。如果像前面章节中那样使用系统的加载器来加载servlet和其他需要的类，这样servlet就可以进入Java虚拟机CLASSPATH环境下面的任何类和类库，这会带来安全隐患。Servlet只允许访问WEB-INF/目录及其子目录下面的类以及部署在WEB-INF/lib目录下的类库。所以一个servlet容器需要一个自己的加载器，该加载器遵守一些特定的规则来加载类。在Catalina中，加载器使用org.apache.catalina.Loader接口表示。 Tomcat需要一个自己的加载器的另一个原因是它需要支持在WEB-INF/classes或者是WEB-INF/lib目录被改变的时候会重新加载。Tomcat的加载器实现中使用一个单独的线程来检查servlet和支持类文件的时间戳。要支持类的自动加载功能，一个加载器类必须实现org.apache.catalina.loader.Reloader接口。 本章的第一节先简要的回顾下Java的类加载机制。接下来介绍了加载器必须实现的Loader接口，然后是Reloader接口。接下来看到的是加载器的实现，最后本章使用一个程序说明了怎么使用Tomcat类的加载器。 本章广泛使用的是两个词：库（repository）和源（resources）。库表示加载器查找的地方，源表示加载器中的DirContext对象，它的文档基（document base）指向了上下文的文档基。
  Java类加载器
  在每次创建一个Java类的实例时候，必须先将该类加载到内存中。Java虚拟机（JVM）使用类加载器来加载类。Java加载器在Java核心类库和CLASSPATH环境下面的所有类中查找类。如果需要的类找不到，会抛出java.lang.ClassNotFoundException异常。 从J2SE1.2开始，JVM使用了三种类加载器：bootstrap类加载器、extension类加载器和systen类加载器。这三个加载器是父子关系，其中bootstrap类加载器在顶端，而system加载器在结构的最底层。 其中bootstrap类加载器用于引导JVM，一旦调用java.exe程序，bootstrap类加载器就开始工作。因此，它必须使用本地代码实现，然后加载JVM需要的类到函数中。另外，它还负责加载所有的Java核心类，例如java.lang和java.io包。另外bootstrap类加载器还会查找核心类库如rt.jar、i18n.jar等，这些类库根据JVM和操作系统来查找。 extension类加载器负责加载标准扩展目录下面的类。这样就可以使得编写程序变得简单，只需把JAR文件拷贝到扩展目录下面即可，类加载器会自动的在下面查找。不同的供应商提供的扩展类库是不同的，Sun公司的JVM的标准扩展目录是/jdk/jre/lib/ext。
  system加载器是默认的加载器，它在环境变量CLASSPATH目录下面查找相应的类。 这样，JVM使用哪个类加载器？答案在于委派模型(delegation model)，这是出于安全原因。每次一类需要加载，system类加载器首先调用。但是，它不会马上加载类。相反，它委派该任务给它的父类-extension类加载器。extension类加载器也把任务委派给它的父类bootstrap类加载器。因此，bootstrap类加载器总是首先加载类。如果bootstrap类加载器不能找到所需要的类的extension类加载器会尝试加载类。如果扩展类加载器也失败，system类加载器将执行任务。如果系统类加载器找不到类，一个java.lang.ClassNotFoundException异常。为什么需要这样的往返模式？ 委派模型对于安全性是非常重要的。如你所知，可以使用安全管理器来限制访问某个目录。现在，恶意的意图有人能写出一类叫做java.lang.Object，可用于访问任何在硬盘上的目录。因为JVM的信任java.lang.Object类，它不会关注这方面的活动。因此，如果自定义java.lang.Object被允许加载的安全管理器将很容易瘫痪。幸运的是，这将不会发生，因为委派模型会阻止这种情况的发生。下面是它的工作原理。 当自定义java.lang.Object类在程序中被调用的时候，system类加载器将该请求委派给extension类加载器，然后委派给bootstrap类加载器。这样bootstrap类加载器先搜索的核心库，找到标准java.lang.Object并实例化它。这样，自定义java.lang.Object类永远不会被加载 关于在Java类加载机制的优势在于可以通过扩展java.lang.ClassLoader抽象类来扩展自己的类加载器。Tomcat的需求自定义自己的类加载器原因包括以下内容 · 要制定类加载器的某些特定规则 · 缓存以前加载的类 · 事先加载类以预备使用 Loader接口 在Web应用程序中加载servlet和其他类需要遵循一些规则。例如，在一个应用程序中Servlet可以使用部署到WEB-INF/classes目录和任何子目录下面的类。然而，没有servlet的不能访问其他类，即使这些类是在运行Tomcat 所在的JVM的CLASSPATH中。此外，一个servlet只能访问WEB-INF/lib目录下的类库，而不能访问其他目录下面的。 一个Tomcat类加载器表示一个Web应用程序加载器，而不是一个类加载器。一个加载器必须实现org.apache.catalina.Loader接口。加载器的实现使用定制的类加载器org.apache.catalina.loader.WebappClassLoader。可以使用Loader接口的getClassLoader方法获取一个网络加载器ClassLoader。
  值得一提的是Loader接口定义了一系列方法跟库协作。Web应用程序的WEB-INF/classes 和 WEB-INF/lib目录作为库添加上。Loader接口的addReposity方法用于添加一个库，findRepositories方法用于返回一个所有库的队列。 一个Tomcat的加载器通常跟一个上下文相关联，Loader接口的和getContainer及setContainer方法是建立此关联。一个加载器还可以支持重新加载，如果在上下文中的一个或多个类已被修改。这样，一个servlet程序员可以重新编译servlet或辅助类，新类将被重新加载而不需要不重新启动Tomcat加载。为了达到重新加载的目的，Loader接口有修改方法。在加载器的实现中，如果在其库中一个或多个类别已被修改，modeify方法必须返回true，因此需要重新加载。一个加载器自己进行重新加载，而是调用上下文接口的重载方法。另外两种方法，setReloadable和getReloadable，用于确定加载器中是否可以使用重加载。默认情况下，在标准的上下文实现中（org.apache.catalina.core.StandardContext类将在第12章讨论）重载机制并未启用。因此，要使得上下文启动重载机制，需要在server.xml文件添加一些元素如下： <Context path="/myApp" docBase="myApp" debug="0" reloadable="true"/> 另外，一个加载器的实现可以确定是否委派给父加载器类。为了实现这一点，Loader接口提供了getDelegate和setDelegate方法。 Loader接口如Listing8.1所示
  Listing 8.1: The Loader interface package org.apache.catalina; import java.beans.PropertyChangeListener; public interface Loader { public ClassLoader getClassLoader(); public Container getContainer(); public void setContainer(Container container); public DefaultContext getDefaultContext(); public void setDefaultContext(DefaultContext defaultContext); public boolean getDelegate(); public void setDelegate(boolean delegate); public String getInfo(); public boolean getReloadable(); public void setReloadable(boolean reloadable); public void addPropertyChangeListener(PropertyChangeListener
  listener); public void addRepository(String repository); public String[] findRepositories(); public boolean modified(); public void removePropertyChangeListener(PropertyChangeListener
  listener); }
  Catalina提供了org.apache.catalina.loader.WebappLoader作为Load接口的实现。WebappLoader对象包含一个org.apache.catalina.loader.WebappClassLoader类的实例，该类扩展了Java.netURLClassLoader类。
  注意
  无论一个跟容器相关的加载器何时需要一个servlet类，当它的invoke方法被调用的时候，容器首先调用加载器的getClassLoader方法获得一个加载器。然后容器调用loadClass方法来加载servlet类，更多的细节会在第11章中介绍。
  Loader接口和它的实现类的结构图如图8.1
  Figure 8.1: The Loader interface and its implementation Reloader接口 要支持自动重新加载，一个加载器的实现必须实现org.apache.catalina.loader.Reloader接口，该接口如Listing8.2
  Listing 8.2: The Reloader interface package org.apache.catalina.loader; public interface Reloader { public void addRepository(String repository); public String[] findRepositories ();
  public boolean modified(); }
  Reloader接口里最重要的方法是modified方法，如果在web应用程序中的servlet任何支持类被修改的时候该方法返回true。addRepository方法用于添加一个库而findRepositories方法用于返回实现了Reloader接口的加载器的所有的库。
  WebappLoader类
  org.apache.catalina.loader.WebappLoader类是Loader接口的实现，它表示一个web应用程序的加载器，负责给web应用程序加载类。WebappLoader创建一个org.apache.catalina.loader.WebappClassLoader类的实例作为它的类加载器。像其他的Catalina组件一样，WebappLoader实现了org.apache.catalina.Lifecycle接口，可有由关联容器启动和停止。WebappLoader类还实现了java.lang.Runnable接口，所以可以通过一个线程来重复的调用modified方法，如果modified方法返回true，WebappLoader实例同志它的关联容器。类通过上下文重新加载自己，而不是WebappLoader。上下文的怎么实现该功能会在第12章，标准上下文中介绍。 WebappLoader类的start方法被调用的时候，将会完成下面几项重要任务： · Creating a class loader · Setting repositories · Setting the class path · Setting permissions · Starting a new thread for auto-reload. · 创建一个类加载器 · 设置库 · 设置类路径 · 设置访问权限 · 开启一个新线程用来进行自动重载 在接下来的内容中会讨论这些任务。
  创建类加载器
  WebappLoader使用一个内部类加载器来加载类。可以回头看Loader接口，该接口提供了getClassLoader方法但是并没有setClassLoader方法。因此，不能通过传递一个WebappLoader来初始化它。这样没有默认类加载器是否意味着WebappLoader不够灵活的？ 答案当然是否定的，WebappLoader类提供了getLoaderClass 和 setLoaderClass方法来获得或者改变它的私有变量loaderClass的值。该变量是一个的表示加载器类名String类型表示形式。默认的loaderClass值是org.apahce.catalina.loader.WebappClassLoader，如果你愿意，可以创建继承WebappClassLoader类的自己的加载器，然后使用setLoaderClass方法来强制WebappLoader使用你创建的加载器。否则，当它WebappLoader启动的时候，它会使用它的私有方法createClassLoader创建WebappClassLoader的实例，该方法如Listing8.3所示：
  Listing 8.3: The createClassLoader method
  private WebappClassLoader createClassLoader() throws Exception { Class clazz = Class.forName(loaderClass); WebappClassLoader classLoader = null; if (parentClassLoader == null) { // Will cause a ClassCast if the class does not extend // WebappClassLoader, but this is on purpose (the exception will be // caught and rethrown) classLoader = (WebappClassLoader) clazz.newInstance(); // in Tomcat 5, this if block is replaced by the following: // if (parentClassLoader == null) { // parentClassLoader = // Thread.currentThread().getContextClassLoader(); // } } else { Class[] argTypes = { ClassLoader.class }; Object[] args = { parentClassLoader }; Constructor constr = clazz.getConstructor(argTypes); classLoader = (WebappClassLoader) constr.newInstance(args); } return classLoader;
  }
  也可以不使用WebappClassLoader而用其他的类，但是注意createClassLoader的返回值类型是WebappClassLoader，所以你的类必须继承WebappClassLoader类，否则该方法会抛出异常。
  设置库
  WebappLoader的start方法会调用setRepositories方法来给类加载器添加一个库。WEB-INF/classes目录传递给加载器addRepository方法，而WEB-INF/lib传递给加载器的setJarPath方法。这样，类加载器能能从WEB-INF/classes 目录下面和WEB-INF/lib目录下面部署的类库里加载类。
  设置类路径
  该任务由start方法调用setClassPath方法完成，setClassPath方法会给servlet上下文分配一个String类型属性保存Jasper JSP编译的类路径，该内容先不予讨论。
  设置访问权限
  如果Tomcat使用了安全管理器，setPermissions给类加载器给必要的目录添加访问权限，例如WEB-INF/classes和WEB-INF/lib。如果不使用管理器，该方法马上返回。
  开启自动重载线程
  WebappLoader支持自动重载，如果WEB-INF/classes或者WEB-INF/lib目录被重新编译过，在不重启Tomcat的情况下必须自动重新载入这些类。为了实现这个目的，WebappLoader有一个单独的线程每个x秒会检查源的时间戳。x的值由checkInterval变量定义，它的默认值是15，也就是每隔15秒会进行一次检查是否需要自动重载。该类还提供了两个方法getCheckInterval和setCheckInterval方法来访问或者设置checkInterval的值。 在Tomcat4中，WebappLoader实现了java.lang.Runnable接口来支持自动重载。WebappLoader对run方法的实现如Listing8.3所示：
  Listing 8.3: The run method public void run() { if (debug >= 1) log("BACKGROUND THREAD Starting"); // Loop until the termination semaphore is set while (!threadDone) { // Wait for our check interval threadSleep(); if (!started) break; try { // Perform our modification check if (!classLoader.modified()) continue; } catch (Exception e) { log(sm.getString("webappLoader.failModifiedCheck"), e); continue; } // Handle a need for reloading notifyContext(); break; } if (debug >= 1) log("BACKGROUND THREAD Stopping"); }
  注
  在Tomcat5中检查类是否被修改的任务由
  意
  org.apache.catalina.core.StandardContext类的backgroundProcess方法完成。该方法会被org.apache.catalina.core.ContainerBase类中一个专门的线程周期性的调用，ContainerBase是StandardContext类的父类。注意ContainerBase类的ContainerBackgroundProcessor内部类实现的Runnable接口。
  Listing8.3所示的run方法作为该线程的核心部分，包括一个while循环知道started变量为false。该while循环完成了下面的工作： · 休眠由checkInterval变量定义的一段时间 · 检查是否有类被改变，如果有责调用WebappLoader实例的modified方法，否则继续循环。 · 如果一个类被修改了，调用私有方法notifyContext来让跟WebappLoader实例相关联的上下文重新载入。 方法notifyContext如Listing8.4所示：
  Listing 8.4: The notifyContext method private void notifyContext() { WebappContextNotifier notifier = new WebappContextNotifier(); (new Thread(notifier)).start(); }
  方法notifyContext并不是直接调用Context接口中的reload方法，它首先初始化一个内部类WebappContextNotifier的实例，并把它传递给一个线程对象，调用它的start方法。这样重载的提交就由另一个线程完成，WebappContextNotifier类如Listing8.5所示：
  Listing 8.5: The WebappContextNotifier inner class protected class WebappContextNotifier implements Runnable { public void run() { ((Context) container).reload(); } }
  当WebappContextNotifier类的一个实例被传递给一个线程的时候，该线程的start方法被唤醒，WebappContextNotifier实例的run方法会被执行。然后，run方法调用Context接口的reload方法。可以在第12章看到org.apache.catalina.core.StandardContext类是如何实现reload方法的。
  WebappClassLoader类
  类org.apache.catalina.loader.WebappClassLoader表示在一个web应用程序中使用的加载器。WebappClassLoader类继承了java.net.URLClassLoader类，该类在前面章节中用于加载Java类。
  WebappClassLoader被可以的进行了优化和安全方面的考虑。例如它缓存了以前加载的类以改进性能，下一次收到第一次没有找到的类的请求的时候，可以直接抛出ClassNotFound异常。WebappClassLoader在源列表以及特定的JAR文件中查找类。
  处于安全性的考虑，WebappClassLoader类不允许一些特定的类被加载。这些类被存储在一个String类型的数组中，现在仅仅有一个成员。 private static final String[] triggers = { "javax.servlet.Servlet" // Servlet API }; 另外在委派给系统加载器的时候，你也不允许加载属于该包的其它类或者它的子包： private static final String[] packageTriggers = { "javax", // Java extensions "org.xml.sax", // SAX 1 & 2 "org.w3c.dom", // DOM 1 & 2 "org.apache.xerces", // Xerces 1 & 2 "org.apache.xalan" // Xalan }; 接下来让我们看看该类是如何实现缓存和加载的。
  缓存
  为了提高性能，当一个类被加载的时候会被放到缓存中，这样下次需要加载该类的时候直接从缓存中调用即可。缓存由WebappClassLoader类实例自己管理。另外，java.lang.ClassLoader维护了一个Vector，可以避免前面加载过的类被当做垃圾回收掉。在这里，缓存被该超类管理。 每一个可以被加载的类(放在 WEB-INF/classes目录下的类文件或者 JAR 文件)都被当做一个源。一个源被org.apache.catalina.loader.ResourceEntry类表示。一个ResourceEntry实例保存一个byte类型的数组表示该类、最后修改的数据或者副本等等。 ResourceEntry类如Listing8.6所示：
  Listing 8.6: The ResourceEntry class. package org.apache.catalina.loader; import java.net.URL; import java.security.cert.Certificate; import java.util.jar.Manifest; public class ResourceEntry {
  public long lastModifled = -1; // Binary content of the resource.
  public byte[] binaryContent = null; public Class loadedClass = null; // URL source from where the object was loaded. public URL source = null; // URL of the codebase from where the object was loaded. public URL CodeBase = null; public Manifest manifest = null; public Certificate[] certificates = null; }
  所有缓存的源被存放在一个叫做resourceEntries的HashMap中，键值为源名，所有找不到的源都被放在一个名为notFoundResources的HashMap中。
  加载类
  当加载一个类的时候，WebappClassLoader类遵循以下规则： · 所有加载过的类都要进行缓存，所以首先需要检查本地缓存。 · 如果无法再本地缓存找到类，使用java.langClassLoader类的findLoaderClass方法在缓存查找类、 · 如果在两个缓存中都无法找到该类，使用系统的类加载器避免从J2EE类中覆盖来的web应用程序。 · 如果使用了安全管理器，检查该类是否允许加载，如果该类不允许加载，则抛出ClassNotFoundException异常。 · 如果要加载的类使用了委派标志或者该类属于trigger包中，使用父加载器来加载类，如果父加载器为null，使用系统加载器加载。 · 从当前的源中加载类 · 如果在当前的源中找不到该类并且没有使用委派标志，使用父类加载器。如果父类加载器为null，使用系统加载器 · 如果该类仍然找不到，抛出ClassNotFoundException异常
  应用程序
  本章的应用程序演示类如何使用一个跟上下文相关联的WebappLoader加载器。一个上下问的标准实现是org.apache.catalina.core.StandardContext，所以该应用程序使用了StandardContext类。但是关于StarndardContext类在12章中才会详细讨论。这里不需要了解该类的细节，只需要知道它有些监听器和可以触发的事件即可，例如START_EVENT和STOP_EVENT，监听器必须实现org.apache.catalina.lifecycle.LifecycleListener接口并且调用StandardContext类的setConfigured方法。在该应用程序中，使用ex08.pyrmont.core.SimpleContextConfig类表示监听器，如Listing8.6所示。
  Listing 8.6: The SimpleContextConfig class package ex08.pyrmont.core; import org.apache.catalina.Context; import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleEvent; import org.apache.catalina.LifecycleListener; public class SimpleContextConfig implements LifecycleListener { public void lifecycleEvent(LifecycleEvent event) { if (Lifecycle.START_EVENT.equals(event.getType())) { Context context = (Context) event.getLifecycle(); context.setConfigured(true); } } }
  你需要做的仅仅是初始化一个StandardContext和SimpleContextConfig对象，然后调用org.apache.catalina.Lifecycle接口的addLifecycleListener方法来注册它。 另外，该应用程序使用了前面章节的类：SimplePipeline, SimpleWrapper, 和SimpleWrapperValve 该应用程序可以使用PrimitiveServlet和ModernServlet测试，但是使用StandardContext将WEB-INF/classes下面的servlets存储起来。该应用程序的目录名为myApp，如果你下载了ZIP文件需要该文件夹应该已经创建好了。设置系统属性catalina.base的值为user.dir，这样可以告诉StandardContext实例查找应用程序目录。 System.setProperty("catalina.base", System.getProperty("user.dir"));
  实际上，它是Bootstrap类的第一行，然后主方法初始化连接器： Connector connector = new HttpConnector(); 然后初始化两个servlet的两个包装器，如下： Wrapper wrapper1 = new SimpleWrapper(); wrapper1.setName("Primitive"); wrapper1.setServletClass("PrimitiveServlet"); Wrapper wrapper2 = new SimpleWrapper(); wrapper2.setName("Modern"); wrapper2.setServletClass("ModernServlet"); 然后创建了一个StandardContext得实例并设置该上下文的文档基（document base）. Context context = new StandardContext(); // StandardContext's start method adds a default mapper context.setPath("/myApp");
  context.setDocBase("myApp"); 这样做跟设置如下设置server.xml效果相同： <Context path="/myApp" docBase="myApp"/> 然后，两个包装器被添加到上下文中，并且添加映射关系，这样上下文就可以找到包装器。 context.addChild(wrapper1); context.addChild(wrapper2); context.addServletMapping("/Primitive", "Primitive"); context.addServletMapping("/Modern", "Modern"); 接下来的工作是初始化一个监听器并且在上下文中注册 LifecycleListener listener = new SimpleContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); 接下来初始化该上下文相关联的WebappLoader: Loader loader = new WebappLoader(); context.setLoader(loader); R然后建立连接器跟上下文的关联，然后调用初始化和start方法，接下来是上下文的start方法，这样servlet容器就可以工作了。 connector.setContainer(context); try { connector.initialize(); ((Lifecycle) connector).start();
  ((Lifecycle) context).start(); 接下来的几行是打印出源的docBase已经改加载器的所有源： // now we want to know some details about WebappLoader WebappClassLoader classLoader = (WebappClassLoader) loader.getClassLoader(); System.out.println("Resources' docBase: " + ((ProxyDirContext)classLoader.getResources ()).getDocBase()); String[] repositories = classLoader.findRepositories(); for (int i=0; i<repositorles.length; i++) { System.out.println(" repository: " + repositories[i]); } 当运行应用程序的时候会显示下面几行： Resources' docBase: C:\HowTomcatWorks\myApp repository: /WEB-INF/classes/
  The value of docBase may be different on your machine, depending where you install the application. docBase的值可能会有不同，这取决于该应用程序被部署在哪里。
  最后，该应用程序等待用户输入终止命令来停止应用程序。 // make the application wait until we press a key. System.in.read(); ((Lifecycle) context).stop();
  Running the Application
  在Windows下面可以在工作目录下面使用如下命令启动该程序： java -classpath ./lib/servlet.jar;./lib/commons-collections.jar;./ ex08.pyrmont.startup.Bootstrap 在Linux下面使用冒号分开两个库： java -classpath ./lib/servlet.jar:./lib/commons-collections.jar:./ ex08.pyrmont.startup.Bootstrap 可以在浏览器中输入如下URL调用PrinitiveServlet servlet。 http://localhost:8080/Primitive 要调用ModernServlet，可以使用如下URL：
  http://localhost:8080/Modern
  总结
  一个应用程序加载器，简单的说就是加载器是Catalina中最重要的组件之一。它使用一个内部的类加载器来完成加载类的工作。Tomcat使用该内部类加载器加载应用类，它属于一个应用上下文并且遵循一系列规则。另外，该加载器还支持缓存以及检测类修改情况的功能。

  ## 第九章：session管理

  综述
  Catalina通过一个叫管理器的组件来完成session管理工作，该组件由org.apache.catalina.Manager interface接口表示。一个管理器通常跟一个上下文容器相关联，它负责创建、更行以及销毁session对象并能给任何请求组件返回一个合法的session。 一个servlet可以使用getSession方法获得一个session对象，该方法在javax.servlet.http.HttpServletRequest定义。它在默认连接器里由org.apache.catalina.connector.HttpRequestBase类实现。这里是HttpRequestBase类的一些相关方法。 public HttpSession getSession() { return (getSession(true)); } public HttpSession getSession(boolean create) { ... return doGetSession(create); } private HttpSession doGetSession(boolean create) { // There cannot be a session if no context has been assigned yet if (context == null) return (null); // Return the current session if it exists and is valid if ((session != null) && !session.isValid()) session = null; if (session != null) return (session.getSession()); // Return the requested session if it exists and is valid Manager manager = null; if (context != null) manager = context.getManager(); if (manager == null) return (null); // Sessions are not supported if (requestedSessionId != null) { try { session = manager.findSession(requestedSessionId); }
  catch (IOException e) { session = null; }
  if ((session != null) && !session.isValid()) session = null; if (session != null) { return (session.getSession()); } } // Create a new session if requested and the response is not // committed if (!create) return (null); ... session = manager.createSession(); if (session != null) return (session.getSession()); else return (null); } 默认情况下管理器将session对象存储在内存中，但是Tomcat也允许将session对象存储在文件或者数据库中（通过JDBC）。Catalina在org.apache.catalina.session包中提供了session对象和session管理的相关类型。 本章使用了三节解释了session管理：Session、Managers和Stores。最后一节介绍了一个使用上下文容器以及相关联的管理器的应用程序。
  Sessions
  在servlet编程中，一个session对象使用javax.servlet.http.HttpSession接口表示。该接口的标准实现是StandardSession类，该类在org.apache.catalina.session包中。但是出于安全的原因，管理器并不会将一个StandardSession实例传递给servlet。而是使用org.apache.catalina.session包中的外观类StandardSession类。在内部，一个管理器使用了另一个外观：org.apache.catalina.Session接口。Session相关类型的UML结构图如图9。1，注意，出于简便的考虑，并没有将Session, StandardSession, 和StandardSessionFacade前面的类添加在里面。
  Figure 9.1: Session-related types
  Session接口
  Session接口扮演了一个Catalina内部外观的角色。它的标准实现StandardSession还是先了javax.servlet.http.HttpSession接口，Session接口如Listing9.1所示：
  Listing 9.1: The Session interface package org.apache.catalina; import java.io.IOException; import java.security.Principal; import java.util.Iterator; import javax.servlet.ServletException; import javax.servlet.http.HttpSession; public interface Session { public static final String SESSION_CREATED_EVENT = "createSession"; public static final String SESSION_DESTROYED_EVENT = "destroySession"; public String getAuthType(); public void setAuthType(String authType); public long getCreationTime(); public void setCreationTime(long time); public String getId(); public void setId(String id); public String getInfo(); public long getLastAccessedTime(); public Manager getManager(); public void setManager(Manager manager); public int getMaxInactiveInterval(); public void setMaxInactiveInterval(int interval); public void setNew(boolean isNew); public Principal getPrincipal(); public void setPrincipal(Principal principal); public HttpSession getSession(); public void setValid(boolean isValid); public boolean isValid();
  public void access(); public void addSessionListener(SessionListener listener); public void expire(); public Object getNote(String name); public Iterator getNoteNames(); public void recycle(); public void removeNote(String name);
  public void removeSessionListener(SessionListener listener); public void setNote(String name, Object value); }
  由于一个Session对象常常被一个管理器持有，所以接口提供了setManager和getManager方法来关联一个Session对象和一个管理器。另外，一个Session实例在跟管理器相关联的容器有一个唯一的ID。对于该ID有setId和getId方法相关。getLastAccessedTime方法由管理器来调用，以确定一个Session对象是否合法。管理器调用setValid方法来重置一个session的合法性。每次一个Session被进入的时候，都会调用access方法更新它的最后访问时间。最后，管理器可以调用expire方法来终止一个expire方法，使用getSession可以获得一个包装在该外观内的HttpSession对象。
  StandardSession类
  StandardSession类是Session接口的标准是实现。另外，实现了javax.servlet.http.HttpSession 和org.apache.catalina.Session之外，它还实现了java.lang.Serializable接口来使得Session对象可序列化。 该类的构造器获得一个管理器实例来强制使得每个Session对象都有一个管理器。 public StandardSession(Manager manager); 接下来是几个重要的变量在存放Session状态。注意transient使得该关键字不可序列化。 // session attributes private HashMap attributes = new HashMap(); // the authentication type used to authenticate our cached Principal, if any private transient String authType = null; private long creationTime = 0L; private transient boolean expiring = false; private transient StandardSessionFacade facade = null; private String id = null; private long lastAccessedTime = creationTime; // The session event listeners for this Session.
  private transient ArrayList listeners = new ArrayList(); private Manager manager = null; private int maxInactiveInterval = -1; // Flag indicating whether this session is new or not. private boolean isNew = false; private boolean isValid = false; private long thisAccessedTime = creationTime;
  注意
  在Tomcat5中上述变量都是protected，在Tomcat 4中是private的。每个变量都有一个set/get方法。
  方法getSession首先会将该实例创建一个StandardSessionFacade对象 public HttpSession getSession() { if (facade == null) facade = new StandardSessionFacade(this); return (facade); } 一个Session对象如果在由maxInactiveInterval变量的时间内没有被进入则被终结。使用Session接口中定义的expire方法可以终结一个Session对象。该方法在Tomcat4中StandardSession中的实现如Listing9.2
  Listing 9.2: The expire method public void expire(boolean notify) { // Mark this session as "being expired" if needed if (expiring) return; expiring = true; setValid(false); // Remove this session from our manager's active sessions if (manager != null) manager.remove(this); // Unbind any objects associated with this session String keys [] = keys(); for (int i = 0; i < keys.length; i++) removeAttribute(keys[i], notify); // Notify interested session event listeners if (notify) { fireSessionEvent(Session.SESSION_DESTROYED_EVENT, null); } // Notify interested application event listeners // FIXME - Assumes we call listeners in reverse order Context context = (Context) manager.getContainer(); Object listeners[] = context.getApplicationListeners(); if (notify && (listeners != null)) { HttpSessionEvent event = new HttpSessionEvent(getSession());
  for (int i = 0; i < listeners.length; i++) { int j = (listeners.length - 1) - i; if (!(listeners[j] instanceof HttpSessionListener))
  continue; HttpSessionListener listener = (HttpSessionListener) listeners[j]; try { fireContainerEvent(context, "beforeSessionDestroyed", listener); listener.sessionDestroyed(event); fireContainerEvent(context, "afterSessionDestroyed", listener); } catch (Throwable t) { try { fireContainerEvent(context, "afterSessionDestroyed", listener); } catch (Exception e) { ; } // FIXME - should we do anything besides log these? log(sm.getString("standardSession.sessionEvent"), t); } } } // We have completed expire of this session expiring = false; if ((manager != null) && (manager instanceof ManagerBase)) { recycle(); } }
  在Listing9.2的过程中包括设置内部变量、删除管理器的Session对象、并触发一个事件。
  StandardSessionFacade类
  要将一个Session对象传递给一个servlet，Catalina会初始化一个StandardSession类填充它并把它传递给servlet。但是它传递的是StandardSession对象，该类是先了javax.servlet.http.HttpSession接口中的方法。这样，servlet就不能将HttpSession向下转化为StandardSessionFacade类来访问它的共有方法。
  管理器
  管理器用来管理Session对象。例如它创建Session对象并销毁它们。管理器由org.apache.catalina.Manager接口表示。在Catalina中，org.apache.catalina.session包中类ManagerBase类提供了常用函数的基本实现。ManagerBase类有两个直接子类：StandardManager和PersistentManagerBase类。 在运行的时候，StandardManager将session对象存放在内存中。但是，当停止的时候，它将Session对象存放到文件中。当它再次启动的时候，重新载入Session对象。
  PersistentManagerBase类作为一个管理器组件将Session对象存放到二级存储器中。它有两个直接子类：PersistentManager和DistributedManager类(DistributedManager)类只在Tomcat4中有。管理器接口和它的实现类的UML结构图如图9.2所示

  ## 第十章：安全

  综述 有些web应用程序的内容是有限制的，只允许有权限的用户在提供正确的用户名和密码的情况下才允许访问。Servlet通过配置部署文件web.xml来对安全性提供技术支持。本章的主要内容是容器对于安全性限制的支持。 一个servlet通过一个叫authenticator的阀门（valve）来支持安全性限制。当容器启动的时候，authenticator被添加到容器的流水线上。如果你忘了流水线是如何工作的，需要重新复习下第六章的内容。 authenticator阀门会在包装器阀门之前被调用。authenticator用于对用户进行验证，如果用户熟人了正确的用户名和密码，authenticator阀门调用下一个用于处理请求servlet的阀门。如果验证失败，authenticator不唤醒下一个阀门直接返回。由于验证失败，用户并不能看到请求的servlet。 在用户验证的时候authenticator阀门调用的是上下文域（realm）内的authenticate方法，将用户名和密码传递给它。该容器域可以访问合法的用户名密码。 本章首先介绍跟安全性相关的类（realms、principal、roles），然后通过一个应用程序演示了如何在你的servlets上使用安全管理。
  注意
  这里假设你已经熟悉servlet编程安全性的相关概念，包括：主要principals, 角色roles,域 realms, 登陆配置login configuration等。如果对这些概念还不清楚可以阅读《Java for the Web with Senlets, JSP, and EJB》或者其它相关书籍
  （域）Realm
  域是用于进行用户验证的一个组件，它可以告诉你一个用户名密码对是否是合法的。一个域跟一个上下文容器相联系，一个容器可以只有一个域。可以使用容器的setRealm方法来建立它们之间的联系。 一个域是如何验证一个用户的合法性的？一个域拥有所有的合法用户的密码或者是可以访问它们。至于它们存放在哪里则取决于域的实现。在Tomcat的默认实现里，合法用户被存储在tomcat-users.xml文件里。但是可以使用域的其它实现来访问其它的源，如关系数据库。 在Catalina中，一个域用接口org.apache.catalina.Realm表示。该接口最重要的方法是四个authenticate方法： public Principal authenticate(String username, String credentials); public Principal authenticate(String username, byte[] credentials); public Principal authenticate(String username, String digest, String nonce, String nc, String cnonce, String qop, String realm, String md5a2); public Principal authenticate(X509Certificate certs[]);
  第一个方法是最常用的方法，Realm接口还有一个getRole方法，签名如下： public boolean hasRole(Principal principal, String role); 另外，域还有getContainer和setContainer方法用于建立域与容器的联系。 一个域的基本上实现是抽象类org.apache.catalina.realm.RealmBase。org.apache.catalina.realm包中海提供了其它一些类继承了RealmBase如：JDBCRealm, JNDIRealm, MemoryRealm,和 UserDatabaseRealm。默认情况下使用的域是MemoryRealm。
  注意
  在Catalina中，验证器阀门使用相关域的authenticate来验证一个用户
  GenericPrincipal
  一个principal使用java.security.Principal接口来表示，Tomcat中该接口的实现为org.apache.catalina.realm.GenericPrincipal接口。一个GenericPrincipal必须跟一个域相关联，这个是通过构造函数实现的： public GenericPrincipal(Realm realm, String name, String password) { this(realm, name, password, null); } public GenericPrincipal(Realm realm, String name, String password, List roles) { super(); this.realm = realm; this.name = name; this.password = password; if (roles != null) { this.roles = new String[roles.size()]; this.roles = (String[]) roles.toArray(this.roles); if (this.roles.length > 0) Arrays.sort(this.roles); } } GenericPrincipal必须拥有一个用户名和一个密码，此外还可选择性的传递一列角色。可以使用hasRole方法来检查一个principal是否有一个特定的角色，传递的参数为角色的字符串表示形式。这里是Tomcat4中的hasRole方法： public boolean hasRole(String role) { if (role == null) return (false); return (Arrays.binarySearch(roles, role) >= 0); } Tomcat5支持servlet2.4所以必须支持用*来匹配任何角色。 public boolean hasRole(String role) { if ("*".equals(role)) // Special 2.4 role meaning everyone
  return true; if (role == null) return (false); return (Arrays.binarySearch(roles, role) >= 0); } LoginConfig类
  一个login configuration包括一个域名，用org.apache.catalina.deploy.LoginConfig类表示。LoginConfig的实例封装了域名和验证要用的方法。可以使用LoginConfig实例的getRealmName方法来获得域名，可以使用getAuthName方法来验证用户。一个验证（authentication）的名字必须是下面的之一：BASIC, DIGEST, FORM, o或者CLIENT-CERT。如果用到的是基于表单（form）的验证，该LoginConfig对象还包括登录或者错误页面像对应的URL。 Tomcat一个部署启动的时候，先读取web.xml。如果web.xml包括一个login-confgi元素，Tomcat创建一LoginConfig对象并相应的设置它的属性。验证阀门调用LoginConfig的getRealmName方法并将域名发送给浏览器显示登录表单。如果getRealmName名字返回值为null，则发送给浏览器服务器的名字和端口名。图10.1是IE6的验证会话。
  Figure 10.1: The basic authentication dialog
  Authenticator类
  org.apache.catalina.Authenticator接口用来表示一个验证器。该方接口并没有方法，只是一个组件的标志器，这样就能使用instanceof来检查一个组件是否为验证器。
  Catalina提供了Authenticator接口的基本实现：org.apache.catalina.authenticator.AuthenticatorBase类。除了实现Authenticator接口外，AuthenticatorBase还继承了org.apache.catalina.valves.ValveBase类。这就是说AuthenticatorBase也是一个阀门。可以在org.apache.catalina.authenticator包中找到该接口的几个类：BasicAuthenticator用于基本验证, FormAuthenticator用于基于表单的验证, DigestAuthentication用于摘要（digest）验证, SSLAuthenticator用于SSL验证。NonLoginAuthenticator用于Tomcat没有指定验证元素的时候。NonLoginAuthenticator类表示只是检查安全限制的验证器，但是不进行用户验证。 org.apache.catalina.authenticator包中类的UML结构图如图10.2所示：
  Figure 10.2: Authenticator-related classes
  一个验证器的主要工作是验证用户。因此，AuthenticatorBase类的invoke方法调用了抽象方法authenticate，该方法的具体实现由子类完成。在BasicAuthenticator中，它authenticate使用基本验证器来验证用户。 安装Authenticator阀门 在部署文件中，只能出现一个login-config元素，login-config元素包括了auth-method元素用于定义验证方法。这也就是说一个上下文容器只能有一个LoginConfig对象来使用一个authentication的实现类。 AuthenticatorBase的子类在上下文中被用作验证阀门，这依赖于部署文件中auth-method元素的值。表10.1为auth-method元素的值，可以用于确定验证器。
  Table 10.1: The authenticator implementation class
  Value of the auth-method element
  Authenticator class
  BASIC
  BasicAuthenticator
  FORM
  FormAuthenticator
  DIGEST
  DigestAuthenticator
  CLIENT-CERT
  SSLAuthenticator
  如果没有使用auth-method值，则认为LoginConfig对象的auth-method属性值为

  ## 第十一章：`StandardWrapper`

  在第五章中已经说过，一共有四种容器：engine（引擎）,host（主机）,context（上下文）和wrapper（包装器）。在前面的章节里也介绍了如何建立自己的context和wrapper。一个上下文一般包括一个或者多个包装器，每一个包装器表示一个servlet。本章将会看到Catalina中Wrapper接口的标准实现。首先介绍了一个HTTP请求会唤醒的一系列方法，接下来介绍了javax.servlet.SingleThreadModel接口。最后介绍了StandardWrapper和StandardWrapperValve类。本章的应用程序说明了如何用StandardWrapper实例来表示servlet。
  方法调用序列Sequence of Methods Invocation 对于每一个连接，连接器都会调用关联容器的invoke方法。接下来容器调用它的所有子容器的invoke方法。例如，如果一个连接器跟一个StadardContext实例相关联，那么连接器会调用StandardContext实例的invoke方法，该方法会调用所有它的子容器的invoke方法。图11.1说明了一个连接器收到一个HTTP请求的时候会做的一系列事情。
  Figure 11.1: The collaboration diagram of methods invocation
  · The StandardContextValve's invoke method obtains the appropriate wrapper to serve the request and calls the wrapper's invoke method. · 连接器创建请求和响应对象
  · 连接器调用StandardContext的invoke方法
  · StandardContext的invoke方法必须调用该上下文容器的流水线的invoke方法，所以StandardContext的流水线会调用StandardContextValve的invoke方法
  · StandardContextValve的invoke方法得到合适的包装器来对请求进行服务并调用包装器的invoke方法 · StandardWrapper是包装器的标准实现，StandardWrapper对象的invoke方法调用流水线的invoke方法。 · StandardWrapper流水线的基本阀门时StandardWrapperValve。因此StandardWrapperValve的invoke方法会被调用。StandardWrapperValve的invoke方法会调用包装器的allocate方法获得一个servlet的实例。 · 当一个servlet需要被加载的时候，方法allocate调用方法load来加载一个servlet · 方法load会调用servlet的init方法
  注意
  StandardContext类的构造函数设置StandardContextValve实例为它的基本阀门 publicStandardContext() {
  super(); pipeline.setBasic(new StandardContextValve()); namingResources.setContainer(this); }
  注意
  StandardWrapper类的构造函数将StandardWrapperValve作为它的基本阀门 public StandardWrapper() { super(); pipeline.setBasic(new StandardWrapperValve()); }
  本章关注的是一个servlet被调用的时候发生的细节。因此我们需要自习看StandardWrapper和StandarWrapperValve类。在学习它们之前，我们需要首先关注下javax.servlet.SingleThreadModel。理解该接口对于理解一个包装器是如何工作的是非常重要的。 SingleThreadModel 一个servlet可以实现javax.servlet.SingleThreadModel接口，实现此接口的一个servlet通俗称为SingleThreadModel（STM）的程序组件。根据Servlet规范，实现此接口的目的是保证servlet一次只能有一个请求。Servlet 2.4规范的第SRV.14.2.24节（Servlet 2.3的有SingleThreadModel接口上的类似说明）
  · 如果一个Servlet实现此接口，将保证不会有两个线程同是使用servlet的service方法。 servlet容器可以保证同步进入一个servlet的一个实例，或维持的
  Servlet实例池和处理每个新请求。该接口并不能避免同步而产生的问题，如访问静态类变量或该servlet以外的类或变量。 很多程序员并没有仔细阅读它，只是认为实现了SIngleThreadModel就能保证它们的servlet是线程安全的。单显然并非如此，重新阅读上面的引文。 一个servlet实现了SIngelThreadModel之后确实能保证它的service方法不会被两个线程同时使用。为了提高servlet容器的性能，可以创建STM servlet的多个实例。
  False Sense of Multi-Thread Safety
  该SingleThreadModel接口在Servlet 2.4中已经废弃，因为它使Servlet程序员产生虚假的安全感，认为它是线程安全的。然而，无论Servlet 2.3和Servlet 2.4的容器仍然必须支持此接口
  注意
  可以在下面网址看到SingleThreadModel的相关讨论 http://w4.metronet.com/~wjm/tomcat/ToFeb11/msg02655.html.
  StandardWrapper
  一个StandardWrapper对象的主要职责是：加载它表示的servlet并分配它的一个实例。该StandardWrapper不会调用servlet的service方法。这个任务留给StandardWrapperValve对象，在StandardWrapper实例的基本阀门管道。StandardWrapperValve对象通过调用StandardWrapper的allocate方法获得Servlet实例。在获得Servlet实例之后的StandardWrapperValve调用servlet的service方法 在servlet第一次被请求的时候，StandardWrapper加载servlet类。它是动态的加载servlet，所以需要知道servlet类的完全限定名称。通过StandardWrapper类的setServletClass方法将servlet的类名传递给StandardWrapper。另外，使用setName方法也可以传递servlet名。 考虑到StandardWrapper负责在StandardWrapperValve请求的时候分配一个servlet实例，它必须考虑一个servlet是否实现了SingleThreadModel接口。 如果一个servlet没有实现SingleThreadModel接口，StandardWrapper加载该servlet一次，对于以后的请求返回相同的实例即可。StandardWrapper假设servlet的service方法是现场安全的，所以并没有创建servlet的多个实例。如果需要的话，由程序员自己解决资源同步问题。
  对于一个STM servlet，情况就有所不同了。StandardWrapper必须保证不能同时有两个线程提交STM servlet的service方法。如果StandardWrapper维持一个STM servlet的实例，下面是它如何调用servlet的service方法： Servlet instance = <get an instance of the servlet>; if ((servlet implementing SingleThreadModel>) { synchronized (instance) { instance.service(request, response);
  } } else { instance.service(request, response); } 但是，为了性能起见，StandardWrapper维护了一个STM servlet实例池。 一个包装器还负责准备一个javax.servlet.ServletConfig的实例，这可以在servlet内部完成，接下来两小节讨论如何分配和加载servlet。
  Allocating the Servlet
  在本节开始的时候介绍到StandardWrapperValve的invoke方法调用了包装器的allocate方法来获得一个请求servlet的实例。因此StandardWrapper类必须实现该接口。该方法的签名如下： public javax.servlet.Servlet allocate() throws ServletException; 注意allocate方法返回的是请求servlet的一个实例。 由于要支持STM servlet，这使得该方法更复杂了一点。实际上，该方法有两部分组成，一部分负责非STM servlet的工作，另一部分负责STM servlet。第一部分的结构如下： if (!singleThreadModel) { // returns a non-STM servlet instance }
  布尔变量singleThreadModel负责标志一个servlet是否是STM servlet。它的初始值是false，loadServlet方法会检测加载的servlet是否是STM的，如果是则将它的值该为true。loadServlet方法在下面会介绍到。 该方法的第二部分处理singleThreadModel为true的情况，第二部分的框架如下： synchronized (instancepool) { // returns an instance of the servlet from the pool } 现在来看一下第一部分和第二部分。 对于非STM servlet，StandardWrapper定义一个java.servlet.Servlet类型的实例 private Servlet instance = null; 方法allocate检查该实例是否为null，如果是调用loadServlet方法来加载servlet。然后增加contAllocated整型并返回该实例。 if (!singleThreadModel) { // Load and initialize our instance if necessary
  if (instance == null) { synchronized (this) { if (instance == null) { try { instance = loadServlet(); } catch (ServletException e) { throw e; } catch (Throwable e) { throw new ServletException (sm.getString("standardWrapper.allocate"), e); } } } } if (!singleThreadModel) { if (debug >= 2) log(" Returninq non-STM instance"); countAllocated++; return (instance); } }
  如果StandardWrapper表示的是一个STM servlet，方法allocate尝试返回池中的一个实例，变量intancePool是一个java.util.Stack类型的STM servlet实例池。 private Stack instancePool = null; 该变量在loadServlet方法内初始化，该部分在接下来的小节进行讨论。 方法allocate负责分配STMservlet实例，前提是实例的数目不超过最大数目，该数目由maxInstances整型定义，默认值是20. private int maxInstances = 20; StandardWrapper提供了nInstances整型变量来定义当前STM 实例的个数。 private int nInstances = 0; 这里是allocate方法的第二部分 synchronized (instancePool) { while (countAllocated >= nInstances) { // Allocate a new instance if possible, or else wait if (nInstances < maxInstances) { try { instancePool.push(loadServlet()); nInstances++;
  } catch (ServletException e) { throw e; } catch (Throwable e) { throw new ServletException (sm.getString("StandardWrapper.allocate"), e); } } else { try { instancePool.wait(); } catch (InterruptedException e) { ; } } } if (debug >= 2) log(" Returning allocated STM instance"); countAllocated++; return (Servlet) instancePool.pop();
  } 上面的代码使用一个while循环等待直到nInstances的数目少于或等于countAllocated（应该是多余或等于把！！）。在循环里，allocate方法检查nInstance的值，如果低于maxInstances的值，调用loadServlet方法并将该实例添加到池中，增加nInstances的值。如果nInstances的值等于或大于maxInstances的值，它调用实例池堆栈的wait方法，知道一个实例被返回。
  Loading the Servlet
  StandardWrapper实现了Wrapper接口的load方法，load方法调用loadServlet方法来加载一个servlet类，并调用该servlet的init方法，传递一个javax.servlet.ServletConfig实例。这里是loadServlet是如何工作的。 方法loadServlet首先检查StandardWrapper是否表示一个STM servlet。如果不是并且该实例不是null（即以前已经加载过），直接返回该实例： // Nothing to do if we already have an instance or an instance pool if (!singleThreadModel && (instance != null)) return instance; 如果该实例是null或者是一个STM servlet，继续该方法的其它部分：.
  首先获得System.out 和System.err输出，接下来以就可以使用javax.servlet.ServletContext 的log方法来记录信息 PrintStream out = System.out; SystemLogHandler.startCapture(); 然后，定义了一个javax.servlet.Servlet类型的变量，它表示loadServlet方法加载servlet后返回的实例。 Servlet servlet = null; 方法loadServlet负责加载servlet类，类名应该被分配给servletClass变量，该方法将该值分配给一个String类型变量actualClass。 String actualClass = servletclass; 但是，由于Catalina也是一个JSP容器，在请求的是JSP页面的时候，loadServlet必须也能工作，如果是JSP页面，则得到相应的Servlet类。 if ((actualClass == null) && (jspFile != null)) { Wrapper jspWrapper = (Wrapper) ((Context) getParent()).findChild(Constants.JSP_SERVLET_NAME); if (jspWrapper != null) actualClass = jspWrapper.getServletClass(); } 如果JSP页面的Servlet名字找不到，就是用servletclass变量的值。但是，如果该变量的值没有使用StandardWrapper类中的setServletClass方法设置，会产生异常，剩余部分不会被执行。 // Complain if no servlet class has been specified if (actualClass == null) { unavailable(null); throw new ServletException (sm.getString("StandardWrapper.notClass", getName())); } 现在，servlet的名字已经获得了，接下来是loadServlet方法获得加载器。如果找不到加载器，则产生异常并停止执行。 // Acquire an instance of the class loader to be used Loader loader = getLoader(); if (loader == null) { unavailable(null); throw new ServletException (sm.getString("StandardWrapper.missingLoader", getName())); } 如果找到加载器，loadServlet方法调用它的getClassLoader方法获得一个ClassLoader。 ClassLoader classLoader = loader.getClassLoader();
  Catalina提供了特殊Servlet，从属于org.apache.catalina包。这些Servlet可以进入Servlet容器的内部。如果该Servlet是一个特殊Servlet，isContainerProvidedServlet方法返回true值。classLoader会获得另一个ClassLoader的实例，这样就可以访问Catalina的内部了。 // Special case class loader for a container provided servlet if (isContainerProvidedServlet(actualClass)) { ClassLoader = this.getClass().getClassLoader(); log(sm.getString ("standardWrapper.containerServlet", getName())); } 有了类加载器和腰加载的Servlet名字，就可以使用loadServlet方法来加载类了。 // Load the specified servlet class from the appropriate class // loader Class classClass = null; try { if (ClassLoader != null) { System.out.println("Using classLoader.loadClass"); classClass = classLoader.loadClass(actualClass); } else { System.out.println("Using forName"); classClass = Class.forName(actualClass); } } catch (ClassNotFoundException e) { unavailable(null); throw new ServletException (sm.getstring("standardWrapper.missingClass", actualClass), e); } if (classClass == null) { unavailable(null); throw new ServletException (sm.getString("standardWrapper.missingClass", actualClass)); } Then, it can instantiate the servlet. // Instantiate and initialize an instance of the servlet class // itself try { servlet = (Servlet) classClass.newInstance(); } catch (ClassCastException e) { unavailable(null);
  // Restore the context ClassLoader throw new ServletException (sm.getString("standardWrapper.notServlet", actualClass), e); } catch (Throwable e) { unavailable(null); // Restore the context ClassLoader throw new ServletException (sm.getstring("standardWrapper.instantiate", actualClass), e);
  } 但是，loadServlet方法在初始化Servlet之前，它使用isServletAllowed方法来检查该Servlet是否可以访问。 // Check if loading the servlet in this web application should be // allowed if (!isServletAllowed(servlet)) { throw new SecurityException (sm.getString("standardWrapper.privilegedServlet", actualClass)); } 如果通过了安全性检查，接下来检查该Servlet是否是一个ContainerServlet。ContainerServlet是实现了org.apache.catalina.ContainerServlet接口的Servlet，它可以访问Catalina的内部函数。如果该Servlet是ContainerServlet，loadServlet方法调用ContainerServlet的setWrapper方法，传递该StandardWrapper实例。 // Special handling for ContainerServlet instances if ((servlet instanceof ContainerServlet) && isContainerProvidedServlet(actualClass)) { ((ContainerServlet) servlet).setWrapper(this); } 接下来loadServlet方法触发BEFORE_INIT_EVENT事件，并调用发送者的init方法。 try { instanceSupport.fireInstanceEvent( InstanceEvent.BEFORE_INIT_EVENT, servlet); servlet.init(facade); 注意该方法传递一个façade变量，改变量是一个javax.servlet.ServletConfig对象。怎样创建一个ServletConfig对象会在本章的Creating ServletConfig小节看到。 如果loadOnStartup变量的值大于零并且Servlet是一个JSP页面，调用该Servlet的service方法。
  // Invoke jspInit on JSP pages if ((loadOnStartup > 0) && (jspFile != null)) { // Invoking jspInit HttpRequestBase req = new HttpRequestBase(); HttpResponseBase res = new HttpResponseBase(); req.setServletPath(jspFile}; req.setQueryString("jsp_precompile=true"); servlet.service(req, res); }
  接下来，loadServlet方法触发AFTER_INIT_EVENT事件 instanceSupport.firelnstanceEvent (InstanceEvent.AFTER_INIT_EVENT, servlet); 如果该StandardWrapper对象表示的是一个STM Servlet，将该实例添加到实例池中，因此，如果实例池如果为null，首先需要创建它。 // Register our newly initialized instance singleThreadModel = servlet instanceof SingleThreadModel; if (singleThreadModel) { if (instancePool == null) instancePool = new Stack(); } fireContainerEvent("load", this); } 在finally块中，loadservlet方法会停止捕获System.out和System.err，并将加载过程中信息使用该容器的log方法记录到日志系统中。 finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { if (getServletContext() != null) { getServletContext().log(log); } else { out.println(log); } } } 最后，loadServlet方法返回Servlet实例。 return servlet;
  ServletConfig对象
  StandardWrapper的loadServlet方法在加载了loaded方法之后调用的发送者的init方法 。init方法传递一个javax.servlet.ServletConfig实例，你可能想知道一个StandardWrapper对象如何获得ServletConfig对象。 只要看StandardWrapper类即可，该类实现javax.servlet.ServletConfig接口和Wrapper接口。
  ServletConfig接口有以下四个方法getServletContext, getServletName, getInitParameter, 和getInitParameterNames。接下来看StandardWrapper对这四个类的实现。
  注意
  StandardWrapper并不将自己传递给Servlet的init方法，它将自己包装到一个StandardWrapperFacade实例中来因此它的public方法。可以在StandardWrapperFacade一节看到这些内容。
  getServletContext
  该方法的签名如下： public ServletContext getServletContext() 一个StandardWrapper实例必须是一个StandardContext容器的子容器。也就是说，StandardWrapper的父容器时StandardContext。可以使用StandardContext 对象的getServletContext来获得ServletContext对象。这里是StandardWrapper中方法getServletContext的实现 public ServletContext getServletContext() { if (parent == null) return (null); else if (!(parent instanceof Context)) return (null); else return (((Context) parent).getServletContext()); }
  注意
  现在你知道不能单独部署一个包装器来表示一个Servlet，包装器必须从属于一个上下文容器，这样才能使用ServletConfig对象使用getServletContext方法获得一个ServletContext实例。
  getServletName
  该方法返回Servlet的名字，该方法签名如下： public java.lang.String getServletName() 这里是getServletName方法在StandardWrapper类中实现：
  public String getServletName() { return (getName()); } 它简单的调用StandardWrapper 的父类ContainerBase类的getName方法，该方法如下在ContainerBase中如下实现： public String getName() { return (name); } 可以使用setName方法来设置name的值。回忆是如何调用StandardWrapper实例的setName方法来传递Servlet的name的。
  getInitParameter
  该方法返回指定参数的值，该方法的签名如下： public java.lang.String getInitParameter(java.lang.String name) 在StandardWrapper中，初始化参数被存放在一个名为parameters的HashMap中 private HashMap parameters = new HashMap(); 可以调用StandardWrapper类的addInitParameter方法来填充parameters。传递参数的名字和值。 public void addInitParameter(String name, String value) { synchronized (parameters) { parameters.put(name, value); } fireContainerEvent("addInitParameter", name); } 下面是StandardWrapper对getInitParameter的实现： public String getInitParameter(String name) { return (findInitParameter(name)); } 方法findInitParameter的参数为参数名，并调用parameters HashMap的get方法。下面是findInitParameter的实现： public String findInitParameter(String name) {
  synchronized (parameters) { return ((String) parameters.get(name)); } }
  getInitParameterNames
  该方法返回所有初始化参数名字的枚举（Enumeration），它的签名如下： public java.util.Enumeration getInitParameterNames() 下面是StandardWrapper类中getInitParameterNames的实现： public Enumeration getInitParameterNames() { synchronized (parameters) { return (new Enumerator(parameters.keyset())); } } Enumerator实现了java.util.Enumeration接口，是org.apache.catalina.util包的一部分。
  Parent and Children
  一个包装器表示一个独立Servlet的容器。这样，包装器就不能再有子容器，因此不可以调用它的addChild方法，如果调用了会得到一个java.langIllegalStateException。这里是StandardWrapper对addChild方法的实现： public void addChild(Container child) { throw new IllegalStateException (sm.getString("StandardWrapper.notChild")); } 一个包装器的父容器只能是一个上下文容器。如果传递的参数不是一个上下文容器，它的setParent方法会抛出java.lang.IllegalArgumentException。 public void setParent(Container container) { if ((container != null) && !(container instanceof Context)) throw new IllegalArgumentException (sm.getString("standardWrapper.notContext")); super.setParent(container); } StandardWrapperFacade
  StandardWrapper调用它价值的Servlet的init方法。该方法需要一个javax.servlet.ServletConfig的参数，而StandardWrapper类自己就实现了ServletConfig接口。所以，理论上StandardWrapper可以将它自己作为参数传递给init方法。但是StandardWrapper需要对Servlet隐藏他的大多数public方法。为了实现这一点，StandardWraper将它自己包装的一个StandardWrapperFacade实例中。图11.2表示了StandardWrapper 和
  StandardWrapperFacade的实现，它们都实现了java.servlet.ServletConfig接口。
  Figure 11.2: The relationship between StandardWrapper and StandardWrapperFacade 下面几行是StandardWrapperFacade的构造函数，它获得一个StandardWrapper类型的参数。 private StandardWrapperFacade facade = new StandardWrapperFacade(this); StandardWrapperFacade类有一个ServletConfig类型的类级变量config private ServletConfig config = null; 当一个StandardWrapperFacade对象创建的时候，构造函数将该StandardWrapper负值给config变量 public StandardWrapperFacade(StandardWrapper config) { super(); this.config = (ServletConfig) config; }
  因此，当StandardWrapper对象调用Servlet实例的init方法的时候，它传递的是一个StandardWrapperFacade对象。在Servlet内部调用ServletConfig的getServletName, getInitParameter, 和getInitParameterNames方法只需要调用它们在StandardWrapper的实现就行。 public String getServletName() { return config.getServletName(); } public String getInitParameter(String name) { return config.getInitParameter(name); } public Enumeration getInitParameterNames() { return config.getInitParameterNames(); } 调用getServletContext方法稍微复杂点： public ServletContext getServletContext() {
  ServletContext theContext = config.getServletContext(); if ((theContext != null) && (theContext instanceof ApplicationContext)) theContext = ((ApplicationContext) theContext).getFacade(); return (theContext); } Gauge方法调用StandardWrapper类的getServletContext方法，但是它返回一个ServletContext的外观对象，而不是ServletContext对象自己。
  StandardWrapperValve
  StandardWrapperValve是StandardWrapper实例上的基本阀门，该阀门做两件事情： · 提交Servlet的所有相关过滤器 · 调用发送者的service方法 要实现这些内容，下面是StandardWrapperValve在他的invoke方法要实现的： · 调用StandardWrapper的allocate的方法来获得一个servlet实例 · 调用它的private createFilterChain方法获得过滤链 · 调用过滤器链的doFilter方法。包括调用servlet的service方法 · 释放过滤器链 · 调用包装器的deallocate方法 · 如果Servlet无法使用了，调用包装器的unload方法 接下来是invoke方法： // Allocate a servlet instance to process this request try { if (!unavailable) { servlet = wrapper.allocate(); } } ... // Acknowlege the request try { response.sendAcknowledgement(); } ... // Create the filter chain for this request ApplicationFilterChain filterChain = createFilterChain(request, servlet); // Call the filter chain for this request
  // This also calls the servlet's servicet() method try { String jspFile = wrapper.getJspFile(); if (jspFile != null) sreq.setAttribute(Globals.JSP_FILE_ATTR, jspFile); else sreq.removeAttribute(Globals.JSP_FILE_ATTR); if ((servlet != null) && (filterChain != null)) { filterChain.doFilter(sreq, sres); } sreq.removeAttribute(Globals.JSP_FILE_ATTR); } ... // Release the filter chain (if any) for this request try { if (filterChain != null) filterChain.release(); } ... // Deallocate the allocated servlet instance try { if (servlet != null) { wrapper.deallocate(servlet); } } ... // If this servlet has been marked permanently unavailable, // unload it and release this instance try { if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) { wrapper.unload(); }
  } ... 最重要的方法是createFilterChain方法并调用过滤器链的doFilter方法。方法createFilterChain创建了一个ApplicationFilterChain实例，并将所有的过滤器添加到上面。ApplicationFilterChain类将在下面的小节中介绍。要完全的理解这个类，还需要理解FilterDef和ApplicationFilterConfig类。这些内容将在下面介绍 FilterDef
  org.apache.catalina.deploy.FilterDef表示一个过滤器定义，就像是在部署文件中定义一个过滤器元素那样。Listing11.1展示了该类：
  Listing 11.1: The FilterDef class package org.apache.catalina.deploy; import java.util.HashMap; import java.util.Map; public final class FilterDef { /** * The description of this filter. */ private String description = null; public String getDescription() { return (this.description); } public void setDescription(String description) { this.description = description; } /** * The display name of this filter. */ private String displayName = null; public String getDisplayName() { return (this.displayName); } public void setDisplayName(String displayName) { this.displayName = displayName; } /**

* The fully qualified name of the Java class that implements this * filter. */ private String filterClass = null; public String getFilterClass() { return (this.filterClass); } public void setFilterclass(String filterClass) { this.filterClass = filterClass; }
  /** * The name of this filter, which must be unique among the filters * defined for a particular web application. */ private String filterName = null; public String getFilterName() { return (this.filterName); } public void setFilterName(String filterName) { this.filterName = filterName; } /** * The large icon associated with this filter. */ private String largeIcon = null; public String getLargeIcon() { return (this.largeIcon); } public void setLargeIcon(String largeIcon) { this.largeIcon = largeIcon; } /** * The set of initialization parameters for this filter, keyed by * parameter name. */ private Map parameters = new HashMap(); public Map getParameterMap() { return (this.parameters); } /** * The small icon associated with this filter. */ private String smallIcon = null; public String getSmallIcon() { return (this.smallIcon); } public void setSmallIcon(String smallIcon) { this.smallIcon = smallIcon; } public void addInitParameter(String name, String value) {
  parameters.put(name, value);
  } /** * Render a String representation of this object. */ public String toString() { StringBuffer sb = new StringBuffer("FilterDef["); sb.append("filterName="); sb.append(this.filterName); sb.append(", filterClass="); sb.append(this.filterClass); sb.append("]"); return (sb.toString()); } }
  FilterDef类中的每一个属性都代表一个可以在过滤器中出现的子元素。该类包括一个Map类型的变量表示一个包含所有初始参数的Map。方法addInitParameer添加一个name/value对到该Map。
  ApplicationFilterConfig
  org.apache.catalina.core.ApplicationFilterConfig实现了javax.servlet.FilterConfig接口。ApplicationFilterConfig负责管理web应用程序启动的时候创建的过滤器实例。 传递一个org.apache.catalina.Context对象和ApplicationFilterConfig对象给ApplicationFilterConfig的构造来创建一个ApplicationFilterConfig实例： public ApplicationFilterConfig(Context context, FilterDef filterDef) throws ClassCastException, ClassNotFoundException, IllegalAccessException, InstantiationException, ServletException Context对象表示一个一个web应用而FilterDef表示一个过滤器定义。ApplicationFilterConfig的getFilter方法可以返回一个javax.servlet.Filter方法，该方法加载过滤器类并初始化它。 Filter getFilter() throws ClassCastException, ClassNotFoundException, IllegalAccessException, InstantiationException, ServletException { // Return the existing filter instance, if any if (this.filter != null) return (this.filter); // Identify the class loader we will be using
  String filterClass = filterDef.getFilterClass(); ClassLoader classLoader = null; if (filterClass.startsWith("org.apache.catalina.")) classLoader = this.getClass().getClassLoader(); else classLoader = context.getLoader().getClassLoader(); ClassLoader oldCtxClassLoader = Thread.currentthread().getContextClassLoader(); // Instantiate a new instance of this filter and return it Class clazz = classLoader.loadClass(filterClass); this.filter = (Filter) clazz.newInstance(); filter.init(this); return (this.filter); }
  ApplicationFilterChain
  org.apache.catalina.core.ApplicationFilterChain类是实现了javax.servlet.FilterChain接口。StandardWrapperValve类中的invoke方法创建一个该类的实例并且调用它的doFilter方法。ApplicationFilterChain类的doFilter的调用该链中第一个过滤器的doFilter方法。Filter接口中doFilter方法的签名如下： public void doFilter(ServletRaquest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException ApplicationFilterChain的doFilter方法，并将它自己作为第三个参数传递给它。 在他的doFilter方法中，一个过滤器可以调用另一个过滤器链的doFilter来唤醒另一个过来出去。这里是一个过滤器的doFilter实现的例子 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // do something here ... chain.doFilter(request, response); } 如你看到的，在doFilter方法最好一行，它调用过滤链的doFilter方法。如果该过滤器是过滤链的最后一个过滤器，它叫调用请求的Servlet的service方法。如果过滤器没有调用chain.doFilter，下一个过滤器就不会被调用。
  The Application
  本应用程序有两个类组成x11.pyrmont.core.SimpleContextConfig 和ex11.pyrmont.startup.Bootstrap。SimpleContextConfig类是前一章程序里的副本，而Bootstrap类如Listing11.2所示：
  Listing 11.2: The Bootstrap class package ex11.pyrmont.startup; //use StandardWrapper import ex11.pyrmont.core.SimpleContextConfig; import org.apache.catalina.Connector; import org.apache.catalina.Context; import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleListener; import org.apache.catalina.Loader; import org.apache.catalina.Wrapper; import org.apache.catalina.connector.http.HttpConnector; import org.apache.catalina.core.StandardContext; import org.apache.catalina.core.StandardWrapper; import org.apache.catalina.loader.WebappLoader; public final class Bootstrap { public static void main(String[] args) { System.setProperty("catalina.base", System.getProperty("user.dir")); Connector connector = new HttpConnector(); Wrapper wrapper1 = new StandardWrapper(); wrapper1.setName("Primitive"); wrapper1.setServletClass("PrimitiveServlet"); Wrapper wrapper2 = new StandardWrapper(); wrapper2.setName("Modern"); wrapper2.setServletClass("ModernServlet"); Context context = new StandardContext(); // StandardContext's start method adds a default mapper context.setPath("/myApp"); context.setDocBase("myApp"); LifecycleListener listener = new SimpleContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); context.addChild(wrapper1); context.addChild(wrapper2); // for simplicity, we don't add a valve, but you can add // valves to context or wrapper just as you did in Chapter 6 Loader loader = new WebappLoader(); context.setLoader(loader); // context.addServletMapping(pattern, name); context.addServletMapping("/Primitive", "Primitive");
  context.addServletMapping("/Modern", "Modern"); // add ContextConfig. This listener is important because it // configures StandardContext (sets configured to true), otherwise // StandardContext won't start
  connector.setContainer(context); try { connector.initialize(); ((Lifecycle) connector).start(); ((Lifecycle) context).start(); // make the application wait until we press a key. System.in.read(); ((Lifecycle) context).stop(); } catch (Exception e) { e.printStackTrace(); } } }
  Bootstrap创建一个StandardContext实例并调用它的myApp。Bootstrap类在该StandardContext容器中，添加了两个StandardWrapper实例：Primitive和Modern
  Running the Applications
  要在Windows中运行该应用程序，可以在工作目录下面使用如下命令： java -classpath ./lib/servlet.jar;./lib/commons-collections.jar;./ ex11.pyrmont.startup.Bootstrap 在Linux中，需要使用分号来分开两个库 java -classpath ./lib/servlet.jar:./lib/commons-collections.jar:./ ex11.pyrmont.startup.Bootstrap 可以在浏览器中输入如下URL来调用PrimitiveServlet http://localhost:8080/Primitive 使用如下URL来调用ModernServlet http://localhost:8080/Modern 总结
  在本章中，你学习到了Wrapper接口在Catalina中的标准实现StandardWrapper类。并且接受了过滤器以及跟过滤器相关的类。在本章的最后接受了一个使用StandardWrapper类的应用程序。

  ## 第十二章：`StandardContext`

  综述 在前面的章节中已经看到，一个上下文容器（Context）代表一个web应用，每一个上下文包括多个包装器（Wrapper），每个包装器代表一个Servlet。但是，上下文还需要其它的一些组件如加载器和管理器。本章要介绍Catalina中Context接口的标准实现，org.apache.catalina.core.StandardContext类。 我们首先介绍StandardContext对象的初始化和配置，然后讨论跟其相关的类StandardContextMapper（Tomcat 4）和ContextConfig类。接下来看，当容器接受到HTTP请求的时候方法调用顺序。然后，在讨论该类几点重要特性，最后一节讨论Tomcat5中的backgroundProcess方法。
  注意
  本章没有相关配套的应用程序，StandardContext类已经在11章中用过了
  StandardContext配置
  创建一个StandardContext实例之后，必须调用它的start方法，这样它就能为受到的HTTP请求服务了。一个StandardContext对象可能启动失败，这时候属性available被设置为false，属性available表示了StandardContext对象的可用性。 如果start方法启动成功，StandardContext对象需要配置它的属性。在一个Tomcat部署中，StandardContext的配置过程做了以下事情：准备读取和解析%CATALINA_HOME%/conf 目录下面的web.xml，部署所有应用程序，确保StandardContext实例可以处理应用级别的web.xml。另外，配置需要添加一个验证器阀门和证书阀门（authenticator valve and a certificate valve）
  注意
  更多StandardContext配置的细节将在15章中讨论。
  StandardContext的属性之一是它属性configured,用来表示该StandardContext是否已经配置了。StandardContext使用一个事件监听器来作为它的配置器。当StandardContext实例的start方法被调用的时候，首先触发一个生命周期事件。该事件唤醒一个监听器来配置该StandardContext实例。配置成功后，该监听器将configured属性设置为true。否则，StandardContext对象拒绝启动，这样就不能对HTTP请求进行服务了。
  在第11章中已经看到一个生命周期监听器被添加到StandardContext实例上，它的类型是ch11.pyrmont.core.SimpleContextConfig，它仅仅将StandardContext实例的configured属性设置为true，这样就认为配置完成了。在一个Tomcat部署中，配置StandardContext的生命周期监听器类型为org.apache.catalina.startup.ContextConfig，具体内容将在第15章中进行介绍。 现在你应该已经明白了配置过程对于StandardContext的重要性，接下来看更多StandardContext类的细节，首先是它的构造函数。
  StandardContext构造函数
  下面是StandardContext类的构造函数： public StandardContext() { super(); pipeline.setBasic(new StandardContextValve()); namingResources.setContainer(this); }
  在构造函数中，最重要的事情是在StandardContext的流水线上添加了一个类型为org.apache.catalina.core.StandardContextValve的基本阀门，该阀门用于裁判美国连接器获得HTTP请求。
  启动StandardContext
  Start方法初始化StandardContext对象并让生命周期监听器配置该StandardContext实例。如果配置成功，生命周期监听器会将configured属性设置为true。最后start方法，将available属性设置为true或者false。如果是true的话表示该StandardContext属性配置完毕并且所有相关子容器和组件已经成功启动，这样就能对HTTP请求进行服务了，如果是false则表示出现了错误。 StandardContext类将configured的值初始化为false，如果生命周期监听器的配置过程成功，则将该值设置为true。在start方法的最后，它检查StandardContext对象的configured属性，如果该值为true，则启动该StandardContext成，否则调用stop方法停止所有已经启动的组件。 Tomcat 4中StandardContext类中的start方法如Listing12.1:
  Listing 12.1: The start method of the StandardContext class in Tomcat 4 public synchronized void start() throws LifecycleException { if (started) throw new LifecycleException (sm.getString("containerBase.alreadyStarted", logName())); if (debug >= 1) log("Starting");
  // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); if (debug >= 1) log("Processing start(), current available=" + getAvailable()); setAvailable(false); setConfigured(false); boolean ok = true;
  // Add missing components as necessary if (getResources() == null) { // (1) Required by Loader if (debug >= 1) log("Configuring default Resources"); try { if ((docBase != null) && (docBase.endsWith(".war"))) setResources(new WARDirContext()); else setResources(new FileDirContext()); } catch (IllegalArgumentException e) { log("Error initializing resources: " + e.getMessage()); ok = false; } } if (ok && (resources instanceof ProxyDirContext)) { DirContext dirContext = ((ProxyDirContext) resources).getDirContext(); if ((dirContext != null) && (dirContext instanceof BaseDirContext)) { ((BaseDirContext) dirContext).setDocBase(getBasePath()); ((BaseDirContext) dirContext).allocate(); } } if (getLoader() == null) { // (2) Required by Manager if (getPrivileged()) { if (debug >= 1) log("Configuring privileged default Loader"); setLoader(new WebappLoader(this.getClass().getClassLoader())); } else { if (debug >= 1) log("Configuring non-privileged default Loader"); setLoader(new WebappLoader(getParentClassLoader())); } } if (getManager() == null) { // (3) After prerequisites if (debug >= 1) log("Configuring default Manager"); setManager(new StandardManager()); }
  // Initialize character set mapper getCharsetMapper();
  // Post work directory postWorkDirectory(); // Reading the "catalina.useNaming" environment variable String useNamingProperty = System.getProperty("catalina.useNaming"); if ((useNamingProperty != null) && (useNamingProperty.equals("false"))) { useNaming = false; } if (ok && isUseNaming()) { if (namingContextListener == null) { namingContextListener = new NamingContextListener(); namingContextListener.setDebug(getDebug()); namingContextListener.setName(getNamingContextName()); addLifecycleListener(namingContextListener); } } // Binding thread ClassLoader oldCCL = bindThread(); // Standard container startup if (debug >= 1) log("Processing standard container startup"); if (ok) { try { addDefaultMapper(this.mapperClass); started = true; // Start our subordinate components, if any if ((loader != null) && (loader instanceof Lifecycle)) ((Lifecycle) loader).start(); if ((logger != null) && (logger instanceof Lifecycle)) ((Lifecycle) logger).start(); // Unbinding thread unbindThread(oldCCL); // Binding thread
  oldCCL = bindThread(); if ((cluster != null) && (cluster instanceof Lifecycle)) ((Lifecycle) cluster).start(); if ((realm != null) && (realm instanceof Lifecycle)) ((Lifecycle) realm).start(); if ((resources != null) && (resources instanceof Lifecycle)) ((Lifecycle) resources).start(); // Start our Mappers, if any Mapper mappers[] = findMappers(); for (int i = 0; i < mappers.length; i++) { if (mappers[i] instanceof Lifecycle) ((Lifecycle) mappers[i]).start(); }
  // Start our child containers, if any Container children[] = findChildren(); for (int i = 0; i < children.length; i++) { if (children[i] instanceof Lifecycle) ((Lifecycle) children[i]).start(); } // Start the Valves in our pipeline (including the basic), // if any if (pipeline instanceof Lifecycle) ((Lifecycle) pipeline).start(); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(START_EVENT, null); if ((manager != null) && (manager instanceof Lifecycle)) ((Lifecycle) manager).start(); } finally { // Unbinding thread unbindThread(oldCCL); } } if (!getConfigured()) ok = false; // We put the resources into the servlet context
  if (ok) getServletContext().setAttribute (Globals.RESOURCES_ATTR, getResources()); // Binding thread oldCCL = bindThread(); // Create context attributes that will be required if (ok) { if (debug >= 1) log("Posting standard context attributes"); postWelcomeFiles(); } // Configure and call application event listeners and filters if (ok) { if (!listenerStart()) ok = false; } if (ok) { if (!filterStart()) ok = false; } // Load and initialize all "load on startup" servlets if (ok) loadOnStartup(findChildren());
  // Unbinding thread unbindThread(oldCCL); // Set available status depending upon startup success if (ok) { if (debug >= 1) log("Starting completed"); setAvailable(true); } else { log(sm.getString("standardContext.startFailed")); try { stop(); } catch (Throwable t) { log(sm.getString("standardContext.startCleanup"), t);
  } setAvailable(false); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null); }
  注意
  在Tomcat5中，start方法跟Tomcat4的相似，只是包括了JMX相关的代码，JMX的内容将在第20章讨论。读完该章后就可以查看Tomcat5中的start方法了。
  如在Listing12.1中看到的，下面是该方法做的事情： · 触发BEFORE_START事件 · 设置availability属性为false · 设置configured属性为false · 设置源（resources） · 设置加载器 · 设置管理器 · 初始化属性map · 启动跟该上下文相关的组件 · 启动子容器（包装器） · 启动流水线 · 启动管理器 · 触发START事件。监听器（ContextConfig）会进行一系列配置操作，配置成功后，将StandardContext实例的configured属性设置为true。 · 检查configured属性的值，如果为true：调用postWelcomPages方法，加载子包装器，并将available属性设置为true。如果configured属性为false调用stop方法 · 触发AFTER_START事件
  Invoke方法
  在Tomcat4中，StandardContext's方法由相关联的连接器调用，如果该上下文是一个主机（host）的子容器，有该主机的invoke方法调用。StandardContext的invoke方法首先检查是否正在重加载该应用程序，是的话，等待知道加载完毕。然后调用它的父类ContainerBase的invoke方法。Listing12.2展示了StandardContext的invoke方法。
  Listing 12.2: The invoke method of the StandardContext Class
  public void invoke(Request request, Response response) throws IOException, ServletException { // Wait if we are reloading while (getPaused()) { try { Thread.sleep(1000); } catch (InterruptedException e) { ; } } // Normal request processing if (swallowOutput) { try { SystemLogHandler.startCapture(); super.invoke(request, response); } finally { String log = SystemLogHandler.stopCapture(); if (log != null && log.length() > 0) { log(log); } } } else { super.invoke(request, response); } }
  方法getPaused获得属性paused的值，当应用程序正在加载的时候该属性为ture。应用程序加载将在下一节讨论。 在Tomcat5中，StandardContext并没有提供invoke方法的实现，因此它会执行ContainerBase的invoke方法。检查应用程序加载的任务在StandardContextValve类的invoke方法中完成。
  StandardContextMapper
  对于每一个请求，invoke方法都会调用StandarContext流水线基本阀门的invoke方法。StandarContext的基本阀门用org.apache.catalina.core.StandardContextValve类表示。StandardContextValve的invoke方法需要得到一个处理请求的包装器。
  在Tomcat4中，StandardContextValve实例查找包含它的StandardContext。StandardContextValve使用上下文容器的map来查找合适的包装器。一旦它得
  到一个合适的包装器，调用该包装器的invoke方法。在介绍StandardContextValve的做法的时候，本节先介绍该map组件。 StandardContext的父类ContainerBase定义了addDefaultMapper方法来添加一个默认的映射（map）如下， protected void addDefaultMapper(String mapperClass) { // Do we need a default Mapper? if (mapperClass == null) return; if (mappers.size() >= 1) return; // Instantiate and add a default Mapper try { Class clazz = Class.forName(mapperClass); Mapper mapper = (Mapper) clazz.newInstance(); mapper.setProtocol("http"); addMapper(mapper); } catch (Exception e) { log(sm.getString("containerBase.addDefaultMapper", mapperClass), e); } } StandardContext在start方法中调用它的addDefaultMapper方法，传递一个mapperClass变量。 public synchronized void start() throws LifecycleException { ... if (ok) { try { addDefaultMapper(this.mapperClass); ... }
  StandardContext的mapperClass变量定义如下： private String mapperClass = "org.apache.catalina.core.StandardContextMapper"; 你必须使用映射器的setContainer方法来讲映射跟容器相关联。org.apache.catalina.Mapper接口的标准实现是org.apache.catalina.core.StandardContextMapper。StandardContextMapper只能跟上下文相关联，使用的方法是setCOntainer public void setContainer(Container container) { if (!(container instanceof StandardContext))
  throw new IllegalArgumentException (sm.getstring("httpContextMapper.container")); context = (StandardContext) container; } 在一个映射器（mapper）中最重要的方法是map方法，它获得一个HTTP请求返回一个子容器，该方法的签名如下： public Container map(Request request, boolean update) 在StandardContextMapper中map方法返回一个包装器来处理请求。如果找不到合适的包装器，方法返回null。 回到本节开始讨论的内容，StandardContextValve调用上下文容器的map方法来处理HTTP请求，传递的参数是org.apache.catalina.Request对象。map方法（ContainerBase类中）返回一个对应相应协议的映射器，然后调用该映射器的map方法。 // Select the Mapper we will use Mapper mapper = findMapper(request.getRequest().getProtocol()); if (mapper == null) return (null); // Use this Mapper to perform this mapping return (mapper.map(request, update));
  The map method in StandardContextMapper first identifies the context-relative URI to be mapped: StandardContextMapper的map方法首先识别上下文的相关URL映射 // Identify the context-relative URI to be mapped String contextPath = ((HttpServletRequest) request.getRequest()).getContextPath(); String requestURI = ((HttpRequest) request).getDecodedRequestURI();
  String relativeURI = requestURI.substring(contextPath.length()); 然后通过匹配方法尝试获得一个包装器 // Apply the standard request URI mapping rules from the specification Wrapper wrapper = null; String servletPath = relativeURI; String pathInfo = null; String name = null; // Rule 1 -- Exact Match if (wrapper == null) { if (debug >= 2) context.log(" Trying exact match"); if (!(relativeURI.equals("/"))) name = context.findServletMapping(relativeURI);
  if (name != null) wrapper = (Wrapper) context.findChild(name); if (wrapper != null) { servletPath = relativeURI; pathInfo = null; } } // Rule 2 -- Prefix Match if (wrapper == null) { if (debug >= 2) context.log(" Trying prefix match"); servletPath = relativeURI; while (true) { name = context.findServletMapping(servletPath + "/*"); if (name != null) wrapper = (Wrapper) context.findChild(name); if (wrapper != null) { pathInfo = relativeURI.substring(servletPath.length()); if (pathInfo.length() == 0) pathInfo = null; break; } int slash = servletPath.lastIndexOf('/'); if (slash < 0) break; servletPath = servletPath.substring(0, slash); } } // Rule 3 -- Extension Match if (wrapper == null) { if (debug >= 2) context.log(" Trying extension match"); int slash = relativeURI.lastIndexOf('/'); if (slash >= 0) { String last = relativeURI.substring(slash); int period = last.lastIndexOf('.'); if (period >= 0) { String pattern = "*" + last.substring(period);
  name = context.findServletMapping(pattern); if (name != null) wrapper = (Wrapper) context.findChild(name);
  if (wrapper != null) { servletPath = relativeURI; pathInfo = null; } } } } // Rule 4 -- Default Match if (wrapper == null) { if (debug >= 2) context.log(" Trying default match"); name = context.findServletMapping("/"); if (name != null) wrapper = (Wrapper) context.findChild(name); if (wrapper != null) { servletPath = relativeURI; pathInfo = null; } } 你可能会问，上下文容器时如何获得Servlet映射的，回头看第十一章中的Bootstrap类，它添加了两个Servlet映射到StandarContext。 context.addServletMapping("/Primitive", "Primitive"); context.addServletMapping("/Modern", "Modern"); 它还将包装器作为子容器添加到上下文容器中。 context.addChild(wrapper1); context.addChild(wrapper2); Tomcat 5删除了Mapper接口及其相关类。实际上StandardContextValve的invoke方法就能得到请求的合适包装器。 Wrapper wrapper = request.getWrapper(); 这表示映射信息已经包装在请求对象中了。
  重加载支持
  StandardContext定义了reloadable属性来标识是否支持应用程序的重加载。当允许重加载的时候，当web.xml或者WEB-INF/classes目录下的文件被改变的时候会重加载。 StandardContext用它的加载器来加载应用程序。在Tomcat4中，StandardContext 中Loader接口的标准实现WebappLoader类，有一个单独线程来检查WEB-INF目录下面所有类和JAR文件的时间戳。你需要做的是启动该线程，将 WebappLoader关联到StandardContext，使用setContainer方法即可。下面是Tomcat4中WebappLoader的实现：
  public void setContainer(Container container) { // Deregister from the old Container (if any) if ((this.container != null) && (this.container instanceof Context)) ((Context) this.container).removePropertyChangeListener(this); // Process this property change Container oldContainer = this.container; this.container = container; support.firePropertyChange("container", oldContainer, this.container); // Register with the new Container (if any) if ((this.container!=null) && (this.container instanceof Context)) { setReloadable( ((Context) this.container).getReloadable() ); ((Context) this.container).addPropertyChangeListener(this); } } 注意最后一个if语句块中，如果容器是一个上下文容器，调用setReloadable方法，也就是说WebappLoader的reloadable属性跟StandardContext的reloadable属性相同。 下面是WebappLoader对setReload方法的实现： public void setReloadable(boolean reloadable) { // Process this property change boolean oldReloadable = this.reloadable; this.reloadable = reloadable; support.firePropertyChange("reloadable", new Boolean(oldReloadable), new Boolean(this.reloadable)); // Start or stop our background thread if required if (!started) return; if (!oldReloadable && this.reloadable) threadStart(); else if (oldReloadable && !this.reloadable) threadStop(); }
  如果将reloadable属性设置为true，调用threadStart方法。如果从true到false，则调用threadStop方法。threadStart方法启动一个线程持续的检查WEB-INF目录下面的类文件和JAR文件的时间戳。threadStop方法用于停止该线程。 在Tomcat5中，类的时间戳是由backgroundProcess方法调用的，下一节将会结束该方法。 backgroundProcess方法
  一个上下文容器需要其它组件如加载器和管理器的支持。这些组件通常需要一个单独的线程来处理后台过程（background processing）。例如，加载器通过一个线程检查类文件和JAR文件的时间戳来支持自动重载。管理器需要一个线程来检查它管理的Session对象过期时间。在Tomcat4中，这些组件都有自己的线程。 为了节省资源，Tomcat使用了一种不同的方式来处理。所有的后台过程都分享同一个线程。如果一个组件或者是容器需要定期的来执行操作，它需要做的是将这些代码写入到backgroundProcess方法即可。 共享线程有ContainerBase对象创建，ContainerBase在他的start方法中调用threadStard方法。 protected void threadStart() { if (thread != null) return; if (backgroundProcessorDelay <= 0) return; threadDone = false; String threadName = "ContainerBackgroundProcessor[" + toString() + "]"; thread = new Thread(new ContainerBackgroundProcessor(), threadName); thread.setDaemon(true); thread.start(); } 方法threadStart传递一个ContainerBackgroundProcessor对象创建一个新线程。ContainerBackgroundProcessor实现了java.lang.Runnable接口，该类如Listing12.3所示
  Listing 12.3: The ContainerBackgroundProcessor class protected class ContainerBackgroundProcessor implements Runnable { public void run() { while (!threadDone) { try { Thread.sleep(backgroundProcessorDelay * 1000L); } catch (InterruptedException e) { ; } if (!threadDone) { Container parent = (Container) getMappingObject(); ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (parent.getLoader() != null) { cl = parent.getLoader().getClassLoader(); } processChildren(parent, cl); }
  } } protected void processChildren(Container container, ClassLoader cl) { try { if (container.getLoader() != null) { Thread.currentThread().setContextClassLoader (container.getLoader().getClassLoader()); } container.backgroundProcess(); } catch (Throwable t) { log.error("Exception invoking periodic operation: ", t); } finally { Thread.currentThread().setContextClassLoader(cl); } Container[] children = container.findChildren(); for (int i = 0; i < children.length; i++) { if (children[i].getBackgroundProcessorDelay() <= 0) { processChildren(children[i], cl); } } } }
  ContainerBackgroundProcessor是ContainerBase的内部类，在他的run方法里，有一个while循环定期的调用它的processChildren方法。processChildren调用backgroundProcess来处理它的每个孩子的processChildren方法。要实现backgroundProcess方法，以ContainerBase的子类可以有一个线程来周期性的执行任务，例如检查时间戳或者Session对象的终结时间。Listing12.4展示了Tomcat5中StandardContext的backgroundProcess方法的实现。
  Listing 12.4: The backgroudProccss method of the StandardContext class public void backgroundProcess() { if (!started) return; count = (count + 1) % managerChecksFrequency; if ((getManager() != null) && (count == 0)) { try { getManager().backgroundProcess(); } catch ( Exception x ) { log.warn("Unable to perform background process on manager", x); }
  } if (getloader() != null) { if (reloadable && (getLoader().modified())) { try { Thread.currentThread().setContextClassloader (StandardContext.class.getClassLoader()); reload(); } finally { if (getLoader() != null) { Thread.currentThread().setContextClassLoader (getLoader().getClassLoader()); } } } if (getLoader() instanceof WebappLoader) { ((WebappLoader) getLoader()).closeJARs(false); } } }
  需要明白StandardContext怎样让它的相关管理器和加载器来执行任务。 总结 在本章中，介绍了StandardContext极其相关类。另外还看到了StandardContext对象是如何配置的以及如何处理HTTP请求，最后一张讨论了Tomcat5中backgroundProcess方法的实现。

  ## 第13章：主机(host)和引擎(engine)

  综述 本章要讨论的两个主题是主机（host）和引擎（Engine）。如果需要在一个Tomcat部署中部署多个上下文，需要使用一个主机。理论上，当只有一个上下文容器的时候不需要主机，正如org.apache.catalina.Context接口中描述的那样。 · 上下文容器的父容器是主机，但是可能有一些其它实现，没有必要的时候也可以忽略。
  但是实践中，一个Tomcat部署往往需要一个主机。至于为什么，你会在本章后面的Why You Cannot Live without a Host一节中看到。 引擎表示整个Catalina 的Servlet引擎。如果使用的话，它位于容器等级的最高层。可以添加到引擎上的容器包括org.apache.catalina.Host 或者org.apache.catalina.Context。在一个Tomcat部署中，默认的容器是引擎。在该部署中，引擎只有一个主机，默认主机。 本章讨论了跟Host和Engine接口接口相关的类。首先介绍了Host相关的StandardHost、StandardHostMapper（Tomcat4）以及StandardHostValve类。接下来是，用一个示例来说明了主机作为顶层容器的情况。引擎是本章讨论的第二个主题。接下来是本章的第二个应用程序，说明了如何将引擎作为顶层容器使用。 Host接口
  主机是用org.apache.catalina.Host接口表示的。本接口继承了Container接口，如Listing13.1所示：
  Listing 13.1: The Host interface package org.apache.catalina; public interface Host extends Container { public static final String ADD_ALIAS_EVENT = "addAlias"; public static final String REMOVE_ALIAS_EVENT = "removeAlias"; /** * Return the application root for this Host. * This can be an absolute * pathname, a relative pathname, or a URL. */ public String getAppBase(); /** * Set the application root for this Host. This can be an absolute * pathname, a relative pathname, or a URL. *

* @param appBase The new application root */ public void setAppBase(String appBase); /** * Return the value of the auto deploy flag. * If true, it indicates that * this host's child webapps should be discovred and automatically * deployed. */ public boolean getAutoDeploy(); /** * Set the auto deploy flag value for this host. * * @param autoDeploy The new auto deploy flag */ public void setAutoDeploy(boolean autoDeploy); /** * Set the DefaultContext * for new web applications. * * @param defaultContext The new DefaultContext */ public void addDefaultContext(DefaultContext defaultContext); /** * Retrieve the DefaultContext for new web applications. */
  public DefaultContext getDefaultContext(); /** * Return the canonical, fully qualified, name of the virtual host * this Container represents. */ public String getName(); /** * Set the canonical, fully qualified, name of the virtual host * this Container represents. * * @param name Virtual host name

* @exception IllegalArgumentException if name is null */ public void setName(String name); /** * Import the DefaultContext config into a web application context. * * @param context web application context to import default context */ public void importDefaultContext(Context context); /** * Add an alias name that should be mapped to this same Host. * * @param alias The alias to be added */ public void addAlias(String alias); /** * Return the set of alias names for this Host. If none are defined, * a zero length array is returned. */ public String[] findAliases(); /** * Return the Context that would be used to process the specified * host-relative request URI, if any; otherwise return * <code>null</code>. * * @param uri Request URI to be mapped */ public Context map(String uri); /** * Remove the specified alias name from the aliases for this Host. * @param alias Alias name to be removed */ public void removeAlias(String alias); }
  最终要的方法是用合适的上下文来处理请求的map方法，该方法的实现可以在StandardHost类中找到。
  StandardHost类 org.apache.catalina.core.StandardHost类是对Host接口的标准实现。该继承了org.apache.catalina.core.ContainerBase类并实现了Host接口和Deployer接口。Deployer接口将在第17章讨论。 跟StandardContext和StandardWrapper类相似，StandardHost类的构造函数在它的流水线中添加一个基本阀门。 public StandardHost() { super(); pipeline.setBasic(new StandardHostValve()); } 该阀门的类型为org.apache.catalina.core.StandardHostValve。 当它的start方法被调用的时候，StandardHost上面添加两个阀门：ErrorReportValve 和 ErrorDispatcherValve。它们都在org.apache.catalina.valves包中。Tomcat4中StandardHost的start方法如Listing13.2所示
  Listing 13.2: The start method of StandardHost public synchronized void start() throws LifecycleException { // Set error report valve if ((errorReportValveClass != null) && (!errorReportValveClass.equals(""))) { try { Valve valve = (Valve) Class.forName(errorReportValveClass).newInstance(); addValve(valve); } catch (Throwable t) { log(sm.getString ("StandardHost.invalidErrorReportValveClass", errorReportValveClass)); } } // Set dispatcher valve addValve(new ErrorDispatcherValve()); super.start(); }
  注意
  在Tomcat5中，start方法相似，不同点在于包括了构建JXM对象的代码，JMX将在第20章讨论
  errorReportValveClass的值由StandardHost类如下决定： private String errorReportValveClass =
  "org.apache.catalina.valves.ErrorReportValve";
  对于每一个请求，都会调用主机的invoke方法。由于StanardHost类并没有实现invoke方法，所以会调用它的父类ContainerBase类的invoke方法。该invoke方法会转而调用StandardHost 的基本阀门StandardHostValve的invoke方法。StandardHostValve阀门的invoke方法将在StandardHostValve小节讨论。StandardHostValve的invoke方法调用StandardHost类的map方法获得一个合适的上下文容器来处理请求。StandardHost的map方法如Listing13.3所示
  Listing 13.3: The map method in the StandardHost class public Context map(String uri) { if (debug > 0) log("Mapping request URI '" + uri + "'"); if (uri == null) return (null); // Match on the longest possible context path prefix if (debug > 1) log(" Trying the longest context path prefix"); Context context = null; String mapuri = uri; while (true) { context = (Context) findChild(mapuri); if (context != null) break; int slash = mapuri.lastIndexOf('/'); if (slash < 0) break; mapuri = mapuri.substring(0, slash); } // If no Context matches, select the default Context if (context == null) { if (debug > 1) log(" Trying the default context"); context = (Context) findChild(""); } // Complain if no Context has been selected
  if (context == null) { log(sm.getString("standardHost.mappingError", uri)); return (null); } // Return the mapped Context (if any)
  if (debug > 0) log(" Mapped to context '" + context.getPath() + "'"); return (context); }
  注意在Tomcat4中，ContainerBase类也声明了一个map方法如下签名： public Container map(Request request, boolean update); 在Tomcat4中，StandardHostVavle的invoke方法调用ContainerBase的map方法，它由转而调用StandardHost的map方法。在Tomcat5中，没有映射器组件，适当的上下文由请求对象获得。 StandardHostMapper类 在Tomcat4中，StandardHost的父类ContainerBase使用addDefaultMapper方法创建一个默认映射器。默认映射器的类型由mapperClass属性指定。这里是ContainerBase的addDefaulstMapper方法： protected void addDefaultMapper(String mapperClass) { // Do we need a default Mapper? if (mapperClass == null) return; if (mappers.size() >= 1) return; // Instantiate and add a default Mapper try { Class clazz = Class.forName(mapperClass); Mapper mapper = (Mapper) clazz.newInstance(); mapper.setProtocol("http"); addMapper(mapper); } catch (Exception e) { log(sm.getString("containerBase.addDefaultMapper", mapperClass), e); } } StandardHost定义mapperClass变量如下：
  private String mapperClass = "org.apache.catalina.core.StandardHostMapper"; 另外，StandardHost类的start方法在它的最后调用super.start()，这样保证了创建一个默认的映射器。
  注意
  Tomcat4中的standardContext使用了不同的方法来创建一个默认映射器。它的start方法中并没有调用super.start()。相反Standardcontext的
  start方法调用addDefaultMapper来传递mapperClass变量。
  The most important method in StandardHostMapper is, of course, map. Here it is. StandardHostMapper中最重要的方法是map方法，下面是它的实现： public Container map(Request request, boolean update) { // Has this request already been mapped? if (update && (request.getContext() != null)) return (request.getContext()); // Perform mapping on our request URI String uri = ((HttpRequest) request).getDecodedRequestURI(); Context context = host.map(uri); // Update the request (if requested) and return the selected Context if (update) { request.setContext(context); if (context != null) ((HttpRequest) request).setContextPath(context.getPath()); else ((HttpRequest) request).setContextPath(null); } return (context); } 注意，map方法仅仅是简单的调用了Host的map方法。 StandardHostValve类 org.apache.catalina.core.StandardHostValve类是StandardHost的基本阀门类型。当有HTTP请求的时候会调用它的invoke方法：
  Listing 13.4: The invoke method of StandardHostValve public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException { // Validate the request and response object types
  if (!(request.getRequest() instanceof HttpServletRequest) || !(response.getResponse() instanceof HttpServletResponse)) { return; // NOTE - Not much else we can do generically } // Select the Context to be used for this Request StandardHost host = (StandardHost) getContainer();
  Context context = (Context) host.map(request, true); if (context == null) { ((HttpServletResponse) response.getResponse()).sendError (HttpServletResponse.SC_INTERNAL_SERVER_ERROR, sm.getstring("StandardHost.noContext")); return; } // Bind the context CL to the current thread Thread.currentThread().setContextClassLoader (context.getLoader().getClassLoader()); // Update the session last access time for our session (if any) HttpServletRequest hreq = (HttpServletRequest) request.getRequest(); String sessionId = hreq.getRequestedSessionId(); if (sessionId != null) { Manager manager = context.getManager(); if (manager != null) { Session session = manager.findSession(sessionId); if ((session != null) && session.isValid()) session.access(); } } // Ask this Context to process this request context.invoke(request, response); }
  在Tomcat4中的invoke方法中调用StandardHost的map方法来获得一个合适的上下文。 // Select the Context to be used for this Request StandardHost host = (StandardHost) getContainer(); Context context = (Context) host.map(request, true);
  注意
  在得到上下对象的时候需要一个往返过程，map方法介绍两个参数，该方法是在ContainerBase中的。然后ContainerBase类又在它的子对象中查找合适的映射器并调用它的map方法。
  Invoke方法解析来得到一个Session对象并调用它的access方法，access方法更新它的最后进入时间，这里是org.apache.catalina.session.StandardSession类中的access方法。
  public void access() { this.isNew = false;
  this.lastAccessedTime = this.thisAccessedTime; this.thisAccessedTime = System.currentTimeMillis(); } 最后，invoke方法调用上下文容器的invoke方法，让上下文来处理请求。
  为什么Host是必须的
  一个Tomcat部署必须有一个主机如果该上下文使用ContextConfig来配置。原因如下： ContextConfig需要应用文件web.xml的位置，它在它的applicationConfig方法中尝试打开该文件，下面是该方法的片段： synchronized (webDigester) { try { URL url = servletContext.getResource(Constants.ApplicationWebXml); InputSource is = new InputSource(url.toExternalForm()); is.setByteStream(stream); ... webDigester.parse(is); ... Constants.ApplicationWebXml 定义的是 /WEB-INF/web.xml，servletContext是一个org.apache.catalina.core.ApplicationContext类型的对象。 下面是ApplicationContext 类的getResource方法 public URL getResource(String path) throws MalformedURLException { DirContext resources = context.getResources(); if (resources != null) { String fullPath = context.getName() + path; // this is the problem. Host must not be null String hostName = context.getParent().getName(); 最后一行清楚的现实上下文的父容器（主机）是必须的，如果使用ContextConfig来配置的话。在第15章中将会介绍如何解析web.xml文件。简单的说，除非你自己写ContextConfig类，否则你必须有一个主机。
  Application 1程序1
  本章第一个应用程序说明了如何将一个主机作为顶层容器使用。该程序有两个类组成：ex13.pyrmont.core.SimpleContextConfig和ex13.pyrmont.startup.Bootstrap1类。SimpleContextConfig类跟第11章中的相同，而Boostrap2类如Listing13.5所示：
  Listing 13.5: The Bootstrap1 Class
  package ex13.pyrmont.startup; import ex13.pyrmont.core.SimpleContextConfig; import org.apache.catalina.Connector; import org.apache.catalina.Context; import org.apache.catalina.Host; import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleListener; import org.apache.catalina.Loader; import org.apache.catalina.Wrapper; import org.apache.catalina.connector.http.HttpConnector; import org.apache.catalina.core.StandardContext; import org.apache.catalina.core.StandardHost; import org.apache.catalina.core.StandardWrapper; import org.apache.catalina.loader.WebappLoader; public final class Bootstrap1 { public static void main(String[] args) { System.setProperty("catalina.base", System.getProperty("user.dir")); Connector connector = new HttpConnector(); Wrapper wrapper1 = new StandardWrapper(); wrapper1.setName("Primitive"); wrapper1.setServletClass("PrimitiveServlet"); Wrapper wrapper2 = new StandardWrapper(); wrapper2.setName("Modern"); wrapper2.setServletClass("ModernServlet"); Context context = new StandardContext(); // StandardContext's start method adds a default mapper context.setPath("/app1"); context.setDocBase("app1"); context.addChild(wrapper1); context.addChild(wrapper2); LifecycleListener listener = new SimpleContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); Host host = new StandardHost(); host.addChild(context); host.setName("localhost"); host.setAppBase("webapps"); Loader loader = new WebappLoader(); context.setLoader(loader); // context.addServletMapping(pattern, name);
  context.addServletMapping("/Primitive", "Primitive");
  context.addServletMapping("/Modern", "Modern"); connector.setContainer(host); try { connector.initialize(); ((Lifecycle) connector).start(); ((Lifecycle) host).start(); // make the application wait until we press a key. System.in.read(); ((Lifecycle) host).stop(); } catch (Exception e) { e.printStackTrace(); } } }
  Running the Applications
  在Windows下面可以在工作目录下输入如下命令运行该程序 java -classpath ./lib/servlet.jar;./lib/commons- collections.jar;./lib/commons—digester.jar;./ ex13.pyrmont.startup.Bootstrap1 在Linux下面需要使用分号来分隔开两个库 java -classpath ./lib/servlet.jar:./lib/commons- collections.jar:./lib/commons-digester.jar:./ ex13.pyrmont.startup.Bootstrap1 使用如下URL可以调用PrimitiveServlet http://localhost:8080/app1/Primitive 如下URL来调用ModernServlet。 http://localhost:8080/app1/Modern Engine接口 org.apache.catalina.Engine接口用来表示一个引擎。引擎表示整个Catalina的Servlet引擎。当你想要支持多个虚拟主机的时候，需要一个引擎，实际上，Tomcat部署正是使用了引擎。
  Engine接口如Listing 13.6所示：
  Listing 13.6: The Engine Interface package org.apache.catalina;
  public interface Engine extends Container { /** * Return the default hostname for this Engine. */ public String getDefaultHost(); /** * Set the default hostname for this Engine. * * @param defaultHost The new default host */ public void setDefaultHost(String defaultHost); /** * Retrieve the JvmRouteId for this engine. */ public String getJvmRoute(); /** * Set the JvmRouteId for this engine. * * @param jvmRouteId the (new) JVM Route ID. Each Engine within a * cluster must have a unique JVM Route ID. */ public void setJvmRoute(String jvmRouteId); /** * Return the <code>Service</code> with which we are associated (if * any). */ public Service getService(); /** * Set the <code>Service</code> with which we are associated (if * any). * * @param service The service that owns this Engine */ public void setService(Service service); /** * Set the DefaultContext * for new web applications. * * @param defaultContext The new DefaultContext */ public void addDefaultContext(DefaultContext defaultContext); /** * Retrieve the DefaultContext for new web applications. */
  public DefaultContext getDefaultContext(); /** * Import the DefaultContext config into a web application context. * * @param context web application context to import default context */ public void importDefaultContext(Context context); }
  可以给引擎设置默认主机或者默认上下文。注意引擎也可以跟服务相关联（service），Service的内容在第14章介绍。
  StandardEngine类
  类org.apache.catalina.core.StandardEngine是Engine接口的标准实现，跟StandardContext和StandardHost相比，StandardEngine类相对较小。初始化的时候，StandardEngine类需要添加一个基本阀门，下面是该类构造函数： public StandardEngine() { super(); pipeline.setBasic(new StandardEngineValve()); } 在Container容器的顶层，StandardEngine可以有子容器，它的子容器必须是主机（host）。如果你尝试给它添加一个非主机容器，会产生异常。这里是StandardEngine类的addChile方法。 public void addChild(Container child) { if (!(child instanceof Host)) throw new IllegalArgumentException (sm.getString("StandardEngine.notHost")); super.addChild(child); } 由于位于容器的顶层，所以引擎不能有父容器，当你尝试给引擎设置父容器的时候会产生异常，下面是StandardEngine类的setParent方法 public void setParent(Container container) { throw new IllegalArgumentException (sm.getString("standardEngine.notParent")); } StandardEngineValve类 org.apache.catalina.core.StandardEngineValve是StandardEngine的基本阀门，它的invoke方法如Listing13.7
  Listing 13.7: The invoke method of StandardEngineValve public void invoke(Request request, Response response,
  ValveContext valveContext) throws IOException, ServletException { // Validate the request and response object types if (!(request.getRequest() instanceof HttpServletRequest) || !(response.getResponse() instanceof HttpServletResponse)) { return; // NOTE - Not much else we can do generically } // Validate that any HTTP/1.1 request included a host header HttpServletRequest hrequest = (HttpServletRequest) request; if ("HTTP/1.1".equals(hrequest.getProtocol()) && (hrequest.getServerName() == null)) { ((HttpServletResponse) response.getResponse()).sendError (HttpServletResponse.SC_BAD_REQUEST, sm.getString("standardEngine.noHostHeader", request.getRequest().getServerName())); return; } // Select the Host to be used for this Request StandardEngine engine = (StandardEngine) getContainer(); Host host = (Host) engine.map(request, true); if (host == null) { ((HttpServletResponse) response.getResponse()).sendError (HttpServletResponse.SC_BAD_REQUEST, sm.getString("standardEngine.noHost", request.getRequest().getServerName())); return; } // Ask this Host to process this request host.invoke(request, response); }
  在验证了请求对象和响应对象之后，invoke方法获得一个Host实例来处理请求。它得到主机的方法是调用引擎的map方法。一旦获得了一个主机，它的invoke方法将会被调用。
  Application 2程序2
  本章的第二个应用程序用于说明容器最顶层的引擎。该应用程序使用了两个类，ex13.pyrmont.core.SimpleContextConfig和ex13.pyrmont.startup.Bootstrap2类。Bootstrap2类如Listing13.8所示
  Listing 13.8: The Bootstrap2 class package ex13.pyrmont.startup;
  //Use engine
  import ex13.pyrmont.core.SimpleContextConfig; import org.apache.catalina.Connector; import org.apache.catalina.Context; import org.apache.catalina.Engine; import org.apache.catalina.Host; import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleListener; import org.apache.catalina.Loader; import org.apache.catalina.Wrapper; import org.apache.catalina.connector.http.HttpConnector; import org.apache.catalina.core.StandardContext; import org.apache.catalina.core.StandardEngine; import org.apache.catalina.core.StandardHost; import org.apache.catalina.core.StandardWrapper; import org.apache.catalina.loader.WebappLoader; public final class Bootstrap2 { public static void main(String[] args) { System.setProperty("catalina.base", System.getProperty("user.dir")); Connector connector = new HttpConnector(); Wrapper wrapper1 = new StandardWrapper(); wrapper1.setName("Primitive"); wrapper1.setServletClass("PrimitiveServlet"); Wrapper wrapper2 = new StandardWrapper(); wrapper2.setName("Modern"); wrapper2.setServletClass("ModernServlet"); Context context = new StandardContext(); // StandardContext's start method adds a default mapper context.setPath("/app1"); context.setDocBase("app1"); context.addChild(wrapper1); context.addChild(wrapper2); LifecycleListener listener = new SimpleContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); Host host = new StandardHost(); host.addChild(context); host.setName("localhost"); host.setAppBase("webapps"); Loader loader = new WebappLoader(); context.setLoader(loader); // context.addServletMapping(pattern, name); context.addServletMapping("/Primitive", "Primitive"); context.addServletMapping("/Modern", "Modern");
  Engine engine = new StandardEngine(); engine.addChild(host); engine.setDefaultHost("localhost"); connector.setContainer(engine); try { connector.initialize(); ((Lifecycle) connector).start(); ((Lifecycle) engine).start(); // make the application wait until we press a key. System.in.read(); ((Lifecycle) engine).stop();
  } catch (Exception e) { e.printStackTrace(); } } }
  Running the Applications
  要在Windows下面运行该程序，可以在工作目录下面输入如下命令 java -classpath ./lib/servlet.jar;./lib/commons- collections.jar;./lib/commons-digester.jar;./ ex13.pyrmont.startup.Bootstrap2 在Linux里面，需要使用分号分隔开两个库 java -classpath ./lib/servlet.jar:./lib/commons- collections.jar:./lib/commons-digester.jar:./ ex13.pyrmont.startup.Bootstrap2 可以在浏览器中输入如下URL来调用PrimitiveServlet http://localhost:8080/app1/Primitive 要调用ModernServlet，可以使用如下URL http://localhost:8080/app1/Modern 总结 在本章中，我们讨论了两种类型的容器：主机和引擎。本章还介绍了这两种容器的相关类。并且用两个程序说明了如何让这两种容器作为顶层容器来工作。

  ## 第14章：服务器和服务

  综述
  在前面的章节中已经看到了如何初始化连接器和容器并将它们关联起来作为Servlet容器。前面只有一个连接器，通过端口8080对HTTP请求进行服务。你不能添加另一个连接器来处理例如HTTPS的请求。 另外，所有的配套程序都确实一件东西，启动和停止Servlet容器的机制。在本章中，我们将看提供了该机制以及其它一些属性的组件：服务器（server）和服务（service）。 Server服务器 org.apache.catalina.Server接口表示整个Catalina Servlet容器以及其它组件。一个服务器相当有用，因为它提供了一种优雅的机制来启动和停止整个系统。不必再单独的启动连接器和容器了。 下面是启动和停止机制是如何工作的。当服务器启动的时候，它启动它内部的所有组件。然后无限期的等待关闭命令，如果你想要关闭系统，发送一个关闭命令道指定端口即可。当服务器收到正确的关闭指令后，它停止所有组件的服务。 服务器还使用了另外一个组件，服务，它用来持有组件，例如容器或者一个多个的连接器。服务将在本章的service小节中介绍。 Server接口如Listing14.1所示
  Listing 14.1: The Server interface package org.apache.catalina;
  import org.apache.catalina.deploy.NamingResources; public interface Server { /** * Return descriptive information about this Server implementation * and the corresponding version number, in the format * <code>&lt;description&gt;/&lt;version&gt;</code>. */ public String getInfo(); /** * Return the global naming resources. */ public NamingResources getGlobalNamingResources(); /** * Set the global naming resources. * * @param namingResources The new global naming resources
  */ public void setGlobalNamingResources (NamingResources globalNamingResources); /** * Return the port number we listen to for shutdown commands. */ public int getPort(); /** * Set the port number we listen to for shutdown commands. * * @param port The new port number */ public void setPort(int port); /** * Return the shutdown command string we are waiting for. */ public String getShutdown(); /** * Set the shutdown command we are waiting for. * * @param shutdown The new shutdown command */ public void setShutdown(String shutdown); /** * Add a new Service to the set of defined Services. * * @param service The Service to be added */ public void addService(Service service); /** * Wait until a proper shutdown command is received, then return. */ public void await(); /** * Return the specified Service (if it exists); otherwise return * <code>null</code>. * * @param name Name of the Service to be returned
  */ public Service findService(String name); /** * Return the set of Services defined within this Server. */
  public Service[] findServices(); /** * Remove the specified Service from the set associated from this * Server. * * @param service The Service to be removed */ public void removeService(Service service); /** * Invoke a pre-startup initialization. This is used to allow * onnectors to bind to restricted ports under Unix operating * environments. * * @exception LifecycleException If this server was already * initialized. */ public void initialize() throws LifecycleException; }
  属性shutdown用来持有一个停止服务的指令。属性port则是服务器等待关闭命令的端口。可以调用服务器的addService方法将服务添加到服务器。使用removeService方法将服务删除。findServices返回所有服务器中所有的服务。Initialize方法包括在启动之前需要执行的代码。
  StandardServer类
  org.apache.catalina.core.StandardServer类是服务器的标准实现。我们会特别注意这个类最重要的特性，它的关闭机制。而关于服务器通过server.xml配置的相关方法，这里不予讨论。感兴趣的话可以自己阅读，并不难理解。 一个服务器可以有零个或多个服务，StandardServer类提供了addService、removeService、findServices方法的实现。另外还有四个跟生命周期相关的方法：initialize 、tart 、stop以及await。跟其他组件相似，initialize初始化和start启动一个组件。然后可以使用await方法和stop方法。Await方法在收到端口8085（或其他端口）关闭指令之前会一直等待。当await方法返回的时候，调用stop方法停止所有字组件。在本章配套的应用程序中，你可以看到如何实现关闭机制。
  The initialize, start, stop, and await methods are discussed in the following sub-sections. 关于initialize, start, stop, 和 await方法的内容将在下面的子节讨论。
  initialize方法
  Initialize方法用于初始化要添加到服务器实例上的服务，StandardServer的initialize方法如Listing14.2
  Listing 14.2: The initialize method public void initialize() throws LifecycleException { if (initialized) throw new LifecycleException ( sm.getString("StandardServer.initialize.initialized")); initialized = true; // Initialize our defined Services for (int i = 0; i < services.length; i++) { services[i].initialize(); } }
  注意该方法使用了一个名为initialized的变量来避免多次启动该服务器。在Tomcat5中，initialize方法相似，但是包括了JMX的相关代码。Stop方法不会改变initialized的值，所以当服务器被停止后再次启动的时候，不会再次调用initialized方法。
  start方法
  可以使用start方法来启动一个服务器，StandardServer的start方法的实现将会启动所有服务及其相关组件，例如连接器和容器。Listing14.3展示了start方法
  Listing 14.3: The start method public void start() throws LifecycleException { // Validate and update our current component state
  if (started) throw new LifecycleException (sm.getString("standardServer.start.started")); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); lifecycle.fireLifecycleEvent(START_EVENT, null); started = true; // Start our defined Services synchronized (services) { for (int i = 0; i < services.length; i++) { if (services[i] instanceof Lifecycle) ((Lifecycle) services[i]).start(); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);
  }
  该方法使用了一个started布尔变量来避免一个服务器被启动两次。Stop方法会重置该变量的值。
  stop方法
  Stop方法用于停止一个服务器，该方法如Listing14.4所示
  Listing 14.4: The stop method public void stop() throws LifecycleException { // Validate and update our current component state if (!started) throw new LifecycleException (sm.getString("standardServer.stop.notStarted")); // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); lifecycle.fireLifecycleEvent(STOP_EVENT, null); started = false; // Stop our defined Services for (int i = 0; i < services.length; i++) { if (services[i] instanceof Lifecycle) ((Lifecycle) services[i]).stop(); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null); }
  调用stop方法可以停止所有的服务并重置started变量的值，这样就可以再次启动服务器了。
  await方法
  Await负责整个Tomcat部署的停止机制，它的代码如Listing14.5所示：
  Listing 14.5: The await method /** * Wait until a proper shutdown command is received, then return. */ public void await() { // Set up a server socket to wait on ServerSocket serverSocket = null; try {
  serverSocket = new ServerSocket(port, 1, InetAddress.getByName("127.0.0.1")); } catch (IOException e) { System.err.println("StandardServer.await: create[" + port + "]: " + e); e.printStackTrace(); System.exit(1); } // Loop waiting for a connection and a valid command while (true) { // Wait for the next connection Socket socket = null; InputStream stream = null; try { socket = serverSocket.accept(); socket.setSoTimeout(10 * 1000); // Ten seconds stream = socket.getInputStream(); } catch (AccessControlException ace) { System.err.println("StandardServer.accept security exception: " + ace.getMessage()); continue; } catch (IOException e) { System.err.println("StandardServer.await: accept: " + e); e.printStackTrace(); System.exit(1); } // Read a set of characters from the socket StringBuffer command = new StringBuffer(); int expected = 1024; // Cut off to avoid DoS attack while (expected < shutdown.length()) { if (random == null) random = new Random(System.currentTimeMillis()); expected += (random.nextInt() % 1024); } while (expected > 0) { int ch = -1; try {
  ch = stream, read(); }
  catch (IOException e) { System.err.println("StandardServer.await: read: " + e); e.printStackTrace(); ch = -1; } if (ch < 32) // Control character or EOF terminates loop break; command.append((char) ch); expected--; } // Close the socket now that we are done with it try { socket.close(); } catch (IOException e) { ; } // Match against our command string boolean match = command.toString().equals(shutdown); if (match) { break; } else System.err.println("StandardServer.await: Invalid command '" + command.toString() + "' received"); } // Close the server socket and return try { serverSocket.close(); } catch (IOException e) { ; } }
  方法await在8085端口创建一个ServerSocket对象，在while循环调用它的accept方法。Accept方法仅仅接受8085端口的信息。它将接受到的信息跟shutdown命令进行匹配，如果匹配的话跳出循环关闭SocketServer，如果不匹配继续while循环等待另一个命令。
  服务
  org.apache.catalina.Service接口用于表示服务。一个服务可以可以有一个容器和多个连接器。你可以添加多个连接器 ，并将它们跟容器相关联。Service接口如Listing14.6所示
  Listing 14.6: The Service interface package org.apache.catalina; public interface Service { /** * Return the <code>Container</code> that handles requests for all * <code>Connectors</code> associated with this Service. */ public Container getContainer(); /** * Set the <code>Container</code> that handles requests for all * <code>Connectors</code> associated with this Service. * * @param container The new Container */ public void setContainer(Container container); /** * Return descriptive information about this Service implementation * and the corresponding version number, in the format * <code>&lt;description&gt;/&lt;version&gt;</code>. */ public String getInfo(); /** * Return the name of this Service. */ public String getName(); /** * Set the name of this Service. * * @param name The new service name */ public void setName(String name); /** * Return the <code>Server</code> with which we are associated * (if any).
  */ public Server getServer(); /** * Set the <code>Server</code> with which we are associated (if any). * * @param server The server that owns this Service */ public void setServer(Server server); /**

* Add a new Connector to the set of defined Connectors, * and associate it with this Service's Container. * * @param connector The Connector to be added */ public void addConnector(Connector connector); /** * Find and return the set of Connectors associated with * this Service. */ public Connector[] findConnectors(); /** * Remove the specified Connector from the set associated from this * Service. The removed Connector will also be disassociated * from our Container. * * @param connector The Connector to be removed */ public void removeConnector(Connector connector); /** * Invoke a pre-startup initialization. This is used to * allow connectors to bind to restricted ports under * Unix operating environments. * * @exception LifecycleException If this server was * already initialized. */ public void initialize() throws LifecycleException; }
  StandardService类 org.apache.catalina.core.StandardService类是Service接口的标准实现。StandardService类的initialize方法初始化所有的添加到该服务的连接器。该类还实现了org.apache.catalina.Lifecycle接口，所以调用它的start方法能启动所有的连接器和容器。
  容器和连接器
  一个StandardService实例包括两种组件：一个容器和多个连接器。多个连接器可以使得Tomcat能服务于多个协议。一个协议用处处理HTTP请求，另一个用于处理HTTPS请求。
  StandardService类用container变量来持有容器实例，用connectors数组来持有所有的连接器 private Container container = null; private Connector connectors[] = new Connector[0]; 要将一个容器跟一个服务相关联，可以使用它的setContainer方法，如Listing14.7所示
  Listing 14.7: The setContainer method public void setContainer(Container container) { Container oldContainer = this.container; if ((oldContainer != null) && (oldContainer instanceof Engine)) ((Engine) oldContainer).setService(null); this.container = container; if ((this.container != null) && (this.container instanceof Engine)) ((Engine) this.container).setService(this); if (started && (this.container != null) && (this.container instanceof Lifecycle)) { try { ((Lifecycle) this.container).start(); } catch (LifecycleException e) { ; } } synchronized (connectors) { for (int i = 0; i < connectors.length; i++) connectors[i].setContainer(this.container); } if (started && (oldContainer != null) && (oldContainer instanceof Lifecycle)) { try {
  ((Lifecycle) oldContainer).stop(); } catch (LifecycleException e) { ; } } // Report this property change to interested listeners support.firePropertyChange("container", oldContainer, this.container); }
  要与服务相关联的容器传递给该每个连接器，这样来建立容器和每个连接器的关系。 要给一个服务添加连接器，可以使用addConnector方法。要删除一个连接器，可以使用removeConnector方法。它们分别如Listing14.8和Listing14.8所示
  Listing 14.8: The addConnector method public void addConnector(Connector connector) { synchronized (connectors) { connector.setContainer(this.container); connector.setService(this); Connector results[] = new Connector[connectors.length + 1]; System.arraycopy(connectors, 0, results, 0, connectors.length); results[connectors.length] = connector; connectors = results; if (initialized) { try { connector.initialize(); } catch (LifecycleException e) { e.printStackTrace(System.err); } } if (started && (connector instanceof Lifecycle)) { try { ((Lifecycle) connector).start(); } catch (LifecycleException e) { ; } }
  // Report this property change to interested listeners support.firePropertyChange("connector", null, connector); } }
  Listing 14.9: The removeConnector method public void removeConnector(Connector connector) { synchronized (connectors) { int j = -1; for (int i = 0; i < connectors.length; i++) { if (connector == connectors [i]) { j = i; break; } } if (j < 0) return; if (started && (connectors[j] instanceof Lifecycle)) { try {
  ((Lifecycle) connectors[j]).stop(); } catch (LifecycleException e) { ; } } connectors[j].setContainer(null); connector.setService(null); int k = 0; Connector results[] = new Connector[connectors.length - 1]; for (int i = 0; i < connectors.length; i++) { if (i != j) results[k++] = connectors[i]; } connectors = results; // Report this property change to interested listeners support.firePropertyChange("connector", connector, null); } }
  The addConnector method initializes and starts the added connector.
  Lifecycle方法
  Lifecycle方法是从Lifecycle接口继承而来。Initialize方法调用每个连接器的initialize方法，该方法如Listing14.10所示
  Listing 14.10: The initialize method of StandardService public void initialize() throws LifecycleException { if (initialized) throw new LifecycleException ( sm.getString("StandardService.initialize.initialized")); initialized = true; // Initialize our defined Connectors synchronized (connectors) { for (int i = 0; i < connectors.length; i++) { connectors[i].initialize(); } } }
  Start方法用于启动相关联的连接器和容器，如Listing14.11所示
  Listing 14.11: The start method public void start() throws LifecycleException { // Validate and update our current component state if (started) {
  throw new LifecycleException (sm.getString("standardService.start.started")); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null); System.out.println (sm.getString("standardService.start.name", this.name)); lifecycle.fireLifecycleEvent(START_EVENT, null); started = true; // Start our defined Container first if (container != null) { synchronized (container) { if (container instanceof Lifecycle) { ((Lifecycle) container).start();
  } } } // Start our defined Connectors second synchronized (connectors) { for (int i = 0; i < connectors.length; i++) { if (connectors[i] instanceof Lifecycle) ((Lifecycle) connectors[i]).start(); } } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null); }
  Stop方法关闭所有关联连接器和容器。Stop方法如Listing14.12所示
  Listing 14.12: The stop method public void stop() throws LifecycleException { // Validate and update our current component state if (!started) { throw new LifecycleException (sm.getString("standardService.stop.notStarted")); } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null); lifecycle.fireLifecycleEvent(STOP_EVENT, null); System.out.println (sm.getString("standardService.stop.name", this.name)); started = false; // Stop our defined Connectors first synchronized (connectors) {
  for (int i = 0; i < connectors.length; i++) { if (connectors[i] instanceof Lifecycle) ((Lifecycle) connectors[i]).stop(); } } // Stop our defined Container second
  if (container != null) { synchronized (container) { if (container instanceof Lifecycle) { ((Lifecycle) container).stop(); } } } // Notify our interested LifecycleListeners lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null); }
  The Application
  这个应用程序展示了如何使用服务器和服务，特别是它说明了如何使用StandardServer类的启动和停止机制。本程序由三个类组成，SimpleContextConfig跟第13章中的相同，另外两个类一个是Bootstrap启动程序，另一个是Stopper类用来停止它。
  Bootstrap类
  Bootstrap类如Listing14.13所示
  Listing 14.13: The Bootstrap Class package ex14.pyrmont.startup; import ex14.pyrmont.core.SimpleContextConfig; import org.apache.catalina.Connector; import org.apache.catalina.Context; import org.apache.catalina.Engine; import org.apache.catalina.Host; import org.apache.catalina.Lifecycle; import org.apache.catalina.LifecycleException; import org.apache.catalina.LifecycleListener; import org.apache.catalina.Loader; import org.apache.catalina.Server; import org.apache.catalina.Service; import org.apache.catalina.Wrapper; import org.apache.catalina.connector.http.HttpConnector;
  import org.apache.catalina.core.StandardContext; import org.apache.catalina.core.StandardEngine; import org.apache.catalina.core.StandardHost; import org.apache.catalina.core.StandardServer; import org.apache.catalina.core.StandardService;
  import org.apache.catalina.core.StandardWrapper; import org.apache.catalina.loader.WebappLoader; public final class Bootstrap { public static void main(String[] args) { System.setProperty("catalina.base", System.getProperty("user.dir")); Connector connector = new HttpConnector(); Wrapper wrapper1 = new StandardWrapper(); wrapper1.setName("Primitive"); wrapper1.setServletClass("PrimitiveServlet"); Wrapper wrapper2 = new StandardWrapper(); wrapper2.setName("Modern"); wrapper2.setServletClass("ModernServlet"); Context context = new StandardContext(); // StandardContext's start method adds a default mapper context.setPath("/app1"); context.setDocBase("app1"); context.addChild(wrapper1); context.addChild(wrapper2); LifecycleListener listener = new SimpleContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); Host host = new StandardHost(); host.addChild(context); host.setName("localhost"); host.setAppBase("webapps"); Loader loader = new WebappLoader(); context.setLoader(loader); // context.addServletMapping(pattern, name); context.addServletMapping("/Primitive", "Primitive"); context.addServletMapping("/Modern", "Modern"); Engine engine = new StandardEngine(); engine.addChild(host); engine.setDefaultHost("localhost"); Service service = new StandardService(); service.setName("Stand-alone Service"); Server server = new StandardServer(); server.addService(service); service.addConnector(connector); // StandardService class's setContainer method calls // its connectors' setContainer method service.setContainer(engine); // Start the new server if (server instanceof Lifecycle) {
  try { server.initialize(); ((Lifecycle) server).start(); server.await(); // the program waits until the await method returns, // i.e. until a shutdown command is received. }
  catch (LifecycleException e) { e.printStackTrace(System.out); } } // Shut down the server if (server instanceof Lifecycle) { try { ((Lifecycle) server).stop(); } catch (LifecycleException e) { e.printStackTrace(System.out); } } } }
  Bootstrap主方法的开始部分跟第13章相似。它创建了一个连接器、两个包装器、一个上下文、一个主机以及一个引擎。然后将包装器添加到上下文，将上下文添加到主机，主机添加到引擎。它并没有将连接器和引擎相关联，而是创建了一个一个服务对象，设置它的名字，创建一个服务器对象，并给该服务器添加服务。 Service service = new StandardService(); service.setName("Stand-alone Service"); Server server = new StandardServer(); server.addService(service); 然后，主方法将连接器和引擎添加到服务上。 service.addConnector(connector); service.setContainer(engine); 这样讲连接器添加到服务上，连接器在服务上跟容器相关联。 然后主方法调用服务器的initialize和start方法。初始化连接器并启动它以及容器。 if (server instanceof Lifecycle) { try {
  server.initialize(); ((Lifecycle) server).start(); 接下来，调用服务器的await方法让服务器等待一个关闭命令。注意现在连接器已经启动了，在8080端口为HTTP服务进行服务。 server.await() ;
  Await方法在接受到关闭指令以前会一直等待，接受到关闭指令后，调用服务器的stop方法，关闭其它所有组件。 接下来看用于停止服务器的Stopper类。
  Stopper类
  在前面的应用程序中，是通过按键来关闭容器。在本章中，Stopper类提供了一种优雅的方式来关闭Catalina服务器。它还保证了所有生命周期组件的stop方法会被调用。Stopper类如Listing14.14所示
  Listing 14.14: The Stopper class package ex14.pyrmont.startup; import java.io.OutputStream; import java.io.IOException; import java.net.Socket; public class Stopper { public static void main(String[] args) { // the following code is taken from the Stop method of // the org.apache.catalina.startup.Catalina class int port = 8005; try { Socket socket = new Socket("127.0.0.1", port); OutputStream stream = socket.getOutputStream(); String shutdown = "SHUTDOWN"; for (int i = 0; i < shutdown.length(); i++) stream.write(shutdown.charAt(i)); stream.flush(); stream.close(); socket.close(); System.out.println("The server was successfully shut down."); } catch (IOException e) { System.out.println("Error. The server has not been started."); } } }
  主方法创建一个Socket对象然后将关闭命令发送到8085端口。如果Catalina服务器正在运行，它将会被关闭。
  运行应用程序
  在Windows里面，可以在工作目录输入如下命令来运行该应用程序： java -classpath./lib/servlet.jar;./lib/commons- collections.jar;./lib/commons-digester.jar;./lib/naming- factory.jar;./lib/naming-common.jar;./ ex14.pyrmont.startup.Bootstrap 在Linux里，需要使用冒号来分隔开两个库 java -classpath ./lib/servlet.jar:./lib/commons- collections.jar:./lib/commons-digester.jar:./lib/naming- factory.jar:./lib/naming-common.jar:./ ex14.pyrmont.startup.Bootstrap 可以在浏览器输入如下URL来调用PrimitiveServlet http://localhost:8080/app1/Primitive 要调用invoke方法，可以使用如下URL http://localhost:8080/app1/Modern 可以在工作目录下面运行Stopper来停止该应用程序： java ex14.pyrmont.startup.Stopper 注意在一个真正的Catalina部署中，提供停止服务的Stopper类的功能会被包装在Bootstrap类中
  总结
  本章解释了两个Catalina的重要组件：服务器和服务。服务器是非常有用，它提供了一种优雅的机制来启动和停止一个Catalina部署。而一个服务器
  第15章: Digester
  综述
  在前面章节中已经看到，使用Bootstrap类来初始化连接器、上下文、包装器以及其它组件。一旦你获得了它们的对象就可以使用set方法来关联它们。例如可以如下初始化连接器和上下文 Connector connector = new HttpConnector(); Context context = new StandardContext(); 将连接器和上下文关联起来可以如下实现： connector.setContainer(context); 可以使用相应的set方法来配置这些对象的属性。例如可以使用setPath和setDocBase方法来设置path和docBase属性。 context.setPath("/myApp") ; context.setDocBase("myApp"); 另外，可以初始化各种组件，然后使用相应的add方法将其添加到上下文容器中。例如，下面是如何在上下文对象中添加生命周期监听器和加载器： LifecycleListener listener = new SimpleContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); Loader loader = new WebappLoader(); context.setLoader(loader); 一旦必要的关联和添加设置完毕，就可以调用连接器的initialize和start方法和上下文的start方法了。 connector.initialize(); ((Lifecycle) connector).start (); ((Lifecycle) context).start();
  这种方式来配置应用程序有一个很明显的缺点，所有的东西都是硬编码的。要更改一个组件或者一个属性的值都需要重新编译整个Bootstrap类。幸运的是，Tomcat的设计者选择了一种更优雅的方式来进行配置，使用名为server.xml的XML文档。Server.xml中的每一个元素都被转换为一个Java对象，元素的属性用来设置属性。这样，就可以通过编辑server.xml来改变Tomcat的配置。例如，上下文容器元素就可以这样在server.xml中表示 <context/> To set the path and docBase properties you use attributes in the XML element: <context docBase="myApp" path="/myApp"/> Tomcat使用开源工具Digester来讲XML元素转换为Java对象。Digester将会在本章第一节介绍。
  接下来的一节介绍了如何配置一个web应用程序，一个上下文被用来表示一个web应用程序，一次配置初始化该上下文实例即可达到配置该web应用的目的。配置web应用所使用的web应用所使用的XML文件时web.xml，该文件必须存放在该应用程序的WEB-INF目录下面。
  Digester
  Digester是Apache Jakarta项目下面的开源项目。可以在http://jakarta.apache.org/commons/digester/下载到Digester。Digester由三个包组成，被包装到commons-digeser.jar文件中： · org.apache.commons.digester.提供了基于规则（rules-based）的任意XML文档处理。 · org.apache.commons.digester.rss.演示了如何使用Digester解析XML文档，跟很多地方使用的rich site summary格式比较。 · org.apache.commons.digester.xmlrules.该包提供了给Digester提供基于XML文档的规则。 我们不会介绍着三个包的所有成员，而是重点介绍在Tomcat中重要的几个类型。本节首先介绍Digester库里最重要的Digester类：
  Digester类
  org.apache.commons.digester.Digester类是Digester库里的主类。使用它来解析XML文档。对于该文档中的每一个元素，Digester都检查它是否需要做点事情，程序员只需决定Digester实例在调用parser方法之前需要做什么即可。 你怎样告诉一个Digester对象遇到一个XML元素的时候怎么做？很简单，你定义模式并且将模式跟一条或多条规则相关联即可。XML的根元素有一个跟他的元素名相同的模式，例如：Listing15.1所示的XML文档。
  Listing 15.1: The example.xml file <?xml version="1.0" encoding="ISO-8859-1"?> <employee firstName="Brian" lastName="May"> <office> <address streeName="Wellington Street" streetNumber="110"/> </office> </employee>
  该文档的根元素师employee，该元素的模式emploee。它的office元素是<employee>的子元素。一个子元素的模式是它的名字加上它属于的元素作为前缀。所以office元素的模式是employee/office，而address元素的模式是： the parent element's pattern + "/" + the name of the element
  Address元素的父元素师<office>，<office>元素的模式employee/office。因此，<address>的模式employee/office/address。 现在你已经明白了如何从XML文档中获得模式，接下来讨论下规则（rules）。 一个规则定义了Digester遇到特别的模式的时候必须做的动作。一个规则用org.apache.commons.digester.Rule类。Digester类包括零个或多个Rule对象。在一个Digester实例中，规则及其模式被存储在接口org.apache.commons.digester.Rules定义的类型中。每一次给Digester实例添加规则，都将Rule对象添加到Rules对象。 在Rule中有两个方法：begin方法和end方法。当解析一个XML文档的时候，遇到开始元素，Digester实例调用Rule对象的begin方法，而遇到结束元素的时候调用stop方法。 当解析如Listing15.1所示的example.xml所示的文档的时候，下面是Digester对象所作的。 · 第一次遇到employee开始元素，检查是否已经有存在的规则模式employee。如果有，Digester调用Rule对象的begin方法，从begin方法开始添加第一个模式。 · 然后检查office元素，所以Digester对象检查是否存在规则模式为employee/office。如果有，，调用Rule对象的begin方法、 · 接下来检查模式employee/office/address，如果找到了规则，则调用begin方法 · 接下来Digester遇到了address结束符，调用对应规则的end方法。 · 解析来遇到了office结束符，调用相应规则的end方法。 · 最后遇到了employee结束符，调用相应规则的end方法。 可以使用什么规则？Digester预先定义了一些规则，甚至在不了解Rule类的时候都可以使用这些规则。但是，如果这些规则不足够，你需要建立自己的规则。实现定义的规则包括创建对象，设置属性值等。
  创建对象
  如果想让Digester给特定的规则创建对象，可以调用它的addObjectCreate方法。该方法有四个实现，其中两个最常用方法的签名如下： public void addObjectCreate(java.lang.String pattern, java.lang.Class clazz)
  public void addObjectCreate(java.lang.String pattern, java.lang.String className)
  传递一个模式和类对象（或者是类名）给它们。例如，你想Digester根据employee模式，创建一个Employee对象（类为ex15.pyrmont.digestertest.Employee）可以使用如下代码： digester.addObjectCreate("employee", ex15.pyrmont.digestertest.Employee.class); 或者 digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee"); 方法addObjectCreate的另外两个实现允许在XML文档中定义类名，而不是通过作为方法参数。这个特性带来了强大的功能，它使得类名可以在运行时决定，下面是这两个方法的签名： public void addObjectCreate(java.lang.String pattern, java.lang.String className, java.lang.String attributeName) public void addObjectCreate(java.lang.String pattern, java.lang.String attributeName, java.lang.Class clazz) 在这两个实现中，attributeName参数定义了XML文档中的属性，名字有className指定。例如，如果使用下面的代码来定义创建对象规则： digester.addObjectCreate("employee", null, "className"); 其中属性名为className 然后在XML中传递类名： <employee firstName="Brian" lastName="May" className="ex15.pyrmont.digestertest.Employee"> 或者可以如下在addObjectCreate方法中定义默认的类名： digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee", "className"); 如果employee元素包括一个className属性，就用该属性的值来进行类的初始化，如果没有改属性，使用默认值来进行初始化。
  使用addObejectCreate方法创建的对象被压到一个内部堆栈中，并定义来peek、push以及pop方法来操作创建的对象。
  设置属性
  另一个重要的方法是addSetProperties，Digester对象可以通过它设置对象属性。该方法的一个实现的签名如下： public void addSetProperties(java.lang.String pattern) 传递一个模式给该方法，例如下面的代码： digester.addObjectCreate("employee",
  "ex15.pyrmont.digestertest.Employee"); digester.addSetProperties("employee"); 上面的Digester实例有两个规则：创建对象，设置属性。都是关于employee模式的。根据添加的顺序来执行这些规则。XML文档中如下的employee元素 <employee firstName="Brian" lastName="May"> Digester实例首先创建一个ex15.pyrmont.digestertest.Employee类的实例，由第一个规则得到。然后ex15.pyrmont.digestertest.Employee使用第二条规则来根据XML文档调用setFirstName和setLasetName属性来设置Employee对象的值。属性的值跟XML文档中相应元素的属性值是一致的，如果Employee类没有定义该属，会产生错误。
  方法调用
  Digester允许通过添加规则，见到相应的模式的时候就尅调用栈最高层中对象的方法。该方法名为addCallMethod，它的一个实现的签名如下： public void addCallMethod (java.lang.String pattern, java.lang.String methodName)
  建立对象间的联系
  Digester实例有一个栈用来临时存储对象。当调用addObjectCreate创建对象后，将对象压入堆栈中。可以把堆栈想象成一口井，可以将对象放入到井中，而pop方法相当于取出井中最上边的元素。 当通过addObjectCreate方法创建两个对象的时候，第一个对象被放入井中，然后是第二个。addSetNext用于建立第一个对象和第二个对象之间的关系，它把第二个对象作为参数传递给第一个对象。下面是addSetNext方法的签名： public void addSetNext(java.lang.String pattern, java.lang.String methodName) 参数argument定义了触发该规则的模式，methodName参数是是第一个对象要被调用的方法名。该模式的形式如firstObject/secondObject。 例如，一个employee可以有一个office，要创建一个employee和他的office之间的关系，首先需要使用两个addObjectCreate方法。 digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee"); digester.addObjectCreate("employee/office", "ex15.pyrmont.digestertest.Office");
  第一个addObjectCreate方法根据employee元素创建一个Employee类实例。第二个addObjectCreate方法根据<employee>下面的<office>创建一个Office实例。 这两个addObjectCreate方法将两个对象压入到堆栈中，现在对象在栈底部，Office对象在栈顶部。要建立它们之间的关系，可以使用addSetNext方法方法： digester.addSetNext("employee/office", "addOffice"); 其中addOffice是Employee类的方法，该方法必须接受一个Office对象作为参数，第二个Digester实例将会说明仔细介绍setSetNext方法。
  验证XML文档
  可以使用Digester来对XML文档的结构进行验证，一个XML文档是否合法取决于由Digester定义的validating属性，该属性的默认值为false。 方法setValidating用来用来设置是否要验证XML文档，该方法的签名如下： public void setValidating(boolean validating) 如果想要验证XML文档，可以传递一个true值该该方法：
  Digester Example 1
  第一个例子说明了如何使用Digester动态的创建对象并设置它的属性。考虑Listing15.2所示的类Employee用Digester来初始化：
  Listing 15.2: The Employee Class package ex15.pyrmont.digestertest; import java.util.ArrayList; public class Employee { private String firstName; private String lastName; private ArrayList offices = new ArrayList(); public Employee () { System.out.println ("Creating Employee"); } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { System.out.println("Setting firstName : " + firstName); this.firstName = firstName; } public String getLastName() { return lastName;
  } public void setLastName(String lastName) { System.out.println("Setting lastName : " + lastName); this.lastName = lastName; } public void addOffice(Office office) {
  System.out.println("Adding Office to this employee"); offices.add(office); } public ArrayList getOffices() { return offices; } public void printName() { System.out.println("My name is " + firstName + " " + lastName); } }
  Employee类有三个属性：firstName、lastName和office。firstName和lastName类型为String类型，office类型为ex15.pyrmont.digester.Office类型。Office属性用作Digester的第二个例子。 Employee还有一个方法：printName方法将first name和last name打印到console上面。 接下来写一个测试类用Digester来创建Employee对象并设置它的属性，如Listing15.3所示的Test01所示的类即可。
  Listing 15.3: The Test01 Class package ex15.pyrmont.digestertest; import java.io.File; import org.apache.commons.digester.Digester; public class Test01 { public static void main(String[] args) { String path = System.getProperty("user.dir") + File.separator + "etc"; File file = new File(path, "employee1.xml"); Digester digester = new Digester(); // add rules digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee"); digester.addSetProperties("employee"); digester.addCallMethod("employee", "printName");
  try { Employee employee = (Employee) digester.parse(file); System.out.println("First name : " + employee.getFirstName()); System.out.println("Last name : " + employee.getLastName()); } catch(Exception e) { e.printStackTrace(); } } }
  首先定义定义XML所在的路径并将其传递给File类的构造函数，然后创建一个Digester对象并添加employee的如下规则： digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee"); digester.addSetProperties("employee"); digester.addCallMethod("employee", "printName"); 接下来调用调用Digester类的parse方法，将该XML文档作为参数。该方法的返回值是Digester类的内部栈的第一个对象。 Employee employee = (Employee) digester.parse(file); 这样通过Digester获得了一个Employee对象的对象，接下来看该对象的属性，调用getFirstName方法和getLastName方法即可： System.out.println("First name : " + employee.getFirstName()); System.out.println("Last name : " + employee.getLastName()); 现在看Listing15.4所示的employee1.xml文档，根为employee，该元素有两个属性，firstName和lastName。
  Listing 15.4: The employee1.xml file <?xml version="1.0" encoding="ISO-8859-1"?> <employee firstName="Brian" lastName="May"> </employee>
  运行Test01类得到如下运行结果： Creating Employee Setting firstName : Brian Setting lastName : May My name is Brian May First name : Brian Last name : May 下面看问什么会这样
  当调用Digester对象的parse方法的时候，它打开XML文档开始解析它。首先，Digester看到了employee的开始元素。这样触发了关于employee模式的三个规则，第一个是创建一个对象，所以Digester初始化一个Employee类的对象，这样需要调用Employee类的构造函数，该构造函数打印出字符串“Creating Employee”。
  第二个规则设置Employee对象的属性，该元素有两个属性：firstName和lastName。该规则调用方法这两个属性的set方法。这两个set方法打印出如下字符串： Setting firstName : Brian Setting lastName : May 第三个规则调用printName方法，打印出如下内容： My name is Brian May 接下来，最后两行诗调用getFirstName和getLastName方法的结果。 First name : Brian Last name : May
  Digester Example 2
  Digester类的第二个例子说明了如何创建两个对象，并建立它们之间的关系。关系的定义需要事先定义好。例如，一个employee在一个或多个office里工作。一个office用Office类表示。可以创建一个Employee类和Office类的对象并建立它们之间的关系。Office类Listing15.5所示：
  Listing 15.5: The Office Class package ex15.pyrmont.digestertest; public class Office { private Address address; private String description; public Office() { System.out.println("..Creating Office"); } public String getDescription() { return description; } public void setDescription(String description) { System.out.println("..Setting office description : " + description); this.description = description; } public Address getAddress() { return address;
  } public void setAddress(Address address) { System.out.println("..Setting office address : " + address);
  this.address = address; } }
  调用父对象的方法来建立它们之间的关系，注意该例子使用的是Listing15.2所示的Employee类，它由addOffice方法来建立它们之间的关系。 如果不适用Digester的话，可以使用如下Java代码来实现 Employee employee = new Employee(); Office office = new Office(); employee.addOffice(office); 每一个office都有一个address，而address如Listing15.6所示：
  Listing 15.6: The Address Class package ex15.pyrmont.digestertest; public class Address { private String streetName; private String streetNumber; public Adress () { System.out.println("....Creating Address"); } public String getStreetName() { return streetName; } public void setStreetName(String streetName) { System.out.println("....Setting streetName : " + streetName); this.streetName = streetName; } public String getStreetNumber() { return streetNumber; } public void setStreetNumber(String streetNumber) { System.out.println("....Setting streetNumber : " + streetNumber); this.streetNumber = streetNumber; } public String toString() { return "...." + streetNumber + " " + streetName; } }
  要将一个address赋值给office，可以使用Office类的setAddress方法。如果不适用Digester，可以使用如下代码实现： Office office = new Office(); Address address = new Address(); office.setAddress (address);
  第二个Digester例子说明如何创建多个对象并建立它们之间的关系。例子中会使用到Employee、Office和Address类，Test02使用Digester并向上添加规则：
  Listing 15.7: The Test02 Class package ex15.pyrmont.digestertest; import java.io.File; import java.util.*; import org.apache.commons.digester.Digester; public class Test02 { public static void main(String[] args) { String path = System.getProperty("user.dir") + File.separator + "etc"; File file = new File(path, "employee2.xml"); Digester digester = new Digester(); // add rules digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee"); digester.addSetProperties("employee"); digester.addObjectCreate("employee/office", "ex15.pyrmont.digestertest.Office"); digester.addSetProperties("employee/office"); digester.addSetNext("employee/office", "addOffice"); digester.addObjectCreate("employee/office/address", "ex15.pyrmont.digestertest.Address"); digester.addSetProperties("employee/office/address"); digester.addSetNext("employee/office/address", "setAddress"); try { Employee employee = (Employee) digester.parse(file); ArrayList offices = employee.getOffices(); Iterator iterator = offices.iterator(); System.out.println( "-------------------------------------------------"); while (iterator.hasNext()) { Office office = (Office) iterator.next(); Address address = office.getAddress();
  System.out.println(office.getDescription()); System.out.println("Address : " + address.getStreetNumber() + " " + address.getStreetName()); System.out.println(" -------------------------------"); } } catch(Exception e) { e.printStackTrace(); } } }
  要看到Digester如何工作的，可以使用Listing15.8所示的XML文档：
  Listing 15.8: The employee2.xml file <?xml version="1.0" encoding="ISO-8859-1"?> <employee firstName="Freddie" lastName="Mercury"> <office description="Headquarters"> <address streetName="Wellington Avenue" streetNumber="223"/> </office> <office description="Client site"> <address streetName="Downing Street" streetNumber="10"/> </office> </employee>
  Test02类的运行结果如下： Creating Employee Setting firstName : Freddie Setting lastName : Mercury ..Creating Office ..Setting office description : Headquarters ....Creating Address ....Setting streetName : Wellington Avenue ....Setting streetNumber : 223 ..Setting office address : ....223 Wellington Avenue Adding Office to this employee ..Creating Office ..Setting office description : Client site ....Creating Address ....Setting streetName : Downing Street ....Setting streetNumber : 10 ..Setting office address : ....10 Downing Street Adding Office to this employee -------------------------------------------------
  Headquarters Address : 223 Wellington Avenue -------------------------------- Client site Address : 10 Downing Street --------------------------------
  Rule类
  Rule 类有多个方法，其中两个最重要的是begin和end方法。当Digester实例遇到一个XML元素的开始标志的使用，调用所有匹配规则的begin方法。Rule类的begin方法签名如下： public void begin(org.xml.sax.Attributes attributes) throws java.lang.Exception
  当Digester实例遇到XML元素的end时候，调用所有匹配规则的end方法，Rule类的end方法签名如下： public void end() throws java.lang.Exception Digester对象在前面的例子是如何做到这些的？每次调用addObjectCreate、addCallMethod、addSetNext方法的或者该类其它的方法的时候，都会间接的调用Digester类的addRule方法，该方法会将一个Rule对象以及它的匹配模式添加到Didgester内部的规则集合中。 addRule 方法的签名如下 public void addRule(java.lang.String pattern, Rule rule) 该方法在Digester类中的实现如下： public void addRule(String pattern, Rule rule) { rule.setDigester(this); getRules().add(pattern, rule); } 看一下Digester中源代码对addObjectCreate方法的实现： public void addObjectCreate(String pattern, String className) { addRule(pattern, new ObjectCreateRule(className)); } public void addObjectCreate(String pattern, Class clazz) { addRule(pattern, new ObjectCreateRule(clazz)); } public void addObjectCreate(String pattern, String className, String attributeName) { addRule(pattern, new ObjectCreateRule(className, attributeName)); } public void addObjectCreate(String pattern, String attributeName, Class clazz) {
  addRule(pattern, new ObjectCreateRule(attributeName, clazz)); } 这四个实现都调用了addRule方法，ObjectCreateRule类是Rule类的子类。你可能会对begin和end方法在ObjectCreateRule类中的实现感兴趣： public void begin(Attributes attributes) throws Exception { // Identify the name of the class to instantiate String realClassName = className; if (attributeName != null) { String value = attributes.getValue(attributeName);
  if (value != null) { realClassName = value; } } if (digester.log.isDebugEnabled()) { digester.log.debug("[ObjectCreateRule]{" + digester.match + "}New " + realClassName); } // Instantiate the new object and push it on the context stack Class clazz = digester.getClassLoader().loadclass(realClassName); Object instance = clazz.newInstance(); digester.push(instance); } public void end() throws Exception { Object top = digester.pop(); if (digester.log.isDebugEnabled()) { digester.log.debug("[ObjectCreateRule]{" + digester.match + "} Pop " + top.getdass().getName()); } } 在begin方法中的最后三行创建了对象并将其压到Digester类的内部堆栈中，end方法使用pop方法从堆栈中获得对象。 Rule类的其它子类工作方式是类似的，如果想知道它们是如何工作的可以查看它们的源代码
  Digester Example 3: RuleSet的使用
  另一种往Digester实例添加规则方法是调用addRuleSet方法，该方法的签名如下： public void addRuleSet(RuleSet ruleSet)
  org.apache.commons.digester.RuleSet表示了Rule对象，该接口定义了两个方法：addRuleInstance和getNamespaceURI。addRuleInstance的签名如下： public void addRuleInstance(Digester digester) 方法addRuleInstance将在当前RuleSet中定义的Rule对象添加到Digester实例中，参数就是该对象。 方法getNamespaceURI返回用于请求所有规则对象的名字空间URI，它的签名如下：
  public java.lang.String getNamespaceURI() 因此，在创建完一个Digester对象后，可以创建RuleSet对象并传递一个RuleSet对象给addRuleSet方法。 有一个基本类RuleSetBase实现了RuleSet接口，RuleSetBase是一个抽象类，它提供了getNamespaceURI的实现，你需要做的只是提供addRuleInstances的实现即可。 这里修改前面例子中的Test02类来介绍EmployeeRuleSet类
  Listing 15.9: The EmployeeRuleSet Class package ex15.pyrmont.digestertest; import org.apache.commons.digester.Digester; import org.apache.commons.digester.RuleSetBase; public class EmployeeRuleSet extends RuleSetBase { public void addRuleInstances(Digester digester) { // add rules digester.addObjectCreate("employee", "ex15.pyrmont.digestertest.Employee"); digester.addSetProperties("employee"); digester.addObjectCreate("employee/office", "ex15.pyrmont.digestertest.Office"); digester.addSetProperties("employee/office"); digester.addSetNext("employee/office", "addOffice"); digester.addObjectCreate("employee/office/address", "ex15.pyrmont.digestertest.Address"); digester.addSetProperties("employee/office/address"); digester.addSetNext("employee/office/address", "setAddress"); } }
  注意addRuleInstances方法在EmployeeRuleSet中的实现跟Test02添加了相同的规则，如Listing15.10所示的Test03创建了一个EmployeeRuleSet兵将其添加到Digester对象上。
  Listing 15.10: The Test03 Class
  package ex15.pyrmont.digestertest; import java.io.File; import java.util.ArrayList; import java.util.Iterator; import org.apache.commons.digester.Digester; public class Test03 {
  public static void main(String[] args) { String path = System.getProperty("user.dir") + File.separator + "etc"; File file = new File(path, "employee2.xml"); Digester digester = new Digester(); digester.addRuleSet(new EmployeeRuleSet()); try { Employee employee = (Employee) digester.parse(file); ArrayList offices = employee.getOffices(); Iterator iterator = offices.iterator(); System.out.println( "-------------------------------------------------"); while (iterator.hasNext()) { Office office = (Office) iterator.next(); Address address = office.getAddress(); System.out.println(office.getDescription()); System.out.println("Address : " + address.getStreetNumber() + " " + address.getStreetName()); System.out.println ("-------------------------------"); } } catch(Exception e) { e.printStackTrace (); } } }
  运行的时候，Test03跟Test02产生了相同的输出，注意Test03比较短，因为它将添加规则对象的操作隐藏到了EmployeeRuleSet类中。 接下来你会看到，Catalina使用RuleSetBase的子类来初始化服务器和其他组件，在下一节里，你会看到Digester在Catalina中扮演的重要角色。
  ContextConfig类
  跟其它类型的容器不同，StandardContext必须有一个监听器，该监听器用于配置StandardContext对象并将StandardContext的configured变量设置为true。在前面的章节中，使用SimpleContextConfig类来作为StandardContext的监听器。该类是一个非常简单的类，它的目的是设置configured变量那样StandardContext的start方法可以继续。
  在一个实际的Tomcat部署中，StandardContext的标准监听器是org.apache.catalina.startup.ContextConfig类的实例。不像简单的SimpleContextConfig类，ContextConfig做了很多有用的工作。例如，ContextConfig实例给StandardContext的流水线安装一个验证阀门。它还给流水线添加一个证书阀门。 更重要的是，ContextConfig实例还读并解析默认的web.xml文件，并将其中的XML元素转换为Java对象。默认的web.xml文档在CATALINE_HOME下面的conf目录下面。它定义并映射了默认的Servlet，并映射MIME类型的文件扩展，定义默认Session失效时间，欢迎文件列表。你可以打开该文件看看里面的内容。 应用程序的web.xml是文件应用配置文件，处于应用程序目录下的WEB-INF目录下面。这两个文件都不是必须的，ContextConfig在找不到它们的情况下仍然可以工作。 ContextConfig为每一个Servlet元素创建了一个StandardWrapper实例。因此，在本章的应用程序中可以看到配置是很简单的。不需要自己在完成包装器初始化任务。 因此，在你的启动类中，必须初始化ContextConfig类并且将其添加到StandardContext，使用的方法是org.apache.catalina.Lifecycle接口的addLifecycleListener方法。 LifecycleListener listener = new ContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); StandardContext在它启动的时候触发以下事件： · BEFORE_START_EVENT · START_EVENT · AFTER_START_EVENT 停止的时候StandardContext触发以下事件： · BEFORE_STOP_EVENT · STOP_EVENT · AFTER_STOP_EVENT ContextConfig回应两个事件START_EVENT 和STOP_EVENT。lifecycleEvent方法在StandardContext每次触发事件的时候都会被调用。该方法如Listing15.11所示。我们在Listing15.11中添加了注释以助于对stop方法的理解。
  Listing 15.11: The lifecycleEvent method of ContextConfig public void lifecycleEvent(LifecycleEvent event) { // Identify the context we are associated with
  try { context = (Context) event.getLifecycle(); if (context instanceof StandardContext) { int contextDebug = ((StandardContext) context).getDebug(); if (contextDebug > this.debug) this.debug = contextDebug; } } catch (ClassCastException e) { log(sm.getString("contextConfig.cce", event.getLifecycle()), e); return; } // Process the event that has occurred if (event.getType().equals(Lifecycle.START_EVENT)) start(); else if (event.getType().equals(Lifecycle.STOP_EVENT)) stop(); }
  如你看到的在lifecycleEvent的最后，它调用自己的start方法或者stop方法。Start方法如Listing15.12所示。注意在它内部的start方法调用了defaultConfig 和 applicationConfig方法。它们会在下一节中介绍。
  Listing 15.12: The start method of ContextConfig private synchronized void start() { if (debug > 0) log(sm.getString("ContextConfig.start")); // reset the configured boolean context.setConfigured(false); // a flag that indicates whether the process is still // going smoothly ok = true; // Set properties based on DefaultContext Container container = context.getParent(); if( !context.getOverride() ) { if( container instanceof Host ) { ((Host)container).importDefaultContext(context); container = container.getParent(); } if( container instanceof Engine ) { ((Engine)container).importDefaultContext(context); } }
  // Process the default and application web.xml files
  defaultConfig(); applicationConfig(); if (ok) { validateSecurityRoles(); } // Scan tag library descriptor files for additional listener classes if (ok) { try { tldScan(); } catch (Exception e) { log(e.getMessage(), e); ok = false; } } // Configure a certificates exposer valve, if required if (ok) certificatesConfig(); // Configure an authenticator if we need one if (ok) authenticatorConfig(); // Dump the contents of this pipeline if requested if ((debug >= 1) && (context instanceof ContainerBase)) { log("Pipline Configuration:"); Pipeline pipeline = ((ContainerBase) context).getPipeline(); Valve valves[] = null; if (pipeline != null) valves = pipeline.getValves(); if (valves != null) { for (int i = 0; i < valves.length; i++) { log(" " + valves[i].getInfo()); } } log("======================"); } // Make our application available if no problems were encountered if (ok) context.setConfigured(true); else { log(sm.getString("contextConfig.unavailable")); context.setConfigured(false); }
  }
  defaultConfig 方法
  方法defaultConfig读取并解析默认的%CATALINA_HOME%/conf目录下面的web.xml。defaultConfig方法如Listing15.13所示
  Listing 15.13: The defaultConfig method private void defaultConfig() { // Open the default web.xml file, if it exists File file = new File(Constants.DefaultWebXml); if (!file.isAbsolute()) file = new File(System.getProperty("catalina.base"), Constants.DefaultWebXml); FileInputStream stream = null; try { stream = new FileInputStream(file.getCanonicalPath()); stream.close(); stream = null; } catch (FileNotFoundException e) { log(sm.getString("contextConfig.defaultMissing")); return; } catch (IOException e) { log(sm.getString("contextConfig.defaultMissing"), e); return; } // Process the default web.xml file synchronized (webDigester) { try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); stream = new FileInputStream(file); is.setByteStream(stream); webDigester.setDebug(getDebug()); if (context instanceof StandardContext) ((StandardContext) context).setReplaceWelcomeFiles(true); webDigester.clear(); webDigester.push(context); webDigester.parse(is); } catch (SAXParseException e) {
  log(sm.getString("contextConfig.defaultParse"), e); log(sm.getString("contextConfig.defaultPosition", "" + e.getLineNumber(), "" + e.getColumnNumber())); ok = false; } catch (Exception e) { log(sm.getString("contextConfig.defaultParse"), e); ok = false; } finally { try { if (stream != null) { stream.close(); } } catch (IOException e) { log(sm.getString("contextConfig.defaultClose"), e); } }
  } }
  defaultConfig方法首先传教一个File对象指向默认的web.xml。 File file = new File(Constants.DefaultWebXml); DefaultWebXML的值可以在org.apache.catalina.startup.Constants中找到： public static final String DefaultWebXml = "conf/web.xml"; 然后方法defaultConfig处理web.xml文件。它对webDigester对象枷锁，然后解析该文件。 synchronized (webDigester) { try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); stream = new FileInputStream(file); is.setByteStream(stream); webDigester.setDebug(getDebug()); if (context instanceof StandardContext) ((StandardContext) context).setReplaceWelcomeFiles(true); webDigester.clear(); webDigester.push(context); webDigester.parse(is);
  webDigester变量指向一个Digester对象的实例，该实例用于处理web.xml并添加规则。这些将在下面”creating Web Digester”小节中介绍到。
  applicationConfig 方法
  applicationConfig方法defaultConfig方法相似，除了处理应用程序部署文件的地方。一个应用的部署文件在该应用目录下的WEB-INF目录下面 applicationConfig方法如Listing15.14所示：
  Listing 15.14: The applicationConfig method of ContextConfig private void applicationConfig() { // Open the application web.xml file, if it exists InputStream stream = null; ServletContext servletContext = context.getServletContext(); if (servletContext != null) stream = servletContext.getResourceAsStream (Constants.ApplicationWebXml); if (stream == null) {
  log(sm.getString("contextConfig.applicationMissing")); return; } // Process the application web.xml file synchronized (webDigester) { try { URL url = servletContext.getResource(Constants.ApplicationWebXml); InputSource is = new InputSource(url.toExternalForm()); is.setByteStream(stream); webDigester.setDebug(getDebug()); if (context instanceof StandardContext) { ((StandardContext) context).setReplaceWelcomeFiles(true); } webDigester.clear(); webDigester.push(context); webDigester.parse(is); } catch (SAXParseException e) { log(sm.getString("contextConfig.applicationParse"), e); log(sm.getString("contextConfig.applicationPosition", "" + e.getLineNumber(), "" + e.getColumnNumber()));
  ok = false; } catch (Exception e) { log(sm.getString("contextConfig.applicationParse"), e); ok = false; } finally { try { if (stream != null) { stream.close(); } } catch (IOException e) { log(sm.getString("contextConfig.applicationClose"),e); } } }
  } 创建web Digester 在ContextConfig类中存在一个名为webDigester的Digester对象： private static Digester webDigester = createWebDigester(); 该Digester用于解析默认web.xml以及应用程序web.xml。处理web.xml的规则在调用createWebDigester方法的时候会被添加。createWebDigester方法如Listing15.15所示：
  Listing 15.15: The createWebDigester method private static Digester createWebDigester() { URL url = null; Digester webDigester = new Digester(); webDigester.setValidating(true); url = ContextConfig.class.getResource( Constants.WebDtdResourcePath_22); webDigester.register(Constants.WebDtdPublicId_22, url.toString()); url = ContextConfig.class.getResource( Constants.WebDtdResourcePath_23); webDigester.register(Constants.WebDtdPublicId_23, url.toString()); webDigester.addRuleSet(new WebRuleSet()); return (webDigester); }
  注意createWebDigester方法在webDigester中调用addRuleSet的时候传递一个org.apache.catalina.startu. WebRuleSet p实例. WebRuleSet是org.apache.commons.digester.RuleSetBase类的一个子类。如果你熟悉Servlet应用程序部署文件的语法并且读过本章前面的Digester部分，可以很容易的理解他是如何工作的。 Listing15.16所示的WebRuleSet，注意里面删除了addRuleInstance方法的一些内容以节省空间。
  Listing 15.16: The WebRuleSet class package org.apache.catalina.startup; import java.lang.reflect.Method; import org.apache.catalina.Context; import org.apache.catalina.Wrapper; import org.apache.catalina.deploy.SecurityConstraint; import org.apache.commons.digester.Digester; import org.apache.commons.digester.Rule; import org.apache.commons.digester.RuleSetBase; import org.xml.sax.Attributes; /** * <p><strong>RuleSet</strong> for processing the contents of a web application * deployment descriptor (<code>/WEB-INF/web.xml</code>) resource.</p> * * @author Craig R. McClanahan * @version $Revision: 1.1 $ $Date: 2001/10/17 00:44:02 $ */
  public class WebRuleSet extends RuleSetBase { // ------------------------------------- Instance Variables /** * The matching pattern prefix to use for recognizing our elements. */ protected String prefix = null; // ------------------------------------------- Constructor /** * Construct an instance of this <code>RuleSet</code> with * the default matching pattern prefix. */ public WebRuleSet () { this(""); }
  /** * Construct an instance of this <code>RuleSet</code> with * the specified matching pattern prefix. * * @param prefix Prefix for matching pattern rules (including the * trailing slash character) */ public WebRuleSet(String prefix) { super(); this.namespaceURI = null; this.prefix = prefix; } // ------------------------------------------- Public Methods /** * <p>Add the set of Rule instances defined in this RuleSet to the * specified <code>Digester</code> instance, associating them with * our namespace URI (if any). This method should only be called * by a Digester instance.</p> * * @param digester Digester instance to which the new Rule instances * should be added. */ public void addRuleInstances(Digester digester) { digester.addRule(prefix + "web-app", new SetPublicIdRule(digester, "setPublicId")); digester.addCallMethod(prefix + "web-app/context-param", "addParameter", 2); digester.addCallParam(prefix + "web-app/context-param/param-name", 0); digester.addCallParam(prefix + "web-app/context-param/param-value", 1); digester.addCallMethod(prefix + "web-app/display-name", "setDisplayName", 0); digester.addRule(prefix + "web-app/distributable", new SetDistributableRule(digester)); ... digester.addObjectCreate(prefix + "web-app/filter", "org.apache.catalina.deploy.FilterDef"); digester.addSetNext(prefix + "web-app/filter", "addFilterDef",
  "org.apache.catalina.deploy.FilterDef"); digester.addCallMethod(prefix + "web-app/filter/description", "setDescription", 0);
  digester.addCallMethod(prefix + "web-app/filter/display-name", "setDisplayName", 0); digester.addCallMethod(prefix + "web-app/filter/filter-class", "setFilterClass", 0); digester.addCallMethod(prefix + "web-app/filter/filter-name", "setFilterName", 0); digester.addCallMethod(prefix + "web-app/filter/large-icon", "setLargeIcon", 0); digester.addCallMethod(prefix + "web-app/filter/small-icon", "setSmallIcon", 0); digester.addCallMethod(prefix + "web-app/filter/init-param", "addInitParameter", 2); digester.addCallParam(prefix + "web-app/filter/init-param/param-name", 0); digester.addCallParam(prefix + "web-app/filter/init-param/param-value", 1); digester.addObjectCreate(prefix + "web-app/filter-mapping", "org.apache.catalina.deploy.FilterMap"); digester.addSetNext(prefix + "web-app/filter-mapping", "addFilterMap", "org.apache.catalina.deploy.FilterMap"); digester.addCallMethod(prefix + "web-app/filter-mapping/filter-name", "setFilterName", 0); digester.addCallMethod(prefix + "web-app/filter-mapping/servlet-name", "setServletName", 0); digester.addCallMethod(prefix + "web-app/filter-mapping/url-pattern", "setURLPattern", 0); digester.addCallMethod (prefix + "web-app/listener/listener-class", "addApplicationListener", 0); ... digester.addRule(prefix + "web-app/servlet", new WrapperCreateRule(digester)); digester.addSetNext(prefix + "web-app/servlet", "addChild", "org.apache.catalina.Container"); digester.addCallMethod(prefix + "web-app/servlet/init-param", "addInitParameter", 2); digester.addCallParam(prefix + "web-app/servlet/init-param/param-name", 0); digester.addCallParam(prefix + "web-app/servlet/init-param/param-value", 1); digester.addCallMethod(prefix + "web-app/servlet/jsp-file", "setJspFile", 0); digester.addCallMethod(prefix + "web-app/servlet/load-on-startup", "setLoadOnStartupString", 0); digester.addCallMethod(prefix +
  "web-app/servlet/run-as/role-name", "setRunAs", 0); digester.addCallMethod(prefix + "web-app/servlet/security-role-ref", "addSecurityReference", 2); digester.addCallParam(prefix + "web-app/servlet/security-role-ref/role-link", 1); digester.addCallParam(prefix + "web-app/servlet/security-role-ref/role-name", 0); digester.addCallMethod(prefix + "web-app/servlet/servlet-class", "setServletdass", 0);
  digester.addCallMethod(prefix + "web-app/servlet/servlet-name", "setName", 0); digester.addCallMethod(prefix + "web-app/servlet-mapping", "addServletMapping", 2); digester.addCallParam(prefix + "web-app/servlet-mapping/servlet-name"/ 1); digester.addCallParam(prefix + "web-app/servlet-mapping/url-pattern", 0); digester.addCallMethod (prefix + "web-app/session-config/session-timeout", "setSessionTimeout", 1, new Class[] { Integer.TYPE }); digester.addCallParam(prefix + "web-app/session-config/session-timeout", 0); digester.addCallMethod(prefix + "web-app/taglib", "addTaglib", 2); digester.addCallParam(prefix + "web-app/taglib/taglib-location", 1); digester.addCallParam(prefix + "web-app/taglib/taglib-uri", 0); digester.addCallMethod(prefix + "web-app/welcome-file-list/welcome-file", "addWelcomeFile", 0); } } // --------------------------------------------- Private Classes /** * A Rule that calls the <code>setAuthConstraint(true)</code> method of * the top item on the stack, which must be of type * <code>org.apache.catalina.deploy.SecurityConstraint</code>. */ final class SetAuthConstraintRule extends Rule { public SetAuthConstraintRule(Digester digester) { super(digester); }
  public void begin(Attributes attributes) throws Exception { SecurityConstraint securityConstraint = (SecurityConstraint) digester.peek(); securityConstraint.setAuthConstraint(true); if (digester.getDebug() > 0) digester.log("Calling SecurityConstraint.setAuthConstraint(true)"); } } ... final class WrapperCreateRule extends Rule { public WrapperCreateRule(Digester digester) { super(digester); } public void begin(Attributes attributes) throws Exception { Context context = (Context) digester.peek(digester.getCount() - 1); Wrapper wrapper = context.createWrapper(); digester.push(wrapper); if (digester.getDebug() > 0) digester.log("new " + wrapper.getClass().getName()); }
  public void end() throws Exception { Wrapper wrapper = (Wrapper) digester.pop(); if (digester.getDebug() > 0) digester.log("pop " + wrapper.getclass().getName()); } }
  The Application
  本章的应用程序说明了如何使用ContextConfig实例作为监听器来配置StandardContext对象。它只有一个类组成，如Listing15.17所示的BootStrap类：
  Listing 15.17: The Bootstrap class package ex15.pyrmont.startup; import org.apache.catalina.Connector; import org.apache.catalina.Container; import org.apache.catalina.Context; import org.apache.catalina.Host; import org.apache.catalina.Lifecycle;
  import org.apache.catalina.LifecycleListener; import org.apache.catalina.Loader; import org.apache.catalina.connector.http.HttpConnector; import org.apache.catalina.core.StandardContext; import org.apache.catalina.core.StandardHost; import org.apache.catalina.loader.WebappLoader; import org.apache.catalina.startup.ContextConfig; public final class Bootstrap { // invoke: http://localhost:8080/app1/Modern or // http://localhost:8080/app2/Primitive // note that we don't instantiate a Wrapper here, // ContextConfig reads the WEB-INF/classes dir and loads all // servlets. public static void main(String[] args) { System.setProperty("catalina.base", System.getProperty("user.dir")); Connector connector = new HttpConnector(); Context context = new StandardContext(); // StandardContext's start method adds a default mapper context.setPath("/app1"); context.setDocBase("app1"); LifecycleListener listener = new ContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); Host host = new StandardHost(); host.addChild(context); host.setName("localhost"); host.setAppBase("webapps");
  Loader loader = new WebappLoader(); context.setLoader(loader); connector.setContainer(host); try { connector.initialize(); ((Lifecycle) connector).start(); ((Lifecycle) host).start(); Container[] c = context.findChildren(); int length = c.length; for (int i=0; i<length; i++) { Container child = c[i]; System.out.println(child.getName()); } // make the application wait until we press a key.
  System.in.read(); ((Lifecycle) host) .stop(); } catch (Exception e) { e.printStackTrace(); } } }
  Running the Applications
  To run the application in Windows, from the working directory, type the following: java -classpath ./lib/servlet.jar;./lib/commons- collections.jar;./lib/commons-digester.jar;./lib/commons- logging.jar;./lib/commons-beanutils.jar;./ ex15.pyrmont.startup.Bootstrap In Linux, you use a colon to separate two libraries. java -classpath ./lib/servlet.jar:./lib/commons- collections.jar:./lib/commons-digester.jar:./lib/commons- logging.jar:./lib/commons-beanutils.jar:./ ex15.pyrmont.startup.Bootstrap To invoke PrimitiveServlet, use the following URL in your browser. http://localhost:8080/app1/Primitive To invoke ModernServlet, use the following URL. http://localhost:8080/app1/Modern
  总结
  Tomcat使用的是不同的配置，简单的配置配置使用server.xml文件通过Digester对象将XML元素转换为Java对象。另外，一个web.xml文档被用于配置servlet/JSP应用。Tomcat必须能够解析web.xml文档并基于XML文档配置上下问对象，Digester优雅的解决了这个问题。
  第16章： 关闭钩子
  综述 在很多环境下，在关闭应用程序的时候需要做一些清理工作。问题在于，用户并不是经常的按照要求的流程来退出。例如，在Tomcat部署通过初始化一个服务器并调用它的start方法来启动一个servlet容器，该方法又调用其他组件的start方法。正常的情况下，可以通过一个关闭命令来让服务器关闭所有组件（如14章中介绍）。如果突然的关闭程序，如关闭运行程序的控制台可能会发生意想不到的事情。 幸运的是，Java提供了一种优雅的方式供程序员来使用，这样可以保证清理代码的执行。本章将会说明如何使用一个关闭钩子（shutdown hool）来保证清理代码一定会被执行。 在Java中，虚拟机遇到两种事件的时候会关闭虚拟机： · 应用程序正常退出如System.exit方法被调用或者最后一个非守护退出。 · 用户突然强制终止虚拟机，例如键入CTRL+C或者在关闭Java程序之前从系统注销。 幸运的是，当关闭的时候，虚拟机会有以下两个步骤： 1. 虚拟机启动所有注册的关闭钩子。关闭钩子是实现在Runtime上面注册的线程。所有的关闭钩子会被同时执行直到完成。 2. 虚拟机调用所有的未被调用的finalizers
  在本章中，我们对第一个步骤感兴趣，它允许虚拟机提交清理代码。一个关闭钩子是java.lang.Thread类的子类，可以如下创建一个关闭钩子： · 写一个类继承Thread类 · 提供你的实现类中的run方法。该方法是应用程序被关闭的时候要提交的代码，无论是正常退出还是非正常退出。 · 在你的应用程序中，初始化一个关闭钩子 · 在当前的Runtime上使用addShutdownHook方法来注册该关闭钩子。 你可能已经注意到，你并没有启动该线程。虚拟机在它的关闭步骤中会启动该线程。 Listing16.1提供了一个简单的类名为ShutdownHookDemo以及一个Thread类的子类名为ShutdownHook类。注意其run方法仅仅会打印出一些语句在控制台上，但是，你可以在其中插入任何你想要执行的语句。
  Listing 16.1: Using Shutdown Hook package ex16.pyrmont.shutdownhook; public class ShutdownHookDemo {
  public void start() { System.out.println("Demo"); ShutdownHook ShutdownHook = new ShutdownHook(); Runtime.getRuntime().addShutdownHook(ShutdownHook); } public static void main(String[] args) { ShutdownHookDemo demo = new ShutdownHookDemo(); demo.start(); try { System.in.read(); } catch(Exception e) { } } } class ShutdownHook extends Thread { public void run() { System.out.println("Shutting down"); } }
  在初始化一个ShutdownHookDemo对象之后，主方法调用start方法。Start方法创建一个关闭钩子并在当前Runtime中注册。 ShutdownHook shutdownHook = new ShutdownHook(); Runtime.getRuntime().addShutdownHook(shutdownHook); 然后该程序等待用户键入回车键。 System.in.read(); 用户键入Enter键后，应用程序退出。但是虚拟机会运行关闭钩子，结果就是打印出语句“Shutting down” 一个关闭钩子的例子 另一个例子，考虑一个简单的Swing应用程序，名为MySwingApp。该应用程序启动的时候创建一个临时的文件，它关闭的时候，该临时文件必须被删除。
  Figure 16.1: A Swing application
  该类的代码如Listing16.2所示
  Listing 16.2: A simple Swing application package ex16.pyrmont.shutdownhook; import java.awt.*; import javax.swing.*; import java.awt.event.*; import java.io.File; import java.io.IOException; public class MySwingApp extends JFrame { JButton exitButton = new JButton(); JTextArea jTextArea1 = new JTextArea(); String dir = System.getProperty("user.dir"); String filename = "temp.txt"; public MySwingApp() { exitButton.setText("Exit"); exitButton.setBounds(new Rectangle(304, 248, 76, 37)); exitButton.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) { exitButton_actionPerformed(e); } }); this.getContentPane().setLayout(null);
  jTextArea1.setText("Click the Exit button to quit"); jTextArea1.setBounds(new Rectangle(9, 7, 371, 235)); this.getContentPane().add(exitButton, null); this.getContentPane().add(jTextArea1, null); this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setBounds(0,0, 400, 330); this.setvisible(true); initialize(); } private void initialize() { // create a temp file File file = new File(dir, filename); try { System.out.println("Creating temporary file"); file.createNewFile(); } catch (IOException e) { System.out.println("Failed creating temporary file."); } } private void shutdown() { // delete the temp file File file = new File(dir, filename); if (file.exists()) { System.out.println("Deleting temporary file."); file.delete(); } }
  void exitButton_actionPerformed(ActionEvent e) { shutdown(); System.exit(0); } public static void main(String[] args) { MySwingApp mySwingApp = new MySwingApp(); } }
  运行的时候，该应用程序调用它的initialize方法。该方法在用户工作目录下创建一个临时文件名为temp.txt private void initialize() {
  // create a temp file File file = new File(dir, filename); try { System.out.println("Creating temporary file"); file.createNewFile(); } catch (IOException e) { System.out.println("Failed creating temporary file."); } } 当用户关闭该应用程序的时候，程序必须删除该临时文件。我们希望用户总是点击Exit按钮，这样在shutdown方法中就可以总是删除临时文件。但是，临时文件在用户非正常退出的时候也必须被删除。 Listing16.3所示的类提供了一种解决方案，它提供了一个关闭钩子。该关闭钩子作为一个内部类来声明，所以它可以访问所有主类的方法。在Listing16.3中，关闭钩子的run方法调用了shutdown方法，保证了改方法一定会被执行。
  Listing 16.3: Using a shutdown hook in the Swing application package ex16.pyrmont.shutdownhook; import java.awt.*; import javax.swing.*; import java.awt.event.*; import java.io.File; import java.io.IOException; public class MySwingAppWithShutdownHook extends JFrame { JButton exitButton = new JButton(); JTextArea jTextArea1 = new JTextArea();
  String dir = System.getProperty("user.dir"); String filename = "temp.txt"; public MySwingAppWithShutdownHook() { exitButton.setText("Exit"); exitButton.setBounds(new Rectangle(304, 248, 76, 37)); exitButton.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(ActionEvent e) { exitButton_actionPerformed(e); } }); this.getContentPane().setLayout(null); jTextArea1.setText("Click the Exit button to quit"); jTextArea1.setBounds(new Rectangle(9, 7, 371, 235));
  this.getContentPane().add(exitButton, null); this.getContentPane().add(jTextArea1, null); this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setBounds(0,0, 400, 330); this.setVisible(true); initialize(); } private void initialize() { // add shutdown hook MyShutdownHook shutdownHook = new MyShutdownHook(); Runtime.getRuntime().addShutdownHook(shutdownHook); // create a temp file File file = new File(dir, filename); try { System.out.println("Creating temporary file"); file.createNewFile(); } catch (IOException e) { System.out.println("Failed creating temporary file."); } } private void shutdown() { // delete the temp file File file = new File(dir, filename); if (file.exists()) { System.out.println("Deleting temporary file."); file.delete(); } } void exitButton_actionPerformed(ActionEvent e) { shutdown(); System.exit(0); } public static void main(String[] args) { MySwingAppWithShutdownHook mySwingApp = new MySwingAppWithShutdownHook(); }
  private class MyShutdownHook extends Thread {
  public void run() { shutdown(); } } }
  注意该类的initialize方法，它做的第一件事情就是创建一个MyshutdownHook内部类对象。 // add shutdown hook MyShutdownHook shutdownHook = new MyShutdownHook(); 一旦你获得一个该类的实例，就可以将其传递给Runtime的addShutDownHook方法，如下： Runtime.getRuntime().addShutdownHook(shutdownHook); Initialize方法的其它部分就跟Listing16.2所示的相同了。它创建一个临时文件并打印出“Creating temporary file” // create a temp file File file = new File(dir, filename); try { System.out.println("Creating temporary file"); file.createNewFile(); } catch (IOException e) { System.out.println("Failed creating temporary file."); } } 接下来启动该应用程序，检查临时是否总是被删除。 Tomcat中的关闭钩子 如你所料，Tomcat也有自己的关闭钩子。你可以在org.apache.catalina.startup.Catalina类中找到它，该类负责启动服务器对象以管理其它组件。在该类中有一个内部类CatalinaShutdownHook继承了java.lang.Thread类，在该类的run方法中调用了服务器的stop方法。
  Listing 16.4: Catalina shutdown hook protected class CatalinaShutdownHook extends Thread { public void run() { if (server != null) { try { ((Lifecycle) server).stop(); } catch (LifecycleException e) { System.out.println("Catalina.stop: " + e);
  e.printStackTrace(System.out); if (e.getThrowable() != null) { System.out.println("----- Root Cause -----"); e.getThrowable().printStackTrace(System.out); } } } } }
  该关闭钩子在Catalina实例启动的时候被初始化并添加到Runtime中。你可以在第17章学习到更多的细节 总结 有时候我们需要应用程序在关闭前进行一些清理工作。但是我们并不能保证用户总是正确的推出，本章描述的关闭钩子的方法提供了一种方法来保证清理工作的执行，无论用户是怎么停止应用程序的。
  第17章： Tomcat 启动
  综述
  本章的关注重点是Tomcat如何使用org.apache.catalina.startup下面的Catalina类和Bootstrap类来启动的。Catalina类用来启动和停止一个服务器对象并且解析Tomcat配置文件，即server.xml。Bootstrap类创建一个Catalina的实例并调用它的process方法。理论上，这两个类可以合成一个类。但是，为了支持Tomcat的多模式启动，提供了多个引导类。例如前述的Bootstrap类是将Tomcat作为一个独立的程序运行，而org.apache.catalina.startup.BootstrapService则是将Tomcat作为一个Windows NT系统的服务来运行。 为了使用方便，Tomcat允许使用批处理文件以及Shell脚本来启动和停止servlet容器。有了这些批处理文件和Shell脚本的帮助，用户不需要记住java.exe的选项来运行Bootstrap类，简单的运行批处理文件或者Shell脚本即可。 本章的第一节讨论Catalina类，第二节讨论Bootstrap类。要理解本章的内容，首先要确保您已经读过14、15、16章的内容。本章还讨论了如何在Windows以及Unix/Linux下面运行Tomcat。一节介绍Windows环境下的批处理文件，一节介绍Unix/Linux下面的Shell脚本。
  Catalina类
  org.apache.catalina.startup.Catalina是Tomcat的启动类。它包含一个用于解析%CATALINE_HOME%/conf目录下面server.xml文件的Digester。理解了如何往该Digester添加规则，你可以根据你的想法来配置该Tomcat。 Catalina类还封装了一个Server对象用来提供服务，如弟15章所介绍的那样。一个服务对象（Service）包括一个容器以及一个或多个连接器。可以使用Catalina来启动或停止Server对象。 可以首先初始化一个Catalina对象并调用它的process方法来启动Tomcat，在调用该方法的时候必须传递合适的参数。第一个参数用来确定你是否需要用关闭命令来关闭Tomcat。还有一些其它的参数，如-help, -config, -debug，-nonaming。
  注意
  Nonaming参数出现的时候，说明不支持JNDI命名空间。更多的Tomcat对于JNDI命名空间的支持请看org.apache.naming包。
  正常情况下，需要Bootstrap类来初始化Catalina对象并调用它的process方法，即使Catalina有自己的main方法。在下一节里将会介绍一个Bootstrap类，本节也会对它是如何工作的介绍。 Tomcat4中的process方法如Listing17.1所示
  Listing 17.1: The process method of the Catalina class public void process(String args[]) {
  setCatalinaHome(); setCatalinaBase(); try { if (arguments(args)) execute(); } catch (Exception e) { e.printStackTrace(System.out); } }
  该方法设置两个系统属性catalina.home和catalina.base.catalina.home，默认值是user.dir属性的值。Catalina.base被设置为catalina.home的值。因此这两个属性的值都跟user.dir属性值相同。
  注意
  User.dir系统属性是指当前用户工作空间，即运行Java命令的目录。可以在J2SE的API查看java.lang.System定义的系统属性列表。
  然后process方法调用了arguments方法（如Listing17.2），将参数列表传递给该方法。该方法处理参数列表，如果Catalina对象能继续工作返回true。
  Listing 17.2: The arguments method protected boolean arguments(String args[]) { boolean isConfig = false; if (args.length < 1) { usage(); return (false); } for (int i = 0; i < args.length; i++) { if (isConfig) { configFile = args[i]; isConfig = false; } else if (args[i].equals("-config")) { isConfig = true; } else if (args[i].equals("-debug")) { debug = true; } else if (args[i].equals("-nonaming")) { useNaming = false; } else if (args[i].equals("-help")) { usage(); return (false);
  } else if (args[i].equals("start")) { starting = true; } else if (args[i].equals("stop")) { stopping = true; } else { usage(); return (false); } } return (true); }
  Process方法检查arguments方法的返回值，如果为true就调用execute方法。该方法如Listing17.3所示：
  Listing 17.3: The execute method protected void execute() throws Exception { if (starting) start(); else if (stopping) stop(); }
  方法execute用于调用start方法或者stop方法来启动或者停止Tomcat。这两个方法将在下面的子节中介绍。
  注意
  在Tomcat5中，没有execute方法，process方法直接调用start方法和stop方法
  start方法
  起始方法创建一个Digester实例来处理server.xml文件（Tomcat的配置文件）。在解析XML文件之前，start方法调用的Digester的push方法，传递当前的Catalina对象。这将导致Catalina对象称为在Digester的内部堆栈第一个对象。解析文件可以设置服务器对象的变量，服务器默认情况下是类型org.apache.catalina.core.StandardServer。然后 start方法调用initialize方法，并调用服务器对象的start方法。然后Catalina的start方法再调用await方法，服务器分配一个线程等待关机命令。该方法不返回，直到收到关机命令。当await方法返回，在Catalina中的start方法调用的服务器对象的stop方法用于停止服务器以及所有组件。Start方法也采用了关闭钩子的方法确保在服务器对象的stop方法总是执行，即使用户突然退出该应用程序。
  Start方法如Listing17.4所示
  Listing 17.4: The start method protected void start() {
  // Create and execute our Digester Digester digester = createStartDigester(); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { System.out.println("Catalina.start: " + e); e.printstackTrace(System.out); System.exit(1); } // Setting additional variables if (!useNaming) { System.setProperty("catalina.useNaming", "false"); } else { System.setProperty("catalina.useNaming", "true"); String value = "org.apache.naming"; String oldValue = System.getProperty(javax.naming.Context.URL_PKG_PREFIXES); if (oldValue != null) { value = value + ":" + oldValue; } System.setProperty(javax.naming.Context.URL_PKG_PREFIXES, value); value = System.getProperty (javax.naming.Context.INITIAL_CONTEXT_FACTORY); if (value == null) { System.setProperty (javax.naming.Context.INITIAL_CONTEXT_FACTORY, "org.apache.naming.java.javaURLContextFactory"); } }
  // If a SecurityManager is being used, set properties for // checkPackageAccess() and checkPackageDefinition if( System.getSecurityManager() != null ) { String access = Security.getProperty("package.access"); if( access != null && access.length() > 0 ) access += ","; else access = "sun.,"; Security.setProperty("package.access", access + "org.apache.catalina.,org.apache.jasper."); String definition = Security.getProperty("package.definition"); if( definition != null && definition.length() > 0 ) definition += ","; else definition = "sun.,"; Security.setProperty("package.definition",
  // FIX ME package "javax." was removed to prevent HotSpot // fatal internal errors definition + "java.,org.apache.catalina.,org.apache.jasper."); } // Replace System.out and System.err with a custom PrintStream SystemLogHandler log = new SystemLogHandler(System.out); System.setOut(log); System.setErr(log); Thread shutdownHook = new CatalinaShutdownHook(); // Start the new server if (server instanceof Lifecycle) { try { server.initialize(); ((Lifecycle) server).start(); try { // Register shutdown hook Runtime.getRuntime().addShutdownHook(shutdownHook); } catch (Throwable t) { // This will fail on JDK 1.2. Ignoring, as Tomcat can run // fine without the shutdown hook. } // Wait for the server to be told to shut down server.await();
  } catch (LifecycleException e) { System.out.println("Catalina.start: " + e); e.printStackTrace(System.out); if (e.getThrowable() != null) { System.out.println("----- Root Cause -----"); e.getThrowable().printStackTrace(System.out); } } } // Shut down the server if (server instanceof Lifecycle) { try { try { // Remove the ShutdownHook first so that server.stop() // doesn't get invoked twice Runtime.getRuntime().removeShutdownHook(shutdownHook); } catch (Throwable t) { // This will fail on JDK 1.2. Ignoring, as Tomcat can run // fine without the shutdown hook. } ((Lifecycle) server).stop(); } catch (LifecycleException e) { System.out.println("Catalina.stop: " + e); e.printStackTrace(System.out); if (e.getThrowable() != null) {
  System.out.println("----- Root Cause -----"); e.getThrowable().printStackTrace(System.out); } } } }
  stop方法
  Stop方法用于关闭Catalina并且关闭Server对象。Stop方法如Listing17.5所示
  Listing 17.5: The stop Method
  protected void stop() { // Create and execute our Digester Digester digester = createStopDigester(); File file = configFile(); try { InputSource is = new InputSource("file://" + file.getAbsolutePath()); FileInputStream fis = new FileInputStream(file); is.setByteStream(fis); digester.push(this); digester.parse(is); fis.close(); } catch (Exception e) { System.out.println("Catalina.stop: " + e); e.printStackTrace(System.out); System.exit(1); } // Stop the existing server try { Socket socket = new Socket("127.0.0.1", server.getPort()); OutputStream stream = socket.getoutputStream(); String shutdown = server.getShutdown(); for (int i = 0; i < shutdown.length(); i++) stream.write(shutdown.charAt(i)); stream.flush(); stream.close(); socket.close(); } catch (IOException e) { System.out.println("Catalina.stop: " + e); e.printStackTrace(System.out); System.exit(1); } }
  注意stop方法通过createStopDigester方法创建了一个Digester实例。把当前Catalina对象压入到Digester内部栈中，并解析其配置文件，Digester的规则添加将在下一小节中介绍。 在收到关闭命令后，stop方法停止服务器对象。
  开始Digester
  Catalina的createStartDigester用于创建Digester实例然后向其添加规则来解析server.xml。该文件用于Tomcat配置，位于%CATALINE_HOME%/conf目录下面。向Digester添加的规则是理解Tomcat配置的关键。 createStartDigester方法如Listing17.6所示
  Listing 17.6: The createStartDigester method protected Digester createStartDigester() { // Initialize the digester Digester digester = new Digester(); if (debug) digester.setDebug(999); digester.setValidating(false); // Configure the actions we will be using digester.addObjectCreate("Server", "org.apache.catalina.core.StandardServer", "className"); digester.addSetProperties("Server"); digester.addSetNext("Server", "setServer", "org.apache.catalina.Server"); digester.addObjectCreate("Server/GlobalNamingResources", "org.apache.catalina.deploy.NamingResources"); digester.addSetProperties("Server/GlobalNamingResources"); digester.addSetNext("Server/GlobalNamingResources", "setGlobalNamingResources", "org.apache.catalina.deploy.NamingResources"); digester.addObjectCreate("Server/Listener", null, "className"); digester.addSetProperties("Server/Listener"); digester.addSetNext("Server/Listener", "addLifecycleListener", "org.apache.catalina.LifecycleListener"); digester.addObjectCreate("Server/Service",
  "org.apache.catalina.core.StandardService", "className"); digester.addSetProperties("Server/Service"); digester.addSetNext("Server/Service", "addService", "org.apache.catalina.Service"); digester.addObjectCreate("Server/Service/Listener", null, "className"); digester.addSetProperties("Server/Service/Listener"); digester.addSetNext("Server/Service/Listener",
  "addLifecycleListener", "org.apache.catalina.LifecycleListener"); digester.addObjectCreate("Server/Service/Connector", "org.apache.catalina.connector.http.HttpConnector", "className"); digester.addSetProperties("Server/Service/Connector"); digester.addSetNext("Server/Service/Connector", "addConnector", "org.apache.catalina.Connector"); digester.addObjectCreate("Server/Service/Connector/Factory", "org.apache.catalina.net.DefaultServerSocketFactory", "className"); digester.addSetProperties("Server/Service/Connector/Factory"); digester.addSetNext("Server/Service/Connector/Factory", "setFactory", "org.apache.catalina.net.ServerSocketFactory"); digester.addObjectCreate("Server/Service/Connector/Listener", null, "className"); digester.addSetProperties("Server/Service/Connector/Listener"); digester.addSetNext("Server/Service/Connector/Listener", "addLifecycleListener", "org.apache.catalina.LifecycleListener"); // Add RuleSets for nested elements digester.addRuleSet( new NamingRuleSet("Server/GlobalNamingResources/")); digester.addRuleSet(new EngineRuleSet("Server/Service/")); digester.addRuleSet(new HostRuleSet("Server/Service/Engine/")); digester.addRuleSet(new ContextRuleSet("Server/Service/Engine/Default")); digester.addRuleSet( new NamingRuleSet("Server/Service/Engine/DefaultContext/")); digester.addRuleSet( new ContextRuleSet("Server/Service/Engine/Host/Default")); digester.addRuleSet( new NamingRuleSet("Server/Service/Engine/Host/DefaultContext/")); digester.addRuleSet( new ContextRuleSet("Server/Service/Engine/Host/")); digester.addRuleSet( new NamingRuleSet("Server/Service/Engine/Host/Context/")); digester.addRule("Server/Service/Engine", new SetParentClassLoaderRule(digester, parentClassLoader)); return (digester);
  }
  createStartDigester方法创建一个org.apache.commons.digester.Digester类的实例，然后添加规则。
  在server.xml中的前三个规则是针对server元素的，server元素是根元素，这里是server模式的规则。 digester.addObjectCreate("Server", "org.apache.catalina.core.StandardServer", "className"); digester.addSetProperties("Server"); digester.addSetNext("Server", "setServer", "org.apache.catalina.Server"); 在遇到server元素的时候，Digester要创建org.apache.catalina.core.StandardServer的实例。一种例外是server元素有一个className属性，它表示要初始化的类。 第二条规则适用属性的值填充server对象对应属性的值。 第三条规则将Server对象压入堆栈并将其与下一个对象（Catalina对象）相关联，使用的方法是setServer方法。是怎样将一个Catalina的对象放入Digester的栈中的？在start方法中调用Digester的push方法来解析server.xml文档： digester.push (this); 上面的代码将Catalina对象压入Digester的内部栈中 其余的规则可以根据方法中的代码得出，如果有困难，请重读15章。
  停止Digester
  createStopDigester方法返回一个Digester对象用于优雅的停止服务器对象，该方法如Listing17.7
  Listing 17.7: The stop method protected Digester createStopDigester() { // Initialize the digester Digester digester = new Digester(); if (debug) digester.setDebug(999); // Configure the rules we need for shutting down
  digester.addObjectCreate("Server", "org.apache.catalina.core.StandardServer", "className"); digester.addSetProperties("Server"); digester.addSetNext("Server", "setServer", "org.apache.catalina.Server"); return (digester);
  }
  跟开始Digester不同，停止Digester仅仅对根元素感兴趣。 Bootstrap类 org.apache.catalina.startup.Bootstrap类提供了Tomcat的启动入口。当你运行startup.bat或者是startup.sh的时候，实际上运行的就是该类中的主方法。主方法创建三个类加载器并初始化Catalina类，然后调用Catalina的process方法。 Bootstrap类如Listing17.8所示：
  Listing 17.8: The Bootstrap class package org.apache.catalina.startup; import java.io.File; import java.lang.reflect.Method; /** * Boostrap loader for Catalina. This application constructs a * class loader for use in loading the Catalina internal classes * (by accumulating all of the JAR files found in the "server" * directory under "catalina.home"), and starts the regular execution * of the container. The purpose of this roundabout approach is to * keep the Catalina internal classes (and any other classes they * depend on, such as an XML parser) out of the system * class path and therefore not visible to application level classes. * * @author Craig R. McClanahan * @version $Revision: 1.36 $ $Date: 2002/04/01 19:51:31 $ */ public final class Bootstrap { /** * Debugging detail level for processing the startup. */ private static int debug = 0; /** * The main program for the bootstrap. * * @param args Command line arguments to be processed */
  public static void main(String args[]) { // Set the debug flag appropriately
  for (int i = 0; i < args.length; i++) { if ("-debug".equals(args[i])) debug = 1; } // Configure catalina.base from catalina.home if not yet set if (System.getProperty("catalina.base") == null) System.setProperty("catalina.base", getCatalinaHome()); // Construct the class loaders we will need ClassLoader commonLoader = null; ClassLoader catalinaLoader = null; ClassLoader sharedLoader = null; try { File unpacked[] = new File[1]; File packed[] = new File[1]; File packed2[] = new File[2]; ClassLoaderFactory.setDebug(debug); unpacked[0] = new File(getCatalinaHome(), "common" + File.separator + "classes"); packed2[0] = new File(getCatalinaHome(), "common" + File.separator + "endorsed"); packed2[l] = new File(getCatalinaHome(), "common" + File.separator + "lib"); commonLoader = ClassLoaderFactory.createClassLoader(unpacked, packed2, null); unpacked[0] = new File(getCatalinaHome(), "server" + File.separator + "classes"); packed[0] = new File(getCatalinaHome(), "server" + File.separator + "lib"); catalinaLoader = ClassLoaderFactory.createClassLoader(unpacked, packed, commonLoader); unpacked[0] = new File(getCatalinaBase(), "shared" + File.separator + "classes"); packed[0] = new File(getCatalinaBase(), "shared" + File.separator + "lib"); sharedLoader = ClassLoaderFactory.createClassLoader(unpacked, packed, commonLoader); }
  catch (Throwable t) { log('Class loader creation threw exception", t); System.exit(1); } Thread.currentThread().setContextClassLoader(catalinaLoader); // Load our startup class and call its process() method try {
  SecurityClassLoad.securityClassLoad(catalinaLoader); // Instantiate a startup class instance if (debug >= 1) log("Loading startup class"); Class startupClass = catalinaLoader.loadClass ("org.apache.catalina.startup.Catalina"); Object startupInstance = startupClass.newInstance(); // Set the shared extensions class loader if (debug >= 1) log("Setting startup class properties"); String methodName = "setParentClassLoader"; Class paramTypes[] = new Class[1]; paramTypes[0] = Class.forName("java.lang.ClassLoader"); Object paramValues[] = new Object[1]; paramValues[0] = sharedLoader; Method method = startupInstance.getClass().getMethod(methodName, paramTypes); method.invoke(startupInstance, paramValues); // Call the process() method if (debug >= 1) log("Calling startup class process() method"); methodName = "process"; paramTypes = new Class[1]; paramTypes[0] = args.getClass(); paramValues = new Object[l]; paramValues[0] = args; method = startupInstance.getClass().getMethod(methodName, paramTypes); method.invoke(startupInstance, paramValues); } catch (Exception e) {
  System.out.println("Exception during startup processing"); e.printStackTrace(System.out); System.exit(2); } } /** * Get the value of the catalina.home environment variable. */ private static String getCatalinaHome() { return System.getProperty("catalina.home", System.getProperty("user.dir")); } /** * Get the value of the catalina.base environment variable. */ private static String getCatalinaBase() { return System.getProperty("catalina.base", getCatalinaHome()); } /**

* Log a debugging detail message. * * @param message The message to be logged */ private static void log(String message) { System.out.print("Bootstrap: "); System.out.println(message); } /** * Log a debugging detail message with an exception. * * @param message The message to be logged * @param exception The exception to be logged */ private static void log(String message, Throwable exception) { log(message); exception.printStackTrace(System.out); } }
  Bootstrap类有四个静态方法：两个log方法、getCatalinaHome以及getCatalinaBase方法。getCatalinaHome方法的实现如下： return System.getProperty("catalina.home", System.getProperty("user.dir")); 它意味着如果在前面没有提供catalina.home的值，它会使用user.dir的值。 getCatalinaBase方法的实现如下： return System.getProperty("catalina.base", getCatalinaHome()); 它返回catalina.base的值，如果该值不存在返回catalina.home的值。 getCatalinaHome和getCatalinaBase都会被Bootstrap类的主方法调用。 Bootstrap类的主方法还构造了三个加载器用于不同的目的。使用不同加载器的主要原因是防止WEB-INF/classes以及WEB-INF/lib下面的类。%CATALINE_HOME%/common/lib目录下的jar包也可以访问。 这三个类加载器如下定义： // Construct the class loaders we will need
  ClassLoader commonLoader = null; ClassLoader catalinaLoader = null; ClassLoader sharedLoader = null; 每一个类加载器都给定一个可以访问的路径。commonLoader可以访问如下目录的类：%CATALINA_HOME%/common/classes，%CATALINA_HOME%/common/endorsed和 %CATALINA_HOME%/common/lib。 try { File unpacked[] = new File[1]; File packed[] = new File[1]; File packed2[] = new File[2]; ClassLoaderFactory.setDebug(debug); unpacked[0] = new File(getCatalinaHome(), "common" + File.separator + "classes"); packed2[0] = new File(getCatalinaHome(), "common" + File.separator + "endorsed"); packed2[1] = new File(getCatalinaHome(), "common" + File.separator + "lib"); commonLoader = ClassLoaderFactory.createClassLoader(unpacked, packed2, null); catalinaLoader负责加载Catalina容器要求的类，它可以加载%CATALINA_HOME%/server/classes和%CATALINA_HOME%/server/lib目录下面的类。 unpacked[0] = new File(getCatalinaHome(), "server" + File.separator + "classes");
  packed[0] = new File(getCatalinaHome(), "server" + File.separator + "lib"); catalinaLoader = ClassLoaderFactory.createClassLoader(unpacked, packed, commonLoader); sharedLoader可以访问%CATALINA_HOME%/shared/classes和%CATALJNA_HOME%/shared/lib目录下的类以及commondLoader类可以访问的类。sharedLoader是该Tomcat容器相关联的所有web应用的类加载器的父类加载器。 unpacked[0] = new File(getCatalinaBase(), "shared" + File.separator + "classes"); packed[0] = new File(getCatalinaBase(), "shared" + File.separator + "lib"); sharedLoader =
  ClassLoaderFactory.createClassLoader(unpacked, packed, commonLoader); } catch (Throwable t) { log('Class loader creation threw exception", t); System.exit(1); } 注意一点是sharedLoader加载器不能加载Catalina的内部类加载器以及环境变量下面的CLASSPATH下面的类，可以在第八章看到更多的加载器工作原理。 创建完三个类加载器后，主方法加载了Catalina类然后创建它的实例并将其赋值给startupInstance变量。 Class startupClass = catalinaLoader.loadClass ("org.apache.catalina.startup.Catalina"); Object startupInstance = startupClass.newInstance(); 然后调用setParentClassLoader方法，将sharedLoader作为参数： // Set the shared extensions class loader if (debug >= 1) log("Setting startup class properties"); String methodName = "setParentClassLoader"; Class paramTypes[] = new Class[1]; paramTypes[0] = Class.forName("java.lang.ClassLoader"); Object paramValues[] = new Object[1]; paramValues[0] = sharedLoader; Method method = startupInstance.getClass().getMethod(methodName, paramTypes); method.invoke(startupInstance, paramValues);
  最后，主方法调用Catalina对象的process方法： // Call the process() method if (debug >= 1) log("Calling startup class process() method"); methodName = "process"; paramTypes = new Class[1]; paramTypes[0] = args.getClass(); paramValues = new Object[1]; paramValues[0] = args; method = startupInstance.getClass().getMethod(methodName, paramTypes); method.invoke(startupInstance, paramValues);
  Windows环境下运行Tomcat
  如在前面的小节中介绍的，可以使用Bootstrap类将Tomcat作为一个独立程序运行。在Windows环境下面，可以使用starup.bat批处理启动Tomcat以及shutdown.bat批处理文件停止Tomcat。这两个批处理文件都能在%CATALINA_HOME%/bin目录下找到。本节主要讨论批处理文件，对于不熟悉DOS命令的可以使用批处理，首先是一个小的子节：Introduction to Writing Batch Files
  批处理文件简介
  本节主要介绍批处理文件，这样就能理解用于启动和停止Tomcat的批处理文件。特殊的，它解释了如下命令：rem, if, echo, goto, label等。它并没有全面的覆盖该问题，如果需要更多的内容可以查阅其它资源。 首先一个批处理文件必须是扩展名为.bat。可以在双击启动它也可以在命令行中调用他。一旦被调用，会从头至尾一行行的执行。在Tomcat的批处理文件中用到的元素会在下面介绍到。
  注意
  注意DOS命令和环境变量不区分大小写
  rem
  命令rem用作注释，rem开头的行会被忽略不做处理。
  pause
  命令pause命令停止批处理文件处理并要求用户按键，用户按键后会继续执行处理过程。
  echo
  该命令将它后面的文本显示到DOS控制台上面。例如，下面的语句打印Hello World到控制台上并暂停。需要pause命令的原因是这样才能看到控制台上显示的信息。 echo Hello World pause 要打印出一个环境变量的值，需要使用%将该变量括起来。例如，下面的命令打印出myVar的值 echo %myVar%. 要打印出操作系统的名字，可以使用如下命令： cho %OS%
  echo off
  echo off防止批处理文件中的命令被显示，只显示执行结果。但是echo off命令仍然会显示，要禁止echo off命令可以使用@echo off
  @echo off
  @echo off is similar to echo off, but it also suppresses the echo off command itself. @echo off跟echo off相似，但是它也禁止echo off命令本身
  set
  该命令用于设置用户定义的或者环境变量。设置的环境变量的值临时存放在内存中，在处理完成后被抛弃。 例如，下面的命令创建一个名为THE_KING的环境变量，值为Elvis并将其显示在控制台上。 set THE_KING=Elvis echo %THE_KING% pause
  注意
  要引用变量的值，使用%符号将变量名括起来。例如，echo %the_king%表示显示THE_KING的值
  label
  使用冒号来表示一个标签，你可以将标签传递给goto命令，让处理过程跳到该标签处。下面是一个名为end的标签 :end 接下来看一个goto命令
  goto
  命令goto强制批处理文件跳到标签定义的行，看下面的例子 echo Start goto end echo I can guarantee this line will not be executed :end echo End pause 在第一行打印出Start之后，批处理文件执行goto命令，这样控制器跳到end标签。第三行被跳过。
  if
  if用于测试，它有如下三种使用方式 1. To test the value of a variable. 2. To test the existence of a file 3. To test the error value. 4. 测试一个变量的值 5. 测试文件的存在性 6. 测试错误值 要测试一个变量的值，使用如下的格式 if variable==value nextCommand 例如，如下的语句测试myVar的值是不是3。如果是打印出correct到控制台上。 set myVar=3 if %myVar%==3 echo Correct 运行上面的命令会测试myVar的值并打印出Correct。
  要测试一个文件是否存在，可以使用如下格式： if exist c:\temp\myFile.txt goto start
  如果在c:\temp目录中存在myFile.txt文件，控制器会跳到start标签。 也可以使用not关键字来对一个表达式取反。
  not
  关键字not用于对一个表达式取反，例如，如下命令在myVar的值不等于3的时候打印出Correct。 set myVar=3 if not %myVar%==3 echo Correct pause 如下命令在c:\temp目录中不存在myFile.txt文件的时候跳到end标签。 if not exist c:\temp\myFile.txt goto end
  exist
  关键字exist跟if语句连接用于测试一个文件是否存在，残酷if语句的例子。
  Accepting Parameters接受参数
  可以给批处理文件传递参数，可以使用%1引用第一个参数，%2引用第二个参数。依次类推。 例如，如下命令打印第一个参数到控制台上： echo %1 如果批处理文件的名字为test.bat，可以使用test Hello命令来调用它，这样就会在控制台上显示Hello。 下面的批处理文件检查第一个参数，如果是start，就打印出Starting application。如果是stop就打印出Stopping application。其它情况打印出Invalid parameter。 echo off if %1==start goto start
  if %1==stop goto stop goto invalid :start echo Starting application goto end :stop
  echo Stopping application goto end :invalid
  echo Invalid parameter :end 可以“%1”于空字符串比较来检查批处理文件是否有第一个参数，如果没有参数打印出No parameter。
  if "%1"=="" echo No parameter The above is the same as 上面的语句跟下面的相同 if ""%1""=="""" echo No parameter
  shift
  命令shift向后移动参数，意味这%2指向%1，%3 指向%2，依次类推。例如下面的批处理文件使用了shift命令。 echo off shift echo %1 echo %2 如果运行该命令的时候传递3个参数a、b、c，会获得如下输出： b c 第一个参数 可以使用%0引用，最后一个参数丢失
  call
  命令call用于调用另一个命令
  setLocal
  可以使用setLocal命令来指明对于环境变量的改变全市本地的。环境变量的值会在执行完文件或碰到endLocal命令后恢复。
  start
  要打开一个新的窗口，可以使用start命令，可以传递个参数作为窗口的标题： start "Title" 另外，可以传递给该窗口要执行的命令，格式如下： start "Title" commandName
  The catalina.bat Batch File
  catalina.bat文件可以用于启动和停止Tomcat，而startup.bat和shutdown.bat更简单的启动和停止Tomcat。这两个批处理文件都是传递合适的参数给catalina.bat文件实现的。 必须在%CATALINA_HOME%下面的bin目录下面使用如下命令来调用catalina.bat。 catalina command 或者在%CATALINA_HOME%目录下使用如下命令 bin\catalina command 这两种情况下，可以传递的值如下： · debug. Start Catalina in a debugger · debug -security. Debug Catalina with a security manager · embedded. Start Catalina in embedded mode · jpda start. Start Catalina under JPDA debugger · run. Start Catalina in the current window · run -security. Start Catalina in the current window with a security manager · start. Start Catalina in a separate window
  · start -security. Start Catalina in a separate window with security manager · stop. Stop Catalina 例如，要在一个独立的窗口运行Catalina，可以使用如下命令： catalina start Catalina.bat如Listing17.9所示
  Listing 17.9: The catalina.bat File @echo off if "%OS%" == "Windows_NT" setlocal rem ------------------------------------------------------------------- -------- rem Start/Stop Script for the CATALINA Server rem
  rem Environment Variable Prequisites rem rem CATALINA_HOME May point at your Catalina "build" directory. rem rem CATALINA_BASE (Optional) Base directory for resolving dynamic portions rem of a Catalina installation. If not present, resolves to rem the same directory that CATALINA_HOME points to. rem rem CATALINA_OPTS (Optional) Java runtime options used when the "start", rem "stop", or "run" command is executed. rem rem CATALINA_TMPDIR (Optional) Directory path location of temporary directory rem the JVM should use (java.io.tmpdir). Defaults to rem %CATALINA_BASE%\temp. rem rem JAVA_HOME Must point at your Java Development Kit installation. rem rem JAVA_OPTS (Optional) Java runtime options used when the "start", rem "stop", or "run" command is executed. rem rem JSSE_HOME (Optional) May point at your Java Secure Sockets Extension rem (JSSE) installation, whose JAR files will be added to the rem system class path used to start Tomcat. rem rem JPDA_TRANSPORT (Optional) JPDA transport used when the "jpda start" rem command is executed. The default is "dt_shmem". rem
  rem JPDA_ADDRESS (Optional) Java runtime options used when the "jpda start" rem command is executed. The default is "jdbconn". rem rem $Id: catalina.bat,v 1.3 2002/08/04 18:19:43 patrickl Exp $ rem -------------------------------------------------------------------
  -------- rem Guess CATALINA_HOME if not defined if not "%CATALINA_HOME%" == "" goto gotHome set CATALINA_HOME=. if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome set CATALINA_HOME=.. :gotHome if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome echo The CATALINA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program goto end :okHome rem Get standard environment variables if exist "%CATALINA_HOME%\bin\setenv.bat" call "%CATALINA_HOME%\bin\setenv.bat" rem Get standard Java environment variables if exist "%CATALINA_HOME%\bin\setclasspath.bat" goto okSetclasspath echo Cannot find %CATALINA_HOME%\bin\setclasspath.bat echo This file is needed to run this program goto end :okSetclasspath set BASEDIR=%CATALINA_HOME% call "%CATALINA_HOME%\bin\setclasspath.bat" rem Add on extra jar files to CLASSPATH if "%JSSE_HOME%" == "" goto noJsse set CLASSPATH=%CLASSPATH%;%JSSE_HOME%\lib\jcert.jar;%JSSE_HOME%\lib\jnet.ja r;%JSSE_HOME%\lib\jsse.jar :noJsse set CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\bin\bootstrap.jar if not "%CATALINA_BASE%" == "" goto gotBase set CATALINA_BASE=%CATALINA_HOME% :gotBase if not "%CATALINA_TMPDIR%" == "" goto gotTmpdir set CATALINA_TMPDIR=%CATALINA_BASE%\temp :gotTmpdir
  rem ----- Execute The Requested Command ------------------------------- -------- echo Using CATALINA_BASE: %CATALINA_BASE% echo Using CATALINA_HOME: %CATALINA_HOME% echo Using CATALINA_TMPDIR: %CATALINA_TMPDIR% echo Using JAVA_HOME: %JAVA_HOME%
  set _EXECJAVA=%_RUNJAVA% set MAINCLASS=org.apache.catalina.startup.Bootstrap set ACTION=start set SECURITY_POLICY_FILE= set DEBOG_OPTS= set JPDA= if not ""%1"" == ""jpda"" goto noJpda set JPDA=jpda if not "%JPDA_TRANSPORT%" == "" goto gotJpdaTransport set JPDA_TRANSPORT=dt_shmem :gotJpdaTransport if not "%JPDA_ADDRESS%" == "" goto gotJpdaAddress set JPDA_ADDRESS=jdbconn :gotJpdaAddress shift :noJpda if ""%1"" == ""debug"" goto doDebug if ""%1"" == ""embedded"" goto doEmbedded if ""%1"" == ""run"" goto doRun if ""%1"" == ""start"" goto doStart if ""%1"" == ""stop"" goto doStop echo Usage: catalina ( commands ... ) echo commands: echo debug Start Catalina in a debugger echo debug -security Debug Catalina with a security manager echo embedded Start Catalina in embedded mode echo jpda start Start Catalina under JPDA debugger echo run Start Catalina in the current window echo run -security Start in the current window with security manager echo start Start Catalina in a separate window echo start -security Start in a separate window with security manager
  echo stop Stop Catalina goto end :doDebug shift set _EXECJAVA=%_RUNJDB% set DEBUG_OPTS=-sourcepath "%CATALINA_HOME%\..\..\jakarta-tomcat- 4.0\catalina\src\share" if not ""%1"" == ""-security"" goto execCmd shift echo Using Security Manager set SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy goto execCmd :doEmbedded shift set MAINCLASS=org.apache.catalina.startup.Embedded goto execCmd
  :doRun shift if not ""%1"" == ""-security"" goto execCmd shift echo Using Security Manager set SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy goto execCmd :doStart shift if not "%OS%" == "Windows_NT" goto noTitle set _EXECJAVA=start "Tomcat" %_RUNJAVA% goto gotTitle :noTitle set _EXECJAVA=start %_RUNJAVA% :gotTitle if not ""%1"" == ""-security"" goto execCmd shift echo Using Security Manager set SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy goto execCmd :doStop shift set ACTION=stop
  goto execCmd :execCmd rem Get remaining unshifted command line arguments and save them in the set CMD_LINE_ARGS= :setArgs if ""%1""=="""" goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs :doneSetArgs rem Execute Java with the applicable properties if not "%JPDA%" == "" goto dojpda if not "%SECURITY_POLICY_FILE%" == "" goto doSecurity %_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% - Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" - Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" - Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :doSecurity %_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% - Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" - Djava.security.manager -Djava.security.policy=="%SECURITY_POLICY_FILE%" -Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" - Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :doJpda if not "%SECURITY_POLICY_FILE%" == "" goto doSecurityJpda
  %_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% -Xdebug - Xrunjdwp:transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,sus pend=n %DEBUG_OPTS% -Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" - classpath "%CLASSPATH%" -Dcatalina.base="%CATALINA_BASE%" - Dcatalina.home="%CATALINA_HOME%" -Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :doSecurityJpda %_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% -
  Xrunjdwp:transport=%JPDA_TRANSPORT%,address=%JPDA_ADDRESS%,server=y,sus pend=n %DEBUG_OPTS% -Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" - classpath "%CLASSPATH%" -Djava.security.manager - Djava.security.policy=="%SECURITY_POLICY_FILE%" - Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" - Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION% goto end :end
  catalina.bat首先使用@echo off来避免打印出命令。然后检查OS的环境变量的值是否是Windows_NT。如果是调用setLocal来讲环境变量的改变都设置为本地的。 if "%OS%" == "Windows_NT" setlocal
  然后设置CATALINA_HOME的值，默认情况下该变量是不存在的。 如果该变量CATALINA_HOME变量不存在，批处理文件认为其为批处理文件所在的目录。首先它任务catalina.bat文件是运行在安装目录下面下面，即catalina.bat所在的bin目录。 if not "%CATALINA_HOME%" == "" goto gotHome set CATALINA_HOME=. if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome 如果catalina.bat在其bin子目录下面没有找到，就无法调用catalina.bat文件。然后批处理文件再猜一次，它查找CATALINA_HOME目录下面的bin子目录下面是否存在该文件。 set CATALINA_HOME=.. :gotHome if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome
  如果猜测正确，它掉到okHome。否则，打印出错误消息，告诉用户CATALINA_HOME设置错误并跳到end，end标签在该批处理文件末端。 echo The CATALINA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program goto end 如果CATALINA_HOME定义正确，批处理文件调用stenv.bat来设置要求的环境变量，如果setenv.bat文件存在。如果不存在，并不会触发错误信息。 :okHome rem Get standard environment variables if exist "%CATALINA_HOME%\bin\setenv.bat" call "%CATALINA_HOME%\bin\setenv.bat"
  接下来，它检查setclasspath.bat文件是否存在，如果找不到该文件，它显示错误信息并跳到该批处理文件的end来推出批处理文件。 if exist "%CATALINA_HOME%\bin\setclasspath.bat" goto okSetclasspath echo Cannot find %CATALINA_HOME%\bin\setclasspath.bat echo This file is needed to run this program goto end 如果找到setclaspath.bat文件，它设置BASEDIR变量的值为CATALINA_HOME然后调用调用setclasspath.bat文件来设置类路径。 :okSetclasspath set BASEDIR=%CATALINA_HOME% call "%CATALINA_HOME%\bin\setclasspath.bat" setclasspath.bat文件检查环境变量JAVA_HOME是否定义的正确然后使用catalina.bat的其它部分设置接下来的变量： set JAVA_ENDORSED_DIRS=%BASEDIR%\common\endorsed set CLASSPATH=%JAVA_HOME%\lib\tools.jar set _RUNJAVA="%JAVA_HOME%\bin\java" set _RUNJAVAW="%JAVA_HOME%\bin\javaw" set _RUNJDB="%JAVA_HOME%\bin\jdb" set _RUNJAVAC="%JAVA_HOME%\bin\javac" Catalina.bat文件检查是否安装了Java Secure Socket Extension以及JSSE_HOME的设置是否正确。如果找到了JSSE_HOME变量，将其添加到CLASSPATH变量。 if "%JSSE_HOME%" == "" goto noJsse set CLASSPATH=%CLASSPATH%;%JSSE_HOME%\lib\jcert.jar;%JSSE_HOME%\lib\jnet.ja r;%JSSE_HOME%\lib\jsse.jar
  如果找不到JSSE_HOME变量，批处理文件继续下一行的执行，它将bin目录下面的bootstrap.jar添加到CLASSPATH变量中 :noJsse set CLASSPATH=%CLASSPATH%;%CATALINA_HOME%\bin\bootstrap.jar 接下来catalina.bat文件检查CATALINA_BASE。如果CATALINA_BASE找不到，创建它并把CATALINA_HOME的值赋给它。 if not "%CATALINA_BASE%" == "" goto gotBase set CATALINA_BASE=%CATALINA_HOME% :gotBase 接下来，它检查CATALINA_TMPDIR的，它表示CATALINA_BASE下面的temporary目录。 if not "%CATALINA_TMPDIR%" == "" goto gotTmpdir set CATALINA_TMPDIR=%CATALINA_BASE%\temp
  :gotTmpdir 接下来，它显示几个变量的值： echo Using CATALINA_BASE: %CATALINA_BASE% echo Using CATALINA_HOME: %CATALINA_HOME% echo Using CATALINA_TMPDIR: %CATALINA_TMPDIR% echo Using JAVA_HOME: %JAVA_HOME% 然后它设置_EXECJAVA 的值为_RUNJAVA变量的值。_RUNCJAVA的值为%JAVA_HOME%\bin\java。换句话说，它指向JAVA_HOME目录下面bin子目录中的java.exe。 set _EXECJAVA=%_RUNJAVA% 然后设置接下来的变量 set MAINCLASS=org.apache.catalina.startup.Bootstrap set ACTION=start set SECURITY_POLICY_FILE= set DEBUG_OPTS= set JPDA= 然后catalina.bat文件检查传递给它的第一个参数是否是jpda，如果是将JPDA变量的值设置为jpda。然后检查JPDA_TRANSPORT和JPDA_ADDRESS变量，并移动参数。 if not ""%1"" == ""jpda"" goto noJpda set JPDA=jpda if not "%JPDA_TRANSPORT%" == "" goto gotJpdaTransport set JPDA_TRANSPORT=dt_shmem
  :gotJpdaTransport if not "%JPDA_ADDRESS%" == "" goto gotJpdaAddress set JPDA_ADDRESS=jdbconn :gotJpdaAddress shift 在大多数情况下并不会使用JPDA，因此第一个参数必须下面介个之一debug, embedded, run, start, 或stop :noJpda if ""%1"" == ""debug"" goto doDebug if ""%1"" == ""embedded"" goto doEmbedded if ""%1"" == ""run"" goto doRun if ""%1"" == ""start"" goto doStart if ""%1"" == ""stop"" goto doStop 如果第一个参数不正确或者没有参数，批处理文件显示使用说明 echo Usage: catalina ( commands ... ) echo commands:
  echo debug Start Catalina in a debugger echo debug -security Debug Catalina with a security manager echo embedded Start Catalina in embedded mode echo jpda start Start Catalina under JPDA debugger echo run Start Catalina in the current window echo run -security Start in the current window with security manager echo start Start Catalina in a separate window echo start -security Start in a separate window with security manager echo stop Stop Catalina goto end 如果第一个参数是start，它转到doStart标签，如果是stop，将控制权转到doStop标签。 在doStart标签之后，catalina.bat文件调用shift命令检查下一个参数，如果有必须为-security。否则它被忽略。下一个参数是-security，再次调用shift命令然后将SECURITY_POLICY_FILE变量值设置为%CATALINA_BASE%\conf\catalina.policy。 :doStart shift if not "%OS%" == "Windows_NT" goto noTitle set _EXECJAVA=start "Tomcat" %_RUNJAVA% goto gotTitle :noTitle set _EXECJAVA=start %_RUNJAVA% :gotTitle if not ""%1"" == ""-security"" goto execCmd shift
  echo Using Security Manager set SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy 在这一阶段，_EXECJAVA的值是下面值之一： start "Tomcat" "%JAVA_HOME%\bin\java" start "%JAVA_HOME%\bin\java" 然后跳到execCmd标签中： goto execCmd 在execCmd标签下面的命令获得未移动命令行参数并将其存储在CMD_LINE_ARGS并跳到doneSetArgs。 :execCmd set CMD_LINE_ARGS= :setArgs
  if ""%1""=="""" goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs 下面是doneSetArgs标签下的命令。 :doneSetArgs rem Execute Java with the applicable properties if not "%JPDA%" == "" goto doJpda if not "%SECURITY_POLICY_FILE%" == "" goto doSecurity %_EXECJAVA% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% - Djava.endorsed.dirs="%JAVA_ENDORSED_DIRS%" -classpath "%CLASSPATH%" - Dcatalina.base="%CATALINA_BASE%" -Dcatalina.home="%CATALINA_HOME%" - Djava.io.tmpdir="%CATALINA_TMPDIR%" %MAINCLASS% %CMD_LINE_ARGS% %ACTION% 例如在我的电脑上，可以使用如下命令来调用catalina start： start "Tomcat" "C:\j2sdk1.4.2_02\bin\java" - Djava.endorsed.dirs="..\common\endorsed" -classpath "C:\j2sdk1.4.2_02\lib\tools.jar;..\bin\bootstrap.jar" - Dcatalina.base=".." -Dcatalina,home=".." -Djava.io.tmpdir="..\temp" org.apache.catalina.startup.Bootstrap start 你应该明白使用不同的参数调用catalina.bat文件的时候命令是什么样子的。
  在Windows下启动Tomcat
  如Listing17.10所示的startup.bat文件提供了简单方法来调用catalina.bat文件，它传递参数start来调用catalina.bat。
  Listing 17.10: The startup.bat file @echo off if "%OS%" == "Windows_NT" setlocal rem ---------------------------------------------------------------- rem Start script for the CATALINA Server rem rem $Id: startup.bat,v 1.4 2002/08/04 18:19:43 patrickl Exp $ rem ---------------------------------------------------------------- rem Guess CATALINA_HOME if not defined if not "%CATALINA_HOME%" == "" goto gotHome set CATALINA_HOME=. if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome set CATALINA_HOME=.. :gotHome if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome
  echo The CATALINA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program goto end :okHome set EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat rem Check that target executable exists if exist "%EXECUTABLE%" goto okExec echo Cannot find %EXECUTABLE% echo This file is needed to run this program goto end :okExec rem Get remaining unshifted command line arguments and save them in the set CMD_LINE_ARGS= :setArgs if ""%1""=="""" goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs :doneSetArgs call "%EXECUTABLE%" start %CMD_LINE_ARGS% :end Stripping all rem and echo commands, you get the following: if "%OS%" == "Windows_NT" setlocal if not "%CATALINA_HOME%" == "" goto gotHome set CATALINA_HOME=. if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome set CATALINA_HOME=.. :gotHome
  if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome goto end :okHome set EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat if exist "%EXECUTABLE%" goto okExec goto end :okExec rem Get remaining unshifted command line arguments and save them in the set CMD_LINE_ARGS=
  :setArgs if ""%1""=="""" goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs :doneSetArgs call "%EXECUTABLE%" start %CMD_LINE_ARGS% :end
  Windows下面停止Tomcat
  Shutdown.bat文件提供了一种简单方式来运行catalina.bat，传递一个参数stop给它，该文件如Listing17.11所示
  Listing 17.11: The shutdown.bat file @echo off if "%OS%" == "Windows_NT" setlocal rem ------------------------------------------------------------------- -------- rem Stop script for the CATALINA Server rem rem $Id: shutdown.bat,v 1.3 2002/08/04 18:19:43 patrickl Exp $ rem ------------------------------------------------------------------- -------- rem Guess CATALINA_HOME if not defined if not "%CATALINA_HOME%" == "" goto gotHome set CATALINA_HOME=. if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome set CATALINA_HOME=.. :gotHome if exist "%CATALINA_HOME%\bin\catalina.bat" goto okHome echo The CATALINA_HOME environment variable is not defined correctly echo This environment variable is needed to run this program goto end :okHome set EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat
  rem Check that target executable exists if exist "%EXECUTABLE%" goto okExec
  echo Cannot find %EXECUTABLE% echo This file is needed to run this program goto end :okExec rem Get remaining unshifted command line arguments and save them in the set CMD_LINE_ARGS= :setArgs if ""%1""=="""" goto doneSetArgs set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1 shift goto setArgs :doneSetArgs call "%EXECUTABLE%" stop %CMD_LINE_ARGS% :end 在Unix/Linux下面运行Tomcat Tomcat自带了Shell脚本用来在Unix或者Linux下面启动或者停止自己。这些脚本文件扩展名为.sh，并且位于%CATALINA_HOME%目录下的子目录bin下面。本节将会介绍catalina.sh, startup.sh, shutdown.sh, 和setclasspath.sh这四个脚本文件。 本节首先介绍Shell脚本，对于Shell脚本不熟悉的读者可以仔细阅读一下。然后涉及的内容是catalina.sh、startip.sh以及shutdown.sh。setclasspath.sh会在catalina.sh中使用到因此它在介绍catalina.sh小节中会对其进行简单的介绍。
  本节对于Shell脚本的介绍仅限于让你能够读懂Tomcat的脚本，尤其是catalina.sh、startup.sh、shutdown.sh以及setclasspath.sh。并不会完全的介绍Shell脚本，需要的话读者可以查阅其它资料。 物理角度来看，Shell脚本是一个文本文件。可以使用vi或者其它文本编辑器编辑它。要确定该文件的许可模式，这样该文件可以被执行，使用的语法如下： $ chmod +x scriptName $ chmod 755 scriptName 这样将会给文件所有者设置读写执行权限，组以及其它的用户有该文件的执行权。
  接下来可以使用如下命令来执行脚本。 bash scriptName sh scriptName ./scriptName
  接下来是一些Shell脚本中常用的命令，足够你理解Tomcat的Shell脚本。
  comment
  使用#表示后面的文本被忽略，#出现在一行的最前面的话那么这行都是注释。 # This is a comment 它也可以出现在语句的中间，这样#右边的字符都是注释 echo Hello # print Hello
  clear
  使用clear命令来清除屏幕，例如下面的语句先清理屏幕，然后打印出一个字符串 clear echo Shell scripts are useful
  exit
  使用exit命令可以退出Shell脚本。退出的情况有以下几种状态，0表示成功退出，非0值表示非正常退出。因此当你遇到一个问题退出，可以使用如下命令。 exit 1
  echo
  使用echo命令可以在屏幕上打印出一个字符串，例如下面的命令在控制台上打印出Hello World。
  echo Hello World
  Calling A Function
  可以使用句号（.）来调用一个函数或者调用其他Shell脚本。例如，下面命令调用同一个目录下面的test.sh。 . ./test.sh
  System and User Defined Variables
  变量名必须是以数字字母或下划线开。使用等号来给变量设置值，例如，如下命令设置变量myVar值为Tooksie。 myVar=Tootsie
  注意在等号前后不能存在空白符，另外需要注意变量名是大小写敏感的。 可以设置变量的值为空字符串或者直接将右边留空可以将一个变量设置为NULL。 myVar= myVar="" 要访问一个变量的值，可以使用变量名前面加$来访问变量。例如，可以打印出变量myVar的值。 echo $myVar Unix/Linux系统提供了一些系统变量。例如HOME表示当前用户的home目录。PWD表示用户当前目录，PATH表示查找调用命令的路径，等等。
  警告
  在明白更改系统变量值会带来什么后果之前应该不要改变其值。
  expr
  使用expr表示一个表达式，一个表达式必须用引号将其括起来。下面是用Shell脚本来表示加法运算。
  sum=`expr 100 + 200` echo $sum 它创建一个名为sum的变量并将其赋值为300。运行该段脚本可以在控制台上打印出300. 下面是另一个例子： echo `expr 200 + 300` 它在屏幕上打印出如下内容： 500 特殊的`uname`表达式表示操作系统的名字。例如，如果你使用的是Linux，下面的命令将会打印出Linux在控制台上。 echo `uname` 特殊的`dirname filePath`返回文件的目录，例如`dirname /home/user1/test.sh` 返回 /home/user1
  Accessing Parameters
  跟给函数传递参数一样，一个可以传递参数给Shell脚本。可以使用$1来访问第一个参数$2表示第二个参数，依次类推。$#命令获得参数个数，$@命令获得所有参数。
  shift
  Shift命令将参数后移一位，$1获得$2的值，$2获得$1的值。
  if ... then ... [else ... ] fi
  If语句块用于测试一个条件并执行适当的命令，它的语法如下： if condition then list of commands [else list of commands ] fi
  注意
  可以使用elif代替else if
  例如下面的例子在获得一个start参数的时候打印出Starting the application，收到stop的时候打印出Stopping the application。 if [ "$1" = "start" ]; then echo Starting the application fi if [ "$1" = "stop" ]; then echo Stopping the application fi
  注意
  在条件中，在[后边必须有一个空格，而]之前必须有一个空格
  $1用双引号括起来的时候，如果没有参数传递给它不会差生异常， $0表示用于执行脚本的命令。例如，如果使用如下命令执行test.sh。 ./test.sh $0 will then contain ./test.sh. $0就表示./test.sh 下面的表示可选条件 · -f file, true is file exists · -r file, true if you have read access to file · -z string, true if string is empty. · -n string, true if string is not empty · string1 = string2, true if string1 equals string2. · string1 != string2, true if string1 is not equal to string2.
  for Loop
  For循环的语法如下 for { var } in {list} do list of commands done 例如： for i in 1 2 3 do echo iteration $i done
  打印出： iteration 1 iteration 2 iteration 3
  while Loop
  While循环的语法如下 while [ condition ] do list of commands done 例如 n=1 while [ $n -lt 3 ]; do echo iteration $n n=$((n + 1)) done 输出为 iteration 1 iteration 2 [ $n -lt 3]中的-lt表示less than。所以它表示n的值小于3.
  case
  Case运行你写一个选择性执行的程序，语法如下： case $variable-name in pattern1) list of commands ;; pattern2) list of commands ;; *) list of commands ;; esac ;;用于结束执行的命令，*)表示没有其它模式匹配的时候执行。
  例如下面的脚本检查操作系统的名字。如果你使用的不是cygwin, OS400 或Linux，将打印出Operating system not recogized。 case "`uname`" in CYGWIN*) echo cygwin;; OS400*) echo OS400;; Linux*) echo Linux;; *) echo Operating system not recognized esac
  Output Redirection
  使用>将输出定位到文件中，例如。可以使用如下命令 echo Hello > myFile.txt 该文件创建一个名为myFile.txt的文件并将Hello写入到其中。屏幕上不会有显示。 注意1>&2将stdout上的错误信息显示到stderr上而2>&1将stderr的输出显示到stdout上。
  Conditional Executions
  可以写命令或条件的形式来决定执行哪个命令。这时候使用&&和|| command1 && command2 如果command1返回一个0退出状态就执行command2。Command1也可以使用一个条件来代替。如果条件为真，command2将会执行，否则不执行command2。 command1 || command2
  如果command1的退出类型非0，则执行command2 command1 && command2 || command3 如果command1返回0退出状态，执行command2，否则执行command3
  The catalina.sh File
  Catalina.sh用于在Unix/Linux下面启动或停止Tomcat，启动的时候将start传递给catalina.sh，关闭的时候传递stop参数给它。下面是可用参数： · debug. Start Catalina in a debugger (not available on OS400) · debug -security. Debug Catalina with a security manager (not available on OS400) · embedded. Start Catalina in embedded mode · jpda start. Start Catalina under JPDA debugger · run. Start Catalina in the current window · run -security. Start in the current window with security manager · start. Start Catalina in a separate window · start -security. Start in a separate window with security manager · stop. Stop Catalina Catalina.sh文件如Listing17.12所示，基于前面已将的内容，你应该可以明白它的内容。

  Listing 17.12: The catalina.sh file #!/bin/sh # --------------------------------------------------------------------- -------- # Start/Stop Script for the CATALINA Server # # Environment Variable Prequisites # # CATALINA_HOME May point at your Catalina "build" directory. # # CATALINA_BASE (Optional) Base directory for resolving dynamic portions # of a Catalina installation. If not present, resolves to # the same directory that CATALINA_HOME points to.

# # CATALINA_OPTS (Optional) Java runtime options used when the "start", # "stop", or "run" command is executed. # # CATALINA_TMPDIR (Optional) Directory path location of temporary directory # the JVM should use (java.io.tmpdir). Defaults to # $CATALINA_BASE/temp. # # JAVA_HOME Must point at your Java Development Kit installation. #

# JAVA_OPTS (Optional) Java runtime options used when the "start", # "stop", or "run" command is executed. # # JPDA_TRANSPORT (Optional) JPDA transport used when the "jpda start" # command is executed. The default is "dt_socket". # # JPDA_ADDRESS (Optional) Java runtime options used when the "jpda start" # command is executed. The default is 8000. # # JSSE_HOME (Optional) May point at your Java Secure Sockets Extension # (JSSE) installation, whose JAR files will be added to the # system class path used to start Tomcat. # # CATALINA_PID (Optional) Path of the file which should contains the pid # of catalina startup Java process, when start (fork) is used # # $Id: catalina.sh,v 1.8 2003/09/02 12:23:13 remm Exp $ # --------------------------------------------------------------------- -------- # OS specific support. $var _must_ be set to either true or false. cygwin=false

os400=false case "`uname`" in CYGWIN*) cygwin=true;; OS400*) os400=true;; esac # resolve links - $0 may be a softlink PRG="$0" while [ -h "$PRG" ]; do ls=`ls -ld "$PRG"` link=`expr "$ls" : '.*-> \(.*\)$'` if expr "$link" : '.*/.*' > /dev/null; then PRG="$link" else PRG=`dirname "$PRG"`/"$link" fi done # Get standard environment variables PRGDIR=`dirname "$PRG"` CATALINA_HOME=`cd "$PRGDIR/.." ; pwd` if [ -r "$CATALINA_HOME"/bin/setenv.sh ]; then . "$CATALINA_HOME"/bin/setenv.sh fi

# For Cygwin, ensure paths are in UNIX format before anything is touched if $cygwin; then [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"` [ -n "$CATALINA_HOME" ] && CATALINA_HOME=`cygpath --unix "$CATALINA_HOME"` [ -n "$CATALINA_BASE" ] && CATALINA_BASE=`cygpath --unix "$CATALINA_BASE"` [ -n "$CLASSPATH" ] && CLASSPATH=`cygpath --path --unix "$CLASSPATH"` [ -n "$JSSE_HOME" ] && JSSE_HOME=`cygpath --path --unix "$JSSE_HOME"` fi # For OS400 if $os400; then # Set job priority to standard for interactive (interactive - 6) by using # the interactive priority - 6, the helper threads that respond to requests

# will be running at the same priority as interactive jobs. COMMAND='chgjob job('$JOBNAME') runpty(6)' system $COMMAND # Enable multi threading export QIBM_MULTI_THREADED=Y fi # Get standard Java environment variables if [ -r "$CATALINA_HOME"/bin/setclasspath.sh ]; then BASEDIR="$CATALINA_HOME" . "$CATALINA_HOME"/bin/setclasspath.sh else echo "Cannot find $CATALINA_HOME/bin/setclasspath.sh" echo "This file is needed to run this program" exit 1 fi # Add on extra jar files to CLASSPATH if [ -n "$JSSE_HOME" ]; then CLASSPATH="$CLASSPATH":"$JSSE_HOME"/lib/jcert.jar:"$JSSE_HOME"/lib/jnet .jar:"$JSSE_HOME"/lib/jsse.jar fi CLASSPATH="$CLASSPATH":"$CATALINA_HOME"/bin/bootstrap.jar if [ -z "$CATALINA_BASE" ] ; then CATALINA_BASE="$CATALINA_HOME" fi if [ -z "$CATALINA_TMPDIR" ] ; then # Define the java.io.tmpdir to use for Catalina CATALINA_TMPDIR="$CATALINA_BASE"/temp fi # For Cygwin, switch paths to Windows format before running java if $cygwin; then JAVA_HOME=`cygpath --path --windows "$JAVA_HOME"`

CATALINA_HOME=`cygpath --path --windows "$CATALINA_HOME"` CATALINA_BASE=`cygpath --path --windows "$CATALINA_BASE"` CATALINA_TMPDIR=`cygpath --path --windows "$CATALINA_TMPDIR"` CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
JSSE_HOME=`cygpath --path --windows "$JSSE_HOME"` fi # ----- Execute The Requested Command --------------------------------- -------- echo "Using CATALINA_BASE: $CATALINA_BASE" echo "Using CATALINA_HOME: $CATALINA_HOME" echo "Using CATALINA_TMPDIR: $CATALINA_TMPDIR" echo "Using JAVA_HOME: $JAVA_HOME" if [ "$1" = "jpda" ] ; then if [ -z "$JPDA_TRANSPORT" ]; then JPDA_TRANSPORT="dt_socket" fi if [ -z "$JPDA_ADDRESS" ]; then JPDA_ADDRESS="8000" fi if [ -z "$JPDA_OPTS" ]; then JPDA_OPTS="-Xdebug - Xrunjdwp:transport=$JPDA_TRANSPORT,address=$JPDA_ADDRESS,server=y,suspe nd=n" fi CATALINA_OPTS="$CATALINA_OPTS $JPDA_OPTS" shift fi if [ "$1" = "debug" ] ; then if $os400; then echo "Debug command not available on OS400" exit 1 else shift if [ "$1" = "-security" ] ; then echo "Using Security Manager" shift exec "$_RUNJDB" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \ -sourcepath "$CATALINA_HOME"/../../jakarta-tomcat- 4.0/catalina/src/share \ -Djava.security.manager \
-Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" start else exec "$_RUNJDB" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
-sourcepath "$CATALINA_HOME"/../../jakarta-tomcat- 4.0/catalina/src/share \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" start fi fi elif [ "$1" = "embedded" ] ; then shift echo "Embedded Classpath: $CLASSPATH" exec "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Embedded "$@" elif [ "$1" = "run" ]; then shift if [ "$1" = "-security" ] ; then echo "Using Security Manager" shift exec "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \ -Djava.security.manager \ -Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \ -Dcatalina.base="$CATALINA_BASE" \
-Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" start else exec "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" start fi elif [ "$1" = "start" ] ; then shift touch "$CATALINA_BASE"/logs/catalina.out if [ "$1" = "-security" ] ; then echo "Using Security Manager" shift "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
-Djava.security.manager \ -Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" start \ >> "$CATALINA_BASE"/logs/catalina.out 2>&1 & if [ ! -z "$CATALINA_PID" ]; then echo $! > $CATALINA_PID fi else "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" start \ >> "$CATALINA_BASE"/logs/catalina.out 2>&1 &
if [ ! -z "$CATALINA_PID" ]; then echo $! > $CATALINA_PID fi fi elif [ "$1" = "stop" ] ; then shift "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \ -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -clasapath "$CLASSPATH" \ -Dcatalina.base="$CATALINA_BASE" \ -Dcatalina.home="$CATALINA_HOME" \ -Djava.io.tmpdir="$CATALINA_TMPDIR" \ org.apache.catalina.startup.Bootstrap "$@" stop if [ "$1" = "-force" ] ; then shift if [ ! -z "$CATALINA_PID" ]; then echo "Killing: `cat $CATALINA_PID`" kill -9 `cat $CATALINA_PID` fi fi else echo "Usage: catalina.sh ( commands ... )" echo "commands:" if $os400; then echo " debug Start Catalina in a debugger (not available on OS400)" echo " debug -security Debug Catalina with a security manager (not available on OS400)" else echo " debug Start Catalina in a debugger"
echo " debug -security Debug Catalina with a security manager" fi echo " embedded Start Catalina in embedded mode" echo " jpda start Start Catalina under JPDA debugger" echo " run Start Catalina in the current window" echo " run -security Start in the current window with security manager"
echo " start Start Catalina in a separate window" echo " start -security Start in a separate window with security manager" echo " stop Stop Catalina" exit 1 fi
Starting Tomcat on Linux/Unix
简单起见，可以使用startup.sh来启动Tomcat，startup.sh设置了正确的环境变量调用catalina.sh。startup.sh如Listing17.13所示
Listing 17.13: The startup.sh file #!/bin/sh # ---------------------------------------------------------------------- -------- # Start Script for the CATALINA Server # # $Id: startup.sh,v 1.3 2002/08/04 18:19:43 patrickl Exp $ # --------------------------------------------------------------------- -------- # resolve links - $0 may be a softlink PRG="$0" while [ -h "$PRG" ] ; do ls=`ls -ld "$PRG"` link=`expr "$ls" : '.*-> \(.*\)$'` if expr "$link" : '.*/.*' > /dev/null; then PRG="$link" else PRG=`dirname "$PRG"`/"$link" fi done PRGDIR=`dirname "$PRG"` EXECUTABLE=catalina.sh # Check that target executable exists if [ ! -x "$PRGDIR"/"$EXECUTABLE" ]; then
echo "Cannot find $PRGDIR/$EXECUTABLE" echo "This file is needed to run this program" exit 1 fi
exec "$PRGDIR"/"$EXECUTABLE" start "$@"
Stopping Tomcat on Linux/Unix
可以使用shutdown.sh脚本来简单的关闭Tomcat，该脚本传递stop作为参数给catalina.sh。
Listing 17.14 presents shutdown.sh.
Listing 17.14: The shutdown.sh File #!/bin/sh # --------------------------------------------------------------------- # Stop script for the CATALINA Server # # $Id: shutdown.sh,v 1.3 2002/08/04 18:19:43 patrickl Exp $ # --------------------------------------------------------------------- # resolve links - $0 may be a softlink PRG="$0" while [ -h "$PRG" ] ; do ls=`ls -ld "$PRG"` link=`expr "$ls" : '.*-> \(.*\)$'` if expr "$link" : '.*/.*' > /dev/null; then PRG="$link" else PRG=`dirname "$PRG"`/"$link" fi done PRGDIR=`dirname "$PRG"` EXECUTABLE=catalina.sh # Check that target executable exists if [ ! -x "$PRGDIR"/"$EXECUTABLE" ]; then echo "Cannot find $PRGDIR/$EXECUTABLE" echo "This file is needed to run this program" exit 1 fi
exec "$PRGDIR"/"$EXECUTABLE" stop "S@" 总结 本章介绍了用于启动应用程序的两个类，Catalina和Bootstrap，它们都是org.apache.catalina.startup包下面的成员。另外还学习了批处理文件和Shell脚本来启动和停止Tomcat。
第18章：部署器
综述
要使得一个web应用可以访问，一个上下文必须先部署在主机上。在Tomcat中，一个上下文可以以WAR文件的形式部署，也可以直接将整个应用程序部署在Tomcat安装目录的wabapp目录下面。对你部署的每个应用，都可以有一个配置脚本用来配置该上下文，配置脚本以XML文档的形式存在。
注意
在Tomcat4和5中有两个已经部署好的应用：manager和admin。它们的类文件都在%CATALINA_HOME%/server/webapps目录下面。这两个都有配置脚本，分布式manager.xml和admin.xml。在Tomcat4中，配置脚本在%CATALINA_HOME%/webapps下面，而Tomcat5中，它们在相应的应用目录下面，即%CATALINA_HOME%/server/webapps/admin以及%CATALINA_HOME%/server/webapps/manager
本章介绍的内容是使用部署器来部署一个web应用，部署器用org.apache.catalina.Deployer接口表示。部署器跟主机相关联，用于安装子容器。往主机安装上下文意味着创建StandardContext类的实例并将其添加到主机（host）。当主机启动的时候，子上下文也启动（父容器的start方法总是启动子容器的start方法，包装器除外）。但是使用部署器可以独立开始和停止单独的上下文。
部署一个web上下文
在第15章中，使用如下代码初始化一个StandardHost并将上下文对象作为子容器添加到上面。 Context context = new StandardContext(); context.setPath("/app1"); context.setDocBase("app1"); LifecycleListener listener = new ContextConfig(); ((Lifecycle) context).addLifecycleListener(listener); Host host = new StandardHost(); host.addChild(context); 这是我们部署应用程序的方法，但是Tomcat中并没有这些代码。那么，在一个实际部署中，上下文是如何添加到主机的呢？答案StandardHost实例中org.apache.catalina.startup.HostConfig类型的生命周期监听器。 StandardHost实例的start方法启动的时候，它触发START事件。HostConfig的响应是它会调用它自己的start方法，它会部署和安装所有的特定目录下面的web应用程序。下面是具体的细节。
回忆第15章中的内容，它解释了如何使用Digester来解析一个XML文件。但是那章并没有讨论Digester对象的所有规则。它掠过的一个主题就是部署器，这也正是本章要介绍的内容。 org.apache.catalina.startup.Catalina是一个启动类，它使用一个Digester对象将server.xml文档中的XML元素转换为Java对象。Catalina类定义了createStartDigester方法用于往Digester对象添加规则。下面是该方法中的一行 digester.addRuleSet(new HostRuleSet("Server/Service/Engine/")); org.apache.catalina.startup.HostRuleSet类继承了org.apache.commons.digester.RuleSetBase类。作为一个RuleSetBase类的子类，HostRuleSet类提供了addRuleInstances方法的实现，该方法用于为RuleSet定义规则。下面是HostRuleSet类的addRuleInstances方法的一个片段 public void addRuleInstances(Digester digester) { digester.addObjectCreate(prefix + "Host",
"org.apache.catalina.core.StandardHost", "className"); digester.addSetProperties(prefix + "Host"); digester.addRule(prefix + "Host", new CopyParentClassLoaderRule(digester)); digester.addRule(prefix + "Host", new LifecycleListenerRule (digester, "org.apache.catalina.startup.HostConfig", "hostConfigClass")); 这段代码的意思是，当Server/Service/Engine/Host的模式的时候创建一个org.apache.catalina.startup.HostConfig类的对象，并将其作为一个生命周期监听器添加到主机上。换句话说，HostConfig处理StandardHost的start方法和stop方法触发的事件。 HostConfig类的lifecycleEvent方法如Listing18.1所示。该方法用于处理事件，因为HostConfig是StandardHost实例的监听器，每次调用StandardHost启动或停止的时候，都会触发lifecycleEvent方法。
Listing 18.1: The lifecycleEvent method of the HostConfig class. public void lifecycleEvent(LifecycleEvent event) { // Identify the host we are associated with try { host = (Host) event.getLifecycle(); if (host instanceof StandardHost) { int hostDebug = ((StandardHost) host).getDebug(); if (hostDebug > this.debug) { this.debug = hostDebug; } setDeployXML(((StandardHost) host).isDeployXML()); setLiveDeploy(((StandardHost) host).getLiveDeploy()); setUnpackWARs(((StandardHost) host).isUnpackWARs());
} } catch (ClassCastException e) { log(sm.getString("hostConfig.cce", event.getLifecycle()), e); return; } // Process the event that has occurred if (event.getType().equals(Lifecycle.START_EVENT)) start (); else if (event.getType().equals(Lifecycle.STOP_EVENT)) stop(); }
如果主机是org.apache.catalina.core.StandardHost的一个实例，将会调用setDeployXML，setLiveDeploy，setUnpackWARs方法。 setDeployXML(((StandardHost) host).isDeployXML()); setLiveDeploy(((StandardHost) host).getLiveDeploy());
setUnpackWARs(((StandardHost) host).isUnpackWARs()); StandardHost的isDeployXML方法标志该主机是否部署一个上下文部署文件。deployXML属性的默认值是true。liveDeploy属性的值标志是否需要周期性检查新部署，unpackWARs属性定义了是否需要解压来部署WAR文件。 根据接收到的START事件，HostConfig对象的lifecycleEvent方法调用start方法来部署应用程序，该方法如Listing18.2
Listing 18.2: The start method of the HostConfig class protected void start() { if (debug >= 1) log(sm.getString("hostConfig.start")); if (host.getAutoDeploy()) { deployApps(); } if (isLiveDeploy ()) { threadStart(); } }
如果autoDeploy属性为真，start方法调用deployApps方法。另外如果liveDeploy为真他还调用threadStart方法启动一个新线程。Live deploy将在“live deploy”一节介绍。
deployApps方法获得主机的appBase属性，appBase默认的有一个值为webapps。部署过程任务所有的位于%CATALINE_HOME%/webapps目录下面的子目录为一个应用程序。另外在该目录下面的WAR文件和描述文件会被部署。 deployApps方法如Listing18.3
Listing 18.3: The deployApps method protected void deployApps() { if (!(host instanceof Deployer)) return; if (debug >= 1) log(sm.getString("hostConfig.deploying")); File appBase = appBase(); if (!appBase.exists() || !appBase.isDirectory())
return; String files[] = appBase.list(); deployDescriptors(appBase, files); deployWARs(appBase, files); deployDirectories(appBase, files); }
deployApps方法调用了其它三个方法deployDescriptors, deployWARs, 和deployDirectories。所有的方法中，deployApps传递appBase文件以及webapps目录下的文件数组。一个上下文通过它的路径来鉴别，所有的上下文都有唯一的路径。部署的上下文被添加到HostConfig对象的deployed ArraList上面。因此在部署一个上下文的时候， deployDescriptors, deployWARs, 和deployDirectories要确定在deployed ArrayList上面不包含该路径。 接下来看着三个部署方法，看完下面的三个小节你应该能回答下面的问题：这三个方法的调用顺序重要没（答案当然是yes）
Deploying a Descriptor
可以通过编写一个XML文件来描述一个上下文对象。例如，在Tomcat4和5中的admin何manager应用有Listing18.4和Listing18.5部署文件
Listing 18.4: The descriptor for the admin application (admin.xml) <Context path="/admin" docBase="../server/webapps/admin" debug="0" privileged="true"> <!-- Uncomment this Valve to limit access to the Admin app to localhost for obvious security reasons. Allow may be a comma- separated list of hosts (or even regular expressions). <Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="127.0.0.1"/> -->
<Logger className="org.apache.catalina.logger.FileLogger" prefix="localhost_admin_log." suffix=".txt" timestamp="true"/> </Context>
Listing 18.5: The descriptor for the manager application (manager.xml) <Context path="/manager" docBase="../server/webapps/manager" debug="0" privileged="true"> <!-- Link to the user database we will get roles from --> <ResourceLink name="users" global="UserDatabase"
type="org.apache.catalina.UserDatabase"/> </Context>
注意这两个描述文件都有Context元素和docBase属性指向%CATALINA_HOME%/server/webapps/admin 和%CATALINA_HOME%/server/webapps/manager，这说明admin和manager应用没有部署在普通地点。 HostConfig类使用如Listing18.6所示的deployDecriptors方法来部署所有的%CATALINA_HOME%/webapps 下面（Tomcat4）或者%CATALINA_HOME%/server/webapps/ （Tomcat5）下面的XML文件。
Listing 18.6: The deployDescriptors method in HostConfig protected void deployDescriptors(File appBase, String[] files) { if (!deployXML) return; for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; if (deployed.contains(files[i])) continue; File dir = new File(appBase, files[i]); if (files[i].toLowerCase().endsWith(".xml")) { deployed.add(files[i]); // Calculate the context path and make sure it is unique String file = files[i].substring(0, files[i].length() - 4); String contextPath = "/" + file; if (file.equals("ROOT")) { contextPath = ""; } if (host.findChild(contextPath) != null) {
continue; } // Assume this is a configuration descriptor and deploy it log(sm.getString("hostConfig.deployDescriptor", files[i])); try { URL config = new URL("file", null, dir.getCanonicalPath()); ((Deployer) host).install(config, null); } catch (Throwable t) { log(sm.getString("hostConfig.deployDescriptor.error", files[i]), t); } } } }
Deploying a WAR File 可以部署war文件形式的web应用。HostConfig使用如Listing18.7所示的deployWARs方法来部署%CATALINA_HOME%/webapps目录下的WAR文件。
Listing 18.7: The deployWARs method in HostConfig protected void deployWARs(File appBase, String[] files) { for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; if (deployed.contains(files [i])) continue; File dir = new File(appBase, files [i]); if (files[i].toLowerCase().endsWith(".war")) { deployed.add(files [i]); // Calculate the context path and make sure it is unique String contextPath = "/" + files[i]; int period = contextPath.lastIndexOf("."); if (period >= 0) contextPath = contextPath.substring(0, period); if (contextPath.equals("/ROOT")) contextPath = ""; if (host.findChild(contextPath) != null) continue;
if (isUnpackWARs()) { // Expand and deploy this application as a directory log(sm.getString("hostConfig.expand", files[i])); try { URL url = new URL("jar:file:" + dir.getCanonicalPath() + "!/"); String path = expand(url); url = new URL("file:" + path); ((Deployer) host).install(contextPath, url); } catch (Throwable t) { log(sm.getString("hostConfig.expand.error", files[i]), t); } } else { // Deploy the application in this WAR file log(sm.getString("hostConfig.deployJar", files[i])); try { URL url = new URL("file", null, dir.getCanonicalPath()); url = new URL("jar:" + url.toString() + "!/"); ((Deployer) host).install(contextPath, url); } catch (Throwable t) { log(sm.getString("hostConfig.deployJar.error",
files[i]), t); } } } }
} Deploying a Directory 另外也可以将整个目录拷贝到%CATALINA_HOME%/webapps目录下来部署一个应用。HostConfig使用如Listing18.8所示的deployDirectories来部署目录：
Listing 18.8: The deployDirectories method in HostConfig protected void deployDirectories (File appBase, string[] files){ for (int i = 0; i < files.length; i++) { if (files[i].equalsIgnoreCase("META-INF")) continue; if (files[i].equalsIgnoreCase("WEB-INF")) continue; if (deployed.contains(files[i]))
continue; File dir = new File(appBase, files[i]); if (dir.isDirectory()) { deployed.add(files[i]); // Make sure there is an application configuration directory // This is needed if the Context appBase is the same as the // web server document root to make sure only web applications // are deployed and not directories for web space. File webInf = new File(dir, "/WEB-INF"); if (!webInf.exists() || !webInf.isDirectory() || !webInf.canRead()) continue; // Calculate the context path and make sure it is unique String contextPath = "/" + files[i]; if (files[i].equals("ROOT")) contextPath = ""; if (host.findChild(contextPath) != null) continue; // Deploy the application in this directory log(sm.getString("hostConfig.deployDir", files[i])); try { URL url = new URL("file", null, dir.getCanonicalPath()); ((Deployer) host).install(contextPath, url); } catch (Throwable t) { log(sm.getString("hostConfig.deployDir.error", files[i]), t); }
} } }
Live Deploy
如前面提到的StandardHost实例使用HostConfig对象作为一个生命周期监听器。当StandardHost对象开始的时候，它的start方法触发一个START事件。作为该事件的响应，HostConfig中的lifecycleEvent方法作为它的事件处理器，调用它的start方法。在Tomcat4中，start方法的最后一行如果liveDeploy属性为真的话（默认为真）调用threadStart方法。 if (isLiveDeploy()) {
threadStart(); } threadStart分配一个新线程并调用它的run方法，run方法周期性的检查在web.xml文件中的已存在部署是否有改变。该方法如Listing18.9所示：
Listing 18.9: The run method in HostConfig in Tomcat 4 /** * The background thread that checks for web application autoDeploy * and changes to the web.xml config. */ public void run() { if (debug >= 1) log("BACKGROUND THREAD Starting"); // Loop until the termination semaphore is set while (!threadDone) { // Wait for our check interval threadSleep(); // Deploy apps if the Host allows auto deploying deployApps(); // Check for web.xml modification checkWebXmlLastModified(); } if (debug >= 1) log("BACKGROUND THREAD Stopping"); }
threadSleep方法让线程休眠checkInterval属性定义的时间，它的默认值是15，这意味着检查没15秒进行一次。
在Tomcat5中，HostConfig没有独立的线程而是使用backgroundProcess方法来周期性的进行检查事件。 public void backgroundProcess() { lifecycle.fireLifecycleEvent("check", null); }
注意
backgroundProcess会被周期性的调用，工作由一个特殊的线程来处理容器中的后台处理。
在收到一个”check”事件后，生命周期对象HostConfig对象调用它的check方法进行检查工作： public void lifecycleEvent(LifecycleEvent event) { if (event.getType().equals("check")) check(); ...
Tomcat5中的HostConfig的check方法如Listing18.10
Listing 18.10: The check method in HostConfig in Tomcat 5 protected void check() { if (host.getAutoDeploy()) { // Deploy apps if the Host allows auto deploying deployApps(); // Check for web.xml modification checkContextLastModified(); } }
在check方法中调用了deployApps方法，deployApps方法在Tomcat4和5中都是部署一个web应用程序，如Listing18.3所示。如前面所讨论的该方法调用eployDescriptors, deployWARs, 和deployDirectories。 Tomcat5中的check方法调用了checkCOntextLastModified方法，迭代所有的部署上下文并检查web.xml以及每个上下文WEB-INF目录下面内容的时间戳。如果检查到改变，就重启该上下文。另外，checkContextLastModified方法还检查部署的WAR文件的时间戳，如果有改变就进行改变。
在Tomcat4中，后台线程的run方法调用checkWebXmlLastModified跟Tomcat5中的checkContextLastModified方法完成相同任务。 Deployer接口 一个部署器由org.apache.catalina.Deployer接口表示。StandardHost类实现了Deployer接口，以你次，一个StandardHost实例除了是一个容器外也是一个部署器。Deployer接口如Listing18.11所示
Listing 18.11: The Deployer interface package org.apache.catalina; import java.io.IOException; import java.net.URL; /** * A <b>Deployer</b> is a specialized Container into which web * applications can be deployed and undeployed. Such a Container * will create and install child Context instances for each deployed * application. The unique key for each web application will be the * context path to which it is attached. * * @author Craig R. McClanahan * @version $Revision: 1.6 $ $Date: 2002/04/09 23:48:21 $ */
public interface Deployer { /** * The ContainerEvent event type sent when a new application is * being installed by <code>install()</code>, before it has been * started. */ public static final String PRE_INSTALL_EVENT = "pre-install"; /** * The ContainerEvent event type sent when a new application is * installed by <code>install()</code>, after it has been started. */ public static final String INSTALL_EVENT = "install"; /** * The ContainerEvent event type sent when an existing application is * removed by <code>remove()</code>. */ public static final String REMOVE_EVENT = "remove"; /**

* Return the name of the Container with which this Deployer is * associated. */ public String getName(); /** * Install a new web application, whose web application archive is at * the specified URL, into this container with the specified context. * path. A context path of "" (the empty string) should be used for * the root application for this container. Otherwise, the context * path must start with a slash. * <p> * If this application is successfully installed, a ContainerEvent of * type <code>INSTALL_EVENT</code> will be sent to all registered * listeners, * with the newly created <code>Context</code> as an argument. * * @param contextPath The context path to which this application * should be installed (must be unique) * @param war A URL of type "jar:" that points to a WAR file, or type * "file:" that points to an unpacked directory structure containing * the web application to be installed *
* @exception IllegalArgumentException if the specified context path * is malformed (it must be "" or start with a slash) * @exception IllegalStateException if the specified context path * is already attached to an existing web application * @exception IOException if an input/output error was encountered * during installation */ public void install(String contextPath, URL war) throws IOException; /** * <p>Install a new web application, whose context configuration file * (consisting of a <code>&lt;Context&gt;</code> element) and web * application archive are at the specified URLs.</p> * * <p>If this application is successfully installed, a ContainerEvent * of type <code>INSTALL_EVENT</code> will be sent to all registered * listeners, with the newly created <code>Context</code> as an * argument. * </p> * * @param config A URL that points to the context configuration file * to be used for configuring the new Context * @param war A URL of type "jar:" that points to a WAR file, or type * "file:" that points to an unpacked directory structure containing * the web application to be installed * * @exception IllegalArgumentException if one of the specified URLs * is null * @exception IllegalStateException if the context path specified in * the context configuration file is already attached to an existing * web application * @exception IOException if an input/output error was encountered * during installation */
  public void install(URL config, URL war) throws IOException; /** * Return the Context for the deployed application that is associated * with the specified context path (if any); otherwise return * <code>null</code>. * * @param contextPath The context path of the requested web * application
  */ public Context findDeployedApp(String contextPath); /** * Return the context paths of all deployed web applications in this * Container. If there are no deployed applications, a zero-length * array is returned. */ public String[] findDeployedApps(); /** * Remove an existing web application, attached to the specified * context path. If this application is successfully removed, a * ContainerEvent of type <code>REMOVE_EVENT</code> will be sent to * all registered listeners, with the removed <code>Context</code> as * an argument. * * @param contextPath The context path of the application to be * removed * * @exception IllegalArgumentException if the specified context path * is malformed (it must be "" or start with a slash) * @exception IllegalArgumentException if the specified context path * does not identify a currently installed web application * @exception IOException if an input/output error occurs during * removal */ public void remove(String contextPath) throws IOException; /** * Start an existing web application, attached to the specified * context path. Only starts a web application if it is not running. * * @param contextPath The context path of the application to be * started * @exception IllegalArgumentException if the specified context path * is malformed (it must be "" or start with a slash) * @exception IllegalArgumentException if the specified context path * does not identify a currently installed web application * @exception IOException if an input/output error occurs during * startup */ public void start(String contextPath) throws IOException;
  /** * Stop an existing web application, attached to the specified * context path. Only stops a web application if it is running.
* * @param contextPath The context path of the application to be * stopped * @exception IllegalArgumentException if the specified context path * is malformed (it must be "" or start with a slash) * @exception IllegalArgumentException if the specified context path * does not identify a currently installed web application * @exception IOException if an input/output error occurs while * stopping the web application */ public void stop(String contextPath) throws IOException; }
    StandardHost使用一个org.apache.catalina.core.StandardHostDeployer类型的帮助类来部署和安装web应用程序。下面你可以看到StandardHost如何使用StandardDeployer实例来部署和安装web应用程序。 /** * The <code>Deployer</code> to whom we delegate application * deployment requests. */ private Deployer deployer = new StandardHostDeployer(this); public void install(String contextPath, URL war) throws IOException { deployer.install(contextPath, war); } public synchronized void install(URL config, URL war) throws IOException { deployer.install(config, war); } public Context findDeployedApp(String contextPath) { return (deployer.findDeployedApp(contextPath)); } public String[] findDeployedApps() { return (deployer.findDeployedApps()); } public void remove(String contextPath) throws IOException { deployer.remove(contextPath); } public void start(String contextPath) throws IOException { deployer.start(contextPath);
    } public void stop(String contextPath) throws IOException { deployer.stop(contextPath); } StandardHostDeployer将会在下一节讨论：
    StandardHostDeployer类
    org.apache.catalina.core.StandardHostDeployer类是StandardHost的一个帮助类用来部署和安装web应用程序。StandardHostDeployer被设计成由StandardHost使用，它的构造函数接受一个StandardHost实例。 public StandardHostDeployer(StandardHost host) { super(); this.host = host; } 该类的方法将在下面的小节中介绍
    Installing a Descriptor
    StandardHostDeployer类有两个install方法。第一个也是本小节介绍的用于安装描述符（descriptor）。第二个在下一小节介绍用于安装WAR文件和目录。 用于安装描述符的install方法如Listing18.12所示。StandardHost实例在HostConfig通过deployDecriptors来调用install方法的时候调用。
    Listing 18.12: The install method for installing descriptors public synchronized void install(URL config, URL war) throws IOException { // Validate the format and state of our arguments if (config == null) throw new IllegalArgumentException (sm.getString("StandardHost.configRequired")); if (!host.isDeployXML()) throw new IllegalArgumentException (sm.getString("StandardHost.configNotAllowed")); // Calculate the document base for the new web application (if // needed) String docBase = null; // Optional override for value in config file if (war != null) { String url = war.toString(); host.log(sm.getString("StandardHost.installingWAR", url)); // Calculate the WAR file absolute pathname if (url.startsWith("jar:")) {
    url = url.substring(4, url.length() - 2); } if (url.startsWith("file://")) docBase = url.substring(7); else if (url.startsWith("file:"))
    docBase = url.substring(5); else throw new IllegalArgumentException (sm.getString("standardHost.warURL", url)); } // Install the new web application this.context = null; this.overrideDocBase = docBase; InputStream stream = null; try { stream = config.openStream(); Digester digester = createDigester(); digester.setDebug(host.getDebug()); digester.clear(); digester.push(this); digester.parse(stream); stream.close(); stream = null; } catch (Exception e) { host.log (sm.getString("standardHost.installError", docBase), e); throw new IOException(e.toString()); } finally { if (stream != null) { try { stream.close(); } catch (Throwable t) { ; } } } }
    Installing a WAR file and a Directory
    第二个install方法介绍一个上下文路径的字符串表示形式或者一个URL来表示WAR文件。该install方法如Listing18.13所示
    Listing 18.13: The install method for installing a WAR file or a directory public synchronized void install(String contextPath, URL war) throws IOException { // Validate the format and state of our arguments if (contextPath == null) throw new IllegalArgumentException (sm.getString("standardHost.pathRequired")); if (!contextPath.equals("") && !contextPath.startsWith("/")) throw new IllegalArgumentException
    (sm.getString("standardHost.pathFormat", contextPath)); if (findDeployedApp(contextPath) != null) throw new IllegalStateException (sm.getString("standardHost.pathUsed", contextPath)); if (war == null) throw new IllegalArgumentException (sm.getString("standardHost.warRequired")); // Calculate the document base for the new web application host.log(sm.getString("standardHost.installing", contextPath, war.toString())); String url = war.toString(); String docBase = null; if (url.startsWith("jar:")) { url = url.substring(4, url.length() - 2); } if (url.startsWith("file://")) docBase = url.substring(7); else if (url.startsWith("file:")) docBase = url.substring(5); else throw new IllegalArgumentException (sm.getString("standardHost.warURL", url)); // Install the new web application try { Class clazz = Class.forName(host.getContextClass()); Context context = (Context) clazz.newInstance(); context.setPath(contextPath);
    context.setDocBase(docBase); if (context instanceof Lifecycle) { clazz = Class.forName(host.getConfigClass()); LifecycleListener listener = (LifecycleListener) clazz.newInstance(); ((Lifecycle) context).addLifecycleListener(listener); } host.fireContainerEvent(PRE_INSTALL_EVENT, context); host.addChild(context); host.fireContainerEvent(INSTALL_EVENT, context); } catch (Exception e) { host.log(sm.getString("standardHost.installError", contextPath), e); throw new IOException(e.toString()); } }
    注意一旦一个上下文被安装，它将会被添加到StandardHost。
    Starting A Context
    StandardHostDeployer的start方法用于启动一个上下文。它如Listing18.14所示
    Listing 18.14: The start method of the StandardHostDeployer class public void start(String contextPath) throws IOException { // Validate the format and state of our arguments if (contextPath == null) throw new IllegalArgumentException (sm.getString("standardHost.pathRequired")); if (!contextPath.equals("") && !contextPath.startsWith("/")) throw new IllegalArgumentException (sm.getString("standardHost.pathFormat", contextPath)); Context context = findDeployedApp(contextPath); if (context == null) throw new IllegalArgumentException (sm.getstring("standardHost.pathMissing", contextPath)); host.log("standardHost.start " + contextPath); try { ((Lifecycle) context).start(); } catch (LifecycleException e) {
    host.log("standardHost.start " + contextPath + ": ", e); throw new IllegalStateException ("standardHost.start " + contextPath + ": " + e); } }
    Stopping A Context
    要停止一个上下文，可以使用StandardHostDeployer的stop方法如Listing18.15
    Listing 18.15: The stop method in the StandardHostDeployer class public void stop(String contextPath) throws IOException { // Validate the format and state of our arguments if (contextPath == null) throw new IllegalArgumentException (sm.getstring("standardHost.pathRequired")); if (!contextPath.equals("") && !contextPath.startsWith("/")) throw new IllegalArgumentException (sm.getstring("standardHost.pathFormat", contextPath)); Context context = findDeployedApp(contextPath); if (context == null) throw new IllegalArgumentException (sm.getstring("standardHost.pathMissing", contextPath)); host.log("standardHost.stop " + contextPath); try {
    ((Lifecycle) context).stop(); } catch (LifecycleException e) { host.log("standardHost.stop " + contextPath + ": ", e); throw new IllegalStateException ("standardHost.stop " + contextPath + ": " + e); } } 总结 部署器用于部署和安装web应用，由org.apache.catalina.Deployer表示。StandardHost类实现了Deployer，这样它就是一个可以部署web应用的特殊容器。StandardHost使用一个帮助类来完成web应用的部署和安装，该帮助类为org.apache.catalina.core.StandardHostDeployer。StandardHostDeployer类提供了部署和安装应用，以及启动和停止上下文容器的代码。
    第19章：管理Servlet
    综述 Tomcat4和5有一个Manager应用程序用于管理部署的应用程序。跟其它应用程序不同，Manager并不是在%CATALINA_HOME%/webapps目录下面而是在%CATALINA_HOME%/server/webapps下。Manager有一个描述符manager.xml在%CATALINA_HOME$/webapps（Tomcat4）或者%CATALINA_HOME%/server/webapps（Tomcat5），当Tomcat启动的时候就安装Manager。
    注意
    上下文描述符在第18章中讨论了
    本章主要用于描述Manager应用，首先概括的解释了Manager是如何工作的，然后解释了ContainerServlet接口。 Manager应用使用 Manager应用可以在%CATALINA_HOME%/server/webapps/manager目录下找到。该应用中的主servlet是ManagerServlet。在Tomcat4中，该类属于org.apache.catalina.servlets包。在Tomcat5中，该类是org.apache.catalina.manager包的一部分，以JAR包的形式部署在WEB-INF/lib目录下：
    注意
    由于Tomcat4中的Manager应用程序比Tomcat5中的简单，所以它更容易学习，本章主要讨论它。在读完了本章后，你也可以理解Tomcat5中的Manager是如何工作的。
    Here are the servlet elements in the deployment descriptor in Tomcat 4. 这里是Tomcat4中的部署描述符的servlet元素 <servlet> <servlet-name>Manager</servlet-name> <servlet-class> org.apache.catalina.servlets.ManagerServlet </servlet-class> <init-param> <param-name>debug</param-name> <param-value>2</param-value> </init-param> </servlet> <servlet> <servlet-name>HTMLManager</servlet-name> <servlet-class> org.apache,catalina.servlets.HTMLManagerServlet </servlet-class> <init-param>
    <param-name>debug</param-name> <param-value>2</param-value> </init-param> </servlet> 第一个servlet是org.apache.catalina.servlets.ManagerServlet，第二个是org.apache.catalina.servlets.HTMLManagerServlet。本章主要介绍ManagerServerlet。 本应用程序的描述符manager.xml，说明了本应用程序的上下文路径为/manager <Context path="/manager" docBase="../server/webapps/manager" debug="0" privileged="true"> <!-- Link to the user database we will get roles from --> <ResourceLink name="users" global="UserDatabase" type="org.apache.catalina.UserDatabase"/> </Context> 第一个servlet映射元素说明如何调用ManagerServlet <servlet-mapping> <servlet-name>Manager</servlet-name> <url-pattern>/*</url-pattern> </servlet-mapping> 换句话说，如下形式的URL模式将会调用MangerServlet: http://localhost:8080/manager/ 但是，注意在部署描述符中还有安全限制元素
    <security-constraint> <web-resource-collection> <web-resource-name>Entire Application</web-resource-name> <url-pattern>/*</url-pattern> </web-resource-collection> <auth-constraint> <!-- NOTE: This role is not present in the default users file -—> <role-name>manager</role-name> </auth-constraint> </security-constraint> 它的意思是说，整个应用程序只能被manager角色的用户使用。auth-login元素规定用户需要提供正确的用户名密码来通过BASIC验证。 <login-config> <auth-method>BASIC</auth-method> <realm-name>Tomcat Manager Application</realm-name> </login-config> 在Tomcat中，用户角色在%CATALINA_HOME%/conf目录下的tomcat-users.xml文件中有列表。因此，要进入Manager应用程序，必须给用户添加manager角色。 <?xml version='1.0' encoding='utf-8'?>
    <tomcat-users> <role rolename="manager"/> <user username="tomcat" password="tomcat" roles="manager "/> </tomcat-users> 通过该tomcat-users.xml，可以使用用户名tomcat密码tomcat的用户访问Manager应用程序。 下面的是ManagerServlet的可用函数： · list · start · stop · reload · remove · resources · roles · sessions · undeploy 查看servlet的doGet方法看下如何调用一个function。 ContainerServlet接口
    一个实现了org.apache.catalina.ContainerServlet接口的servlet可以访问StandardWrapper对象。可以访问包装器，它也能访问表示该web应用的上下文对象，以及该上下文隶属的部署器（StandardHost实例）以及其它对象。 ContainerServlet接口如Listing19.1所示：
    Listing 19.1: The ContainerServlet Interface package org.apache.catalina; public interface ContainerServlet { public Wrapper getWrapper(); public void setWrapper(Wrapper wrapper); } ManagerServlet初始化 通常情况下，一个servlet用一个org.apache.catalina.core.StandardWrapper实例表示。在第一次调用该servlet的时候，StandardedWrapper对象的loadServlet方法会被调用，它又调用servlet的init方法。接下来你会看到ManagerServlet的loadServlet方法是如何工作的： ... // Special handling for ContainerServlet instances
    if ((servlet instanceof ContainerServlet) && isContainerProvidedServlet(actualClass)) { ((ContainerServlet) servlet).setWrapper(this); } // Call the initialization method of this servlet try { instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT, servlet); servlet.init(facade); ...
    servlet表示要加载的servlet（在这里是ManagerServlet） 在if语句块中，如果servlet是org.apache.catalina.ContainerServlet的实例并且isContainerProvidedServlet方法返回true。就调用ContainerServlet接口的setWrapper接口。 ManagerServlet类实现了ContainerServlet，因此servlet是ContainerSerlvet的一个实例。在StanadardWrapper中的isContainerProvidedServlet方法如Listing19.2所示
    Listing 19.2: The isContainerProvidedServlet method in the StandardWrapper class private boolean isContainerProvidedServlet(String classname) { if (classname.startsWith("org.apache.catalina.")) { return (true); } try { Class clazz = this.getClass().getClassLoader().loadClass(classname); return (ContainerServlet.class.isAssignableFrom(clazz)); } catch (Throwable t) { return (false); } } 传递给isContainerProvidedServlet方法的参数classname是ManagerSerlvet的完全限定名（fully-qualified），即org.apache.catalina.servlets.ManagerServlet。因此，isContainerProvidedServlet方法返回true。 如果该servlet类是ContainerServlet的子类，该方法也返回true，如果classname是接口继承了ContainerServlet或者是实现了ContainerServlet的类名。
    注
    如果表示当前对象的类或接口跟clazz表示的类或接口或相同，或是超类、
    意
    超接口的时候java.lang.Class类的isAssignableFrom(Class clazz)返回true。
    因此，表示ManagerServlet实例的StandardWrapper在它的loadServlet方法中会调用ManagerServlet的setWrapper方法。这里是ManagerServlet类对setWrapper方法的实现： public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; if (wrapper == null) { context = null; deployer = null; } else { context = (Context) wrapper.getParent(); deployer = (Deployer) context.getParent(); } } 如果参数wrapper不是null，将会执行else语句块。将表示Manager应用的上下文赋值给context变量并将该上下文部署在StandardHost实例上。Deployer非常重要，它会在ManagerServlet的好几个方法中使用到。 在StandardWrapper的loadServlet调用了StandardWrapper的setWrapper方法之后。loadServlet方法调用MangerServlet的init方法。 列出Web应用 可以使用如下URL来查看部署的所有应用程序： http://localhost:8080/manager/list 下面是一则输出的例子 OK - Listed applications for virtual host localhost /admin:stopped:0:../server/webapps/admin /app1:running:0:C:\123data\JavaProjects\Pyrmont\webapps\app1 /manager:running:0:../server/webapps/manager 上面的URL将会调用ManagerServlet的list方法，如Listing19.3所示
    Listing 19.3: The list method of ManagerServlet protected void list(PrintWriter writer) { if (debug >= 1) log("list: Listing contexts for virtual host '" + deployer.getName() + "'"); writer.println(sm.getString("managerServlet.listed", deployer.getName())); String contextPaths[] = deployer.findDeployedApps();
    for (int i = 0; i < contextPaths.length; i++) { Context context = deployer.findDeployedApp(contextPaths[i]); String displayPath = contextPaths[i]; if( displayPath.equals("") ) displayPath = "/"; if (context != null ) { if (context.getAvailable()) { writer.println(sm.getString("managerServlet.listitem", displayPath, "running", "" + context.getManager().findSessions().length, context.getDocBase())); } else { writer.println(sm.getString("managerServlet.listitem", displayPath, "stopped", "0", context.getDocBase())); } } } }
    方法list调用部署器的findDeployedApps获得所有部署在Catalina中的上下文的路径。然后变量路径数组获得每个独立的上下文并检查该上下文是否可用。对于每个可用的上下文，list方法打印出上下文路径，running字符串，用户的Session个数以及文档基（document base）。对于不可用的上下文，list方法打印出上下文路径，stopperd字符串，0以及文档基。 启动一个web应用 可以使用如下URL来启动一个web应用： http://localhost:8080/manager/start?path=/contextPath contextPath是要启动的应用的上下文路径。例如，要启动admin应用，可以使用如下路径： http://localhost:8080/manager/start?path=/admin 如果该应用程序已经启动，你会收到错误提示信息： 根据该URL，ManagerServlet调用start方法，如Listing19.4所示
    Listing 19.4: The start method of the ManagerServlet class protected void start(PrintWriter writer, String path) { if (debug >= 1) log("start: Starting web application at '" + path + "'");
    if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", path));
    return; } String displayPath = path; if( path.equals("/") ) path = ""; try { Context context = deployer.findDeployedApp(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", displayPath)); return; } deployer.start(path); if (context.getAvailable()) writer.println (sm.getString("managerServlet.started", displayPath)); else writer.println (sm.getString("managerServlet.startFailed", displayPath)); } catch (Throwable t) { getServletContext().log (sm.getString("managerServlet.startFailed", displayPath), t); writer.println (sm.getString("managerServlet.startFailed", displayPath)); writer.println(sm.getString("managerServlet.exception", t.toString())); } }
    在一些检查之后，start方法调用部署器的findDeployedApp方法，该方法通过path路径获得上下文，如果上下文不为空，start方法调用部署器的start方法启动应用程序。 停止web应用 可以使用如下命令来停止一个应用程序： http://localhost:8080/manager/stop?path=/contextPath contextPath是你想要停止的web应用的路径，如果该应用并没有正在运行，会返回错误信息： ManagerSerlvet收到请求的时候，它调用stop方法，如Listing19.5所示：
    Listing 19.5: The stop method of the ManagerServlet class
    protected void stop(PrintWriter writer, String path) { if (debug >= 1) log("stop: Stopping web application at '" + path + "'"); if ((path == null) || (!path.startsWith("/") && path.equals(""))) { writer.println(sm.getString("managerServlet.invalidPath", path)); return; } String displayPath = path; if( path.equals("/") ) path = ""; try { Context context = deployer.findDeployedApp(path); if (context == null) { writer.println(sm.getString("managerServlet.noContext", displayPath)); return; } // It isn't possible for the manager to stop itself if (context.getPath().equals(this.context.getPath())) { writer.println(sm.getString("managerServlet.noSelf")); return; } deployer.stop(path); writer.println(sm.getString("managerServlet.stopped", displayPath)); } catch (Throwable t) { log("ManagerServlet.stop[" + displayPath + "]", t); writer.println(sm.getString("managerServlet.exception", t.toString())); } }
    通过上面的代码可以明白stop方法是如何工作的。ManagerServlet类的其它方法可以在源码中查看。
    总结
    本章介绍了如何使用一个特殊接口ContainerServelet来创建一个可以访问Catalina内部类的Servlet。Manager应用可以用于管理部署应用，并说明了如何从包装器对象获得其它对象。另外可以设计一个更复杂的Servlet来管理Tomcat。
    第20章：JMX-Based Management
    第19章讨论了Manger应用程序，演示了如何使用实现了ContainerServlet的ManagerServlet类来访问Catalina的内部对象。本章演示用另一种更成熟的方法来管理Tomcat，该方法使用Java管理扩展（Java Management extentsions，JMX）。对于不熟悉JMX的读者，本章开头先进行了简单的介绍。另外本章解释了常用建模库（Commons Modeler library），它可以很简单的写管理beans（Managed Beans），这些对象用于管理其它的对象。另外还提供了例子来进行JMX在Tomcat中使用的说明。
    JMX简介 目前为止，ContainerServlet接口已经足够管理Catalina内部类的访问，为什么还要关注JMX？答案是JMX提供了更大的灵活性。很多基于服务的应用程序，如Tomcat，JBoss，JONAS，Geronimo以及其它的应用，都使用JMX来管理他们的 JMX目前的版本是1.21，定义了一个公开的管理Java对象的标准。例如，Tomcat4和5使用JMX的管理程序来使得各种对象（如服务器、主机、上下文、阀门等等）可用。Tomcat的开发者编写了Admin应用程序用于管理。 一个可以使用JMX管理器来管理的Java对象称为JMX管理资源（JMX manageable resource）。事实上，一个JMX管理资源也可以是一个应用程序、一个实现或者一个服务、设备、用户等等。JMX管理资源用Java写或者提供一个Java包装。
    要想让一个Java对象称为JMX管理资源，必须创建另一个名为Managed Bean或者MBean的对象。org.apache.catalina.mbeans包包括一些MBeans。ConnectorMBean, StandardEngineMBean, StandardHostMBean, StandardContextMBean是Managed Bean的例子。从他们的名字你可以猜到ConnectMBean用于管理连接器，StandardContextMBean用于管理org.apache.catalina.core.StandardContext对象等等。当然，你也可以编写MBean管理多个Java对象。 MBean将Java对象的属性和方法暴露给管理应用程序（management application）。管理应用程序本身不能直接访问Java对象。因此可以选择任意的属性和方法让管理应用程序访问。 一旦你有一个MBean类，你需要初始化它的一个对象并将其注册到一个MBean服务器的对象（MBean server）。MBean服务器是应用程序中所有的MBean的中心登记处（central registry）。管理应用程序通过MBean服务器访问MBeans。将JMX和Servlet应用程序相比较，管理应用程序相当于一个web浏览器。MBean服务器相当于一个Servlet容器，它为客户端提供管理资源的访问。而MBeans相当于Servlet或者JSP页面。就像是web浏览器从来不直接接触Servlet/JSP页面，而是通过容器访问。管理应用程序也不会直接访问MBeans，而是通过MBean服务器来进行。
    一共有四种MBean：标准standard,动态dynamic, 打开open, 和模型model。其中，标准MBean是里面最容易编写的，但是他的灵活性也最小。另外三种更灵
    活，我们将会特别关注模型MBeans，因为Catalina就是使用了这种类型的MBean。在后边有对模型MBeans的讨论，我们会省略动态和打开JMX因为它们与本章没有关系。感兴趣的用户可以阅读JMX1.21规范问答了解更多的细节。
    从结构上来看，JMX规范分为3层，设备层（instrumentation level），代理层（agent level），和分布服务层（distributed services level）。MBean服务器处于代理层，而MBeans处于设备层。分布服务层将会在JMX规范的未来版本涉及到。
    设备层定义了编写JMX管理资源的标准，也就是怎么写MBeans。代理层提供了如何创建一个代理。一个代理封装了一个MBean服务器以及用于处理MBeans的服务。代理和MBeans处于同一个Java虚拟机中，由于JMX规范带有一些参考实现，你不需要自己编写MBean服务器。参考实现提供了一种创建默认MBean服务器的方式
    Note
    Download the specification and reference implementation from http://java.sun.com/products/JavaManagement/download.html. MX4J, an open source version of JMX whose library is included in the software accompanying this book, is available from http://mx4j.sourceforge.net
    Warning
    The zip file that accompanies this book contains the mx4j.jar file that packages the version 2.0 beta 1 of MX4J, replacing the mx4j-jmx.jar file included in Tomcat 4.1.12. This was done in order for you to use the more recent version of JMX (version 1.2.1).
    JMX API
    参考实现组成了Java标准库中的javax.management包以及其它JMX编程相关的特殊领域的包。本节会讨论API中的一些重要类型。
    MBeanServer
    javax.management.MBeanServer是一个表示MBean服务器的接口。要创建一个MBean服务器，可以使用javax.management.MBeanServerFactory中的方法即可，例如createMBean方法。 要在MBean服务器注册MBean，调用MBean服务器对象的registerMBean方法即可。下面是registerMBean方法的签名： public ObjectInstance registerMBean(java.lang.Object object, ObjectName name) throws InstanceAlreadyExistsException, MBeanRegistrationException, NotCompliantMBeanException
    registerMBean方法需要传递一个MBean实例以及实例的对象名（ObjectName）。ObjectName类似于HashMap中的键值，它必须是唯一的。registerMBean返回一个ObjectInstance对象。javax.management.ObjectInstance封装了MBean的对象名以及它的类名。 要检索MBean对象或对象集是否匹配一个模式，MBeanServer接口提供了两个方法queryNames以及queryMBeans。queryNames方法返回一个包括所有对象名匹配模式的MBean的ava.util.Set集合。下面是queryName方法的签名： public java.util.Set queryNames(ObjectName name, QueryExp query) 参数query指定筛选条件 如果name的值为null或者没有指定域和键的值，就返回所有注册MBean的ObjectName。如果query是null，没有过滤器使用。 queryMBeans方法跟queryName相似，但是他返回包含所有选择的ObjectInstance对象的java.util.Set集合。queryMBeans方法的签名如下： public java.util.Set queryMBeans(ObjectName name, QueryExp query) 一旦你获得了需要的MBean，就可以操作暴露的属性和方法。 可以使用MBeanServer接口中的invoke方法来调用注册MBean中的任何方法。MBeanServer接口的getAttribute和setAttribute方法用于获得和设置注册MBean的属性。
    ObjectName
    MBean服务器用于注册MBean。对于在MBean服务器上的MBean，它们都有唯一的对象名，就像是HashMap中的对象都有唯一的键值一样。 对象名由javax.management.ObjectName类表示。一个对象名由两部分组成：域（domain）和一个键值集合。域是一个字符串，可以是空字符处。在一个对象名种，域之后的是冒号以及一个或多个键值对。键是一个非空字符串，不能包含下面的符号equal sign, comma, colon, asterisk, 和question mark。相同的键在一个对象名种只发生一次。 键和值之间用等号隔开，两个键值对之间用逗号隔开。例如，下面是一个合法的对象名： myDomain:type=Car,color=blue ObjectName也可以表示在MBean服务器上查找MBean的属性模式。一个ObjectName是一个它的域和键值对表示的模式。一个ObjectName模式可以零个或多个键。 标准MBeans 标准MBean是最简单的MBean。要是用标准MBean管理一个Java对象，需要以下工作：
    · 创建一个接口，名为你的类名加上后缀MBean。例如，如果要管理的Java类是Car，接口名酒味CarMBean。 · 修改Java类，让它实现你创建的接口。 · 创建一个代理，该代理必须包括一个MBean服务器。 · 为你的MBean创建一个ObjectName。 · 初始化MBean服务器。 · 想MBean服务器注册MBean。 标准MBean更易于变现，但是使用它们的话需要修改你自己的类，这在某些情况下可以，但是有时候是不行的。其它类型的MBean允许在不修改类的情况下管理对象。 考虑下面的类如何变成JMX管理的，作为一个标准MBean的例子。 package ex20.pyrmont.standardmbeantest; public class Car { private String color = "red"; public String getColor() { return color; } public void setColor(String color) {
    this.color = color; } public void drive() { System.out.println("Baby you can drive my car."); } } 修改的第一步是要实现CarMBean接口，新的car类如Listing20.1所示：
    Listing 20.1: The modified Car class package ex20.pyrmont.standardmbeantest; public class Car implements CarMBean { private String color = "red"; public String getColor() { return color; } public void setColor(String color) { this.color = color; } public void drive() {
    System.out.println("Baby you can drive my car."); } }
    接下来创建CarMBean接口如Listing20.2
    Listing 20.2: The CarMBean interface package ex20.pyrmont.standardmbeantest; public interface CarMBean { public String getColor(); public void setColor(String color); public void drive(); }
    基本上，在接口中需要声明所有你需要暴露的方法。在该例子中，CarMBean接口列出了Car类中的所有接口。如果不想让管理程序使用driver方法，从CarMBean接口中移除driver方法即可。 最后，Listing20.3的StandardAgent展示了如何创建一个标准MBean来管理Car类的对象。
    Listing 20.3: The StandardAgent class package ex20.pyrmont.standardmbeantest; import javax.management.Attribute;
    import javax.management.ObjectName; import javax.management.MBeanServer; import javax.management.MBeanServerFactory; public class StandardAgent { private MBeanServer mBeanServer = null; public StandardAgent() { mBeanServer = MBeanServerFactory.createMBeanServer(); } public MBeanServer getMBeanServer() { return mBeanServer; } public ObjectName createObjectName(String name) { ObjectName objectName = null; try { objectName = new ObjectName(name); } catch (Exception e) {
    } return objectName; } private void createStandardBean(ObjectName objectName, String managedResourceClassName) { try { mBeanServer.createMBean(managedResourceClassName, objectName); } catch(Exception e) { } } public static void main(String[] args) { StandardAgent agent = new StandardAgent();
    MBeanServer mBeanServer = agent.getMBeanServer(); String domain = mBeanServer.getDefaultDomain(); String managedResourceClassName = "ex20.pyrmont.standardmbeantest.Car"; ObjectName objectName = agent.createObjectName(domain + ":type=" + managedResourceClassName); agent.createStandardBean(objectName, managedResourceClassName); // manage MBean try { Attribute colorAttribute = new Attribute("Color","blue"); mBeanServer.setAttribute(objectName, colorAttribute); System.out.println(mBeanServer.getAttribute(objectName, "Color")); mBeanServer.invoke(objectName,"drive",null,null); } catch (Exception e) { e.printStackTrace(); } } }
    StandardAgent类是一个代理，它创建一个MBean服务器，用它注册一个CarMBean。首先要做的是要初始化mBeanServer，在StandardAgent类的构造函数中，使用了MBeanServerFactory类的createMBeanServer方法来构造一个MBean服务器。 public StandardAgent() { mBeanServer = MBeanServerFactory.createMBeanServer(); }
    createMBeanServer方法返回一个实现了JMX的MBeanServer对象。高级的JMX程序员可能想自己实现MBeanServer，但是本书并不关注该问题。 StandardAgent的createObjectName根据传递给它的String参数返回一个ObjectName对象。StandardAgent的createObjectName方法调用了MBeanServer的createMBean方法。createMBean接受要管理的资源的类名以及唯一的用于区别它们的ObjectName对象。createMBean还将创建的MBean对象注册到MBeanServer上。因为标准MBean遵循传统的命名。不需要想createMBean方法提供MBean类型名。如果管理的资源类名为Car，它的MBean就是CarMBean。 StandardAgent的main方法首先创建了StandardAgent实力，然后调用getMBeanServer方法获得一个MBeanServer实例。 StandardAgent agent = new StandardAgent(); MBeanServer mBeanServer = agent.getMBeanServer(); 然后为CarMBean创建了一个ObjectName。MBeanServer的默认域用于ObjectName的域。一个名为type的键key被添加到域上，type的值是管理资源的完全限定名。 String domain = mBeanServer.getDefaultDomain(); String managedResourceClassName = "ex20.pyrmont.standardmbeantest.Car"; ObjectName objectName = agent.createObjectName(domain + ":type=" + managedResourceClassName);
    然后main方法调用createStandardBean方法，传递一个objectName以及管理资源的类名。 agent.createStandardBean(objectName, managedResourceClassName); 接下来主方法通过CarMBean实例管理Car对象。它创建了一个名为colorAttribute的Attribute对象表示Color属性并将其值设置为blue。然后调用setAttribute方法，参数为objectName和colorAttribute。然后使用MBeanServer上的invoke方法来调用driver方法。 // manage MBean try { Attribute colorAttribute = new Attribute("Color","blue"); mBeanServer.setAttribute(objectName, colorAttribute); System.out.println(mBeanServer.getAttribute(objectName, "Color")); mBeanServer.invoke(objectName,"drive",null,null); } 如果运行StandardAgent类，会得到以下输出。 blue Baby you can drive my car.
    你可能会疑问为什么需要JMX来管理Java对象。在StandardAgent类里可以直接访问Car对象。的确是这样，但是这里的关键是你可以选择要暴露哪些属性和
    方法让管理程序来使用。另外可以在本章的“The Application”一节中看到MBeanServer扮演了管理对象和管理程序之间的中间层的角色。
    模型MBeans
    模型MBeans提供了更多的灵活性。它编写起来更难，但是你不需要在修改自己的Java类。在不适合修改类的时候使用模型MBean是一种更好的选择。 在使用标准MBean的时候需要要管理的资源必须实现一个自己编写的接口。跟标准MBean不同，使用模型MBean的时候，不需要编写任何接口。而是使用javax.management.modelmbean.ModelMBean接口来表示模型MBean。你只需要实现这个接口即可，而javax.management.modelmbean.RequiredModelMBean类提供了改接口的默认实现。你可以初始化RequiredModelMBean类或者他的子类。
    注意
    ModelMBean接口的其它实现也可以，例如在Commons Modeler库中，有对该接口的实现，而不是继承RequiredModelMBean
    要编写模型MBean的最大挑战是告诉你的模型MBean对象哪些属性和方法要暴露给代理。可以通过创建javax.management.modelmbean.ModelMBeanInfo对象实现这一点。ModelMBeanInfo对象用于描述暴露给代理的构造器、属性、操作以及事件监听器。创建一个ModelMBeanInfo对象是一个负值的工作，但是一旦你做好了一个，你只需要将其跟ModelMBean对象关联即可。 使用RequiredModelMBean作为你的ModelMBean的实现，有两种方法可以将你的ModelMBean关联到ModelMBeanInfo： 1. 传递一个ModelMBeanInfo对象给RequiredModelMBean的构造函数 2. 传递一个ModelMBeanInfo对象给RequiredModelMBean对象的setModelMBeanInfo方法。
    在创建一个ModelMBean之后，必须使用ModelMBean接口的setManagedResource方法将其关联到管理资源。该方法签名如下： public void setManagedResource(java.lang.Object managedResource, java.lang.String managedResourceType) throws MBeanException, RuntimeOperationsException, InstanceNotFoundException, InvalidTargetObjectTypeException managedResourceType参数的值可以是如下之一，ObjectReference, Handle, IOR, EJBHandle, or RMIReference。目前只支持ObjectReference。 然后当然需要创建一个ObjectName对象并经模型MBean注册到MBean服务器。
    本节提供了一个例子来说明模型MBean的使用，使用了跟上一个例子相同的Car对象、在看该实例之前先看用于描述管理资源的属性和操作的ModelMBeanInfo接口。
    MBeanInfo和ModelMBeanInfo
    javax.management.mbean.ModelMBeanInfo接口描述了要暴露给MOdelMBean的构造函数、属性、操作和监听器。构造函数使用javax.management.modelmbean.ModelMBeanConstructorInfo表示。属性使用javax.management.modelmbean.ModelMBeanAttributeInfo表示。操作用javax.management.modelmbean.ModelMBeanOperationInfo表示。监听器用javax.management.modelmbean.ModelMBeanNotificationInfo表示。在本章中，我们只关注操作和属性。 JMX提供了ModelMBeanInfo的默认实现：javax.management.modelmbean.ModelMBeanInfoSupport类。下面是ModelMBeanInfoSupport类的构造函数的签名，它们在例子中会使用到 public ModelMBeanInfoSupport(java.lang.String className, java.lang.String description, ModelMBeanAttributeInfo[] attributes, ModelMBeanConstructorInfo[] constructors, ModelMBeanOperationInfo[] operations, ModelMBeanNotificationInfo[] notifications) 可以使用ModelMBeanAttributeInfo的构造函数构建一个ModelMBeanAttributeInfo对象：
    public ModelMBeanAttributeInfo(java.lang.String name, java.lang.String type, java.lang.String description, boolean isReadable, boolean isWritable, boolean isIs, Descriptor descriptor) throws RuntimeOperationsException 下面是它的参数列表 · name. The name of the attribute属性名 · type. The type or class name of the attribute属性的类型或者类名 · description. The description of the attribute.属性的描述 · isReadable. true if the attribute has a getter method, false otherwise.如果该属性有相应的get方法为真，否则为false
    · isWritable. true if the attribute has a setter method, false otherwise.如果该属性有响应的set方法为真，否则为false。
    · isIs. true if the attribute has an is getter, false otherwise.如果该属性有is getter为真，否则为false。
    · descriptor. An instance of Descriptor containing the appropriate metadata for this instance of the Attribute. If it is null then a default descriptor will be created. Descriptor的实例，包括该Attribute的元数据。如果它是null，就创建一个默认的descriptor。 可以使用如下ModelMBeanOperationInfo构造函数来创建一个该类的对象
    public ModelMBeanOperationInfo(java.lang.String name, java.lang.String description, MBeanParameterInfo[] signature, java.lang.String type, int impact, Descriptor) throws RuntimeOperationsException 下面是参数列表 · name. The name of the method.方法名 · description. The description of the operation.该操作的描述
    · signature, an array of MBeanParameterInfo objects describing the parameters of the method. MBeanParameterInfo对象数组描述该方法的参数。 · type. The type of the method's return value.返回值类型
    · impact. The impact of the method. The value is one of the following: INFO, ACTION, ACTION_INFO, UNKNOWN.该方法的作用：如下值之一INFO, ACTION, ACTION_INFO, UNKNOWN.
    · descriptor. An instance of Descriptor containing the appropriate metadata, for this instance of the MBeanOperationInfo. 包含该MBeanOperationInfo对象的元数据的Deccriptor。
    ModelMBean例子
    这个例子说明了如何使用模型MBean来管理一个Car对象，如Listing20.4所示
    Listing 20.4: The Car class package ex20.pyrmont.modelmbeantest1; public class Car { private String color = "red"; public String getColor() { return color; } public void setColor(String color) { this.color = color; } public void drive() { System.out.println("Baby you can drive my car."); }
    }
    对于模型MBean，不需要想标准MBean那样编写接口。你只需简单的初始化RequiredMBean类。Listing20.5提供了ModelAgent类，它创建了MBean并管理Car对象
    Listing 20.5: The ModelAgent class package ex20.pyrmont.modelmbeantest1; import javax.management.Attribute; import javax.management.Descriptor; import javax.management.MalformedObjectNameException; import javax.management.MBeanOperationInfo; import javax.management.MBeanParameterInfo; import javax.management.MBeanServer; import javax.management.MBeanServerFactory; import javax.management.ObjectName; import javax.management.modelmbean.DescriptorSupport; import javax.management.modelmbean.ModelMBean; import javax.management.modelmbean.ModelMBeanAttributeInfo; import javax.management.modelmbean.ModelMBeanInfo; import javax.management.modelmbean.ModelMBeanInfoSupport; import javax.management.modelmbean.ModelMBeanOperationInfo; import javax.management.modelmbean.RequiredModelMBean; public class ModelAgent { private String MANAGED_CLASS_NAME = "ex20.pyrmont.modelmbeantest1.Car"; private MBeanServer mBeanServer = null; public ModelAgent() { mBeanServer = MBeanServerFactory.createMBeanServer(); } public MBeanServer getMBeanServer() { return mBeanServer; } private ObjectName createObjectName(String name) { ObjectName objectName = null; try { objectName = new ObjectName(name); } catch (MalformedObjectNameException e) { e.printStackTrace(); }
    return objectName; } private ModelMBean createMBean(ObjectName objectName, String mbeanName) { ModelMBeanInfo mBeanInfo = createModelMBeanInfo(objectName,
    mbeanName); RequiredModelMBean modelMBean = null; try { modelMBean = new RequiredModelMBean(mBeanInfo); } catch (Exception e) { e.printStackTrace(); } return modelMBean; } private ModelMBeanInfo createModelMBeanInfo(ObjectName inMbeanObjectName, String inMbeanName) { ModelMBeanInfo mBeanInfo = null; ModelMBeanAttributeInfo[] attributes = new ModelMBeanAttributeInfo[1]; ModelMBeanOperationInfo[] operations = new ModelMBeanOperationInfo[3]; try { attributes[0] = new ModelMBeanAttributeInfo("Color", "java,lang.String", "the color.", true, true, false, null); operations[0] = new ModelMBeanOperationInfo("drive", "the drive method", null, "void", MBeanOperationInfo.ACTION, null); operations[1] = new ModelMBeanOperationInfo("getColor", "get color attribute", null, "java.lang.String", MBeanOperationInfo.ACTION, null); Descriptor setColorDesc = new DescriptorSupport(new String[] { "name=setColor", "descriptorType=operation", "class=" + MANAGED_CLASS_NAME, "role=operation"}); MBeanParameterInfo[] setColorParams = new MBeanParameterInfo[] { (new MBeanParameterInfo("new color", "java.lang.String", "new Color value") )} ; operations[2] = new ModelMBeanOperationInfo("setColor", "set Color attribute", setColorParams, "void",
    MBeanOperationInfo.ACTION, setColorDesc); mBeanInfo = new ModelMBeanInfoSupport(MANAGED_CLASS_NAME, null, attributes, null, operations, null); } catch (Exception e) { e.printStackTrace(); } return mBeanInfo; } public static void main(String[] args) { ModelAgent agent = new ModelAgent(); MBeanServer mBeanServer = agent.getMBeanServer(); Car car = new Car(); String domain = mBeanServer.getDefaultDomain(); ObjectName objectName = agent.createObjectName(domain + ":type=MyCar"); String mBeanName = "myMBean";
    ModelMBean modelMBean = agent.createMBean(objectName, mBeanName); try { modelMBean.setManagedResource(car, "ObjectReference"); mBeanServer.registerMBean(modelMBean, objectName); } catch (Exception e) { } // manage the bean try { Attribute attribute = new Attribute("Color", "green"); mBeanServer.setAttribute(objectName, attribute); String color = (String) mBeanServer.getAttribute(objectName, "Color"); System.out.println("Color:" + color); attribute = new Attribute("Color", "blue"); mBeanServer.setAttribute(objectName, attribute); color = (String) mBeanServer.getAttribute(objectName, "Color"); System.out.println("Color:" + color); mBeanServer.invoke(objectName, "drive", null, null); } catch (Exception e) {
    e.printStackTrace(); } } }
    如你看到的，编写MBean需要做大量的工作，尤其是声明暴露的属性和操作的时候。接下来一节将会看到使用常用模型库（Commons Modeler library）更快的编写模型MBean。
    常用模型
    常用模型库是Apache软件基金会Jakarta项目下的子项目。它提供了更简便的方法来编写模型MBean。它最大的帮助在于使用它你不需要创建自己的ModelMBeanInfo对象。 回想前面的创建RequiredModelMBean例子的方法，需要创建ModelMBeanInfo对象以传递个RequiredModelMBean的构造函数。 ModelMBeanInfo mBeanInfo = createModelMBeanInfo(objectName, mbeanName); RequiredModelMBean modelMBean = null; try { modelMBean = new RequiredModelMBean(mBeanInfo);
    } ... ModelMBeanInfo对象用于描述暴露的属性和操作，而编写createModelMBeanInfo是一项负责的工作，必须列出所有的属性和操作然后将其传递给createModelMBeanInfo。 使用常用 模型，不需要再使用createModelMBeanInfo对象。对模型MBean的描述被封住到org.apache.catalina.modeler.ManagedBean对象中。不需要在编写代码来暴露属性和操作。只需要编写一个XMl文档列出你想创建的MBean、对于每个MBean，需要写出MBean类和管理资源的完全限定名，以及暴露的方法和属性。然后使用org.apache.commons.modeler.Registry对象读取XML文档，就可以创建一个包括所有XML文档中描述的所有ManagedBean实例的MBeanServer实例。 然后可以调用ManagedBean实例的createMBean方法来创建一个模型MBean。其它的工作就是平常需要做的了。需要创建ObjectName实例并将MBean注册到MBean服务器。接下来看看描述文件是如何工作的，然后讨论最重要的类：Modeler, Registry, ManagedBean, 以及BaseModelMBean。
    注意
    Tomcat4使用旧版本的模型，有些方法现在已不赞成继续使用。我们会讨论Tomcat4的版本这样你可以理解org.apache.catalina.mbeans中的MBeans。
    MBean Descriptor
    一个MBean描述符是用于描述MBean服务器管理的模型MBean的XML文档。一个描述符的开头内容如下： <?xml version="1.0"?> <!DOCTYPE mbeans-descriptors PUBLIC "-//Apache Software Foundation//DTD Model MBeans Configuration File" "http://jakarta.apache.org/commons/dtds/mbeans-descriptors.dtd">
    它的根元素是mbeans-descriptors <mbeans-descriptors> ... </mbeans-descriptors> 在mbeans-descriptors标签内的元素师mbean元素，每一个表示一个模型MBean。Mbean元素包括表示属性、操作、构造器、监听器的元素。接下的子节中会讨论Tomcat的MBean描述符中使用到的三种元素：
    mbean
    Mbean元素描述模型Mbean，它包括构造相应的ModelMBeanInfo对象的信息，mbean元素如下定义 <!ELEMENT mbean (descriptor?, attribute*, constructor*, notification*, operation*)> Mbean可以有选择性的descriptor元素，0或多个attribute元素，0或多个constructor元素，0或多个notification元素，0或多个opertion元素。 Mbean元素可以有如下属性：
    · className. Fully qualified Java class name of the ModelMBean implementation. If this attribute is not present, the org.apache.commons.modeler.BaseModelMBean will be used. ModelMBean实现的完全限定名。如果该属性没有，会使用org.apache.commons.modeler.BaseModelMBean。 · description. A description of this model MBean.对该模型MBean的描述 · domain. The MBean server's domain in which the ModelMBean created by this managed bean should be registered, when creating its ObjectName.该managed bean创建的模型MBean要注册的服务器的域。
    · group. Optional name of a "grouping classification" that can be used to select groups of similar MBean implementation classes.选择性的“grouping classification”可用于选择相似的MBean的组。
    · name. A name that uniquely identifies this model MBean. Normally, the base class name of the corresponding server component is used.name用于唯一确认MBean的ID，一般使用服务器组件的基类名。 · type. Fully qualified Java class name of the managed resource implementation class.管理资源类的完全限定名。
    attribute
    使用attribute元素描述MBean的JavaBean属性。Attribute元素可以有选择性的decriptor元素和如下属性： · description. A description of this attribute.该属性的描述 · displayName. The display name of this attribute.属性的显示名称。 · getMethod. The getter method of the property represented by the attribute element.该属性的get方法。 · is. A boolean value indicating whether or not this attribute is a boolean with an is getter method. By default, the value of the is attribute is false.一个Boolean值，表示该属性是一个有getter方法的boolean类型。默认的该值为false。 · name. The name of this JavaBeans property.该JavaBean的属性名 · readable. A boolean value indicating whether or not this attribute is readable by management applications. By default, the value of readable is true.boolean值，用于表示管理程序是否对该属性可读。默认的该值为true。 · setMethod. The setter method of the property represented by this attribute element.表示该attribute元素的setter方法。 · type. The fully qualified Java class name of this attribute.该属性的完全限定Java类名。 · writeable. A boolean value indicating whether or not this attribute can be written by management applications. By default, this is set to true.boolean值，用于表示该管理程序是否对该属性进行写操作，默认为true。
    operation
    Operation元素描述暴露给管理程序的public方法，它可以有0或多个参数子元素，有如下属性：
    · description. The description of this operation.操作的描述
    · impact. This attribute indicates the impact of this method. The possible values are ACTION (write like), ACTION-INFO (write+read like), INFO (read like), or UNKNOWN.该方法的作用，可选值为ACTION (write like), ACTION-INFO (write+read like), INFO (read like), or UNKNOWN。 · name. The name of this public method.该public方法的名字。 · returnType. The fully qualified Java class name of the return type of this method.返回值类型。
    parameter
    Parameter元素用于描述传递给构造函数或操作的参数，它可以有如下属性：
    · description. The description of this parameter.对该参数的描述 · name. The name of this parameter.参数名 · type. The fully qualified Java class name of this parameter.参数类型
    mbean元素例子
    Catalina中有很多模型MBean，在org.apache.catalina.mbeans 包中的mbean-descriptors.xml中声明。Listing20.6提供了Tomcat4中对StandardServer的Mbean的声明。
    Listing 20.6: The declaration of the StandardServer MBean <mbean name="StandardServer" className="org.apache.catalina.mbeans.StandardServerMBean" description="Standard Server Component" domain="Catalina" group="Server" type="org.apache.catalina.core.StandardServer"> <attribute name="debug" description="The debugging detail level for this component" type="int"/> <attribute name="managedResource" description="The managed resource this MBean is associated with" type="java.lang.Object"/> <attribute name="port"
    description="TCP port for shutdown messages" type="int"/> <attribute name="shutdown" description="Shutdown password" type="java.lang.String"/> <operation name="store" description="Save current state to server.xml file" impact="ACTION" returnType="void"> </operation> </mbean>
    Listing20.6中的mbean元素声明了一个模型MBean用于标识StandardServer。该MBean用org.apache.catalina.mbeans.StandardServerMBean表示，管理一个org.apache.catalina.core.StandardServer类型的对象。域是Catalina而组是Server。 该模型MBean暴露了四个属性：debug，managedResource,port以及shutdown，这四个属性都是attribute元素位于mbean元素里面。MBean还暴露了store方法，用operation元素表示。
    编写自己的模型MBean类
    当使用常用模型的时候，在mbean元素的className属性中定义模型MBean的类型。默认的常用模型使用org.apache.commons.modeler.BaseModelMBean类，但是有些情况你可能想要继承BaseModelMBean: 1. 想要覆盖管理资源的属性和方法 2. 想要给管理资源添加为定义的属性和方法 Catalina在org.apache.catalina.mbeans包中提供了BaseModelMBean类的一些子类，这里对它们进行简单的介绍：
    Registry
    该API的中心在org.apache.commons.modeler.Registry类，这里是可以使用该类做的事情：
    · Obtain an instance of javax.management.MBeanServer (so you don't need to call the createMBeanServer method of javax.management.MBeanServerFactory). · Read an mbean descriptor file using the loadRegistry method.
    · Create a ManagedBean object that you can use to construct a model MBean. · 获得一个javax.management.MBeanServer实例（不需要调用javax.management.MBeanServerFactor的createMBeanServer方法） · 使用loadRegistry方法读取描述文件 · 创建一个可用于创建模型MBean的ManagedBean对象
    ManagedBean
    ManagedBean 替代javax.management.MBeanInfo来表示一个模型MBean。
    BaseModelMBean
    org.apache.commons.modeler.BaseModelMBean类实现了javax.management.modelmbean.ModelMBean接口。使用这个类，不需要使用javax.management.modelmbean.RequiredModelMBean类。
    该类还有一点很有用是该类用一个resources属性来表示管理资源。 protected java.lang.Object resource;
    使用Modeler API
    你想要管理的Car类如Listing20.7所示：
    Listing 20.7: The Car class package ex20.pyrmont.modelmbeantest2; public class Car { public Car() { System.out.println("Car constructor"); } private String color = "red"; public String getColor() { return color; } public void setColor(String color) { this.color = color; } public void drive() { System.out.println("Baby you can drive my car.");
    } }
    使用常用模型，不需要再在属性和操作上面进行编码，而是简单的在XML文档中累出来即可。在这个例子中，用于描述它的文档car-mbean-descriptor.xml如Listing20.8所示
    Listing 20.8: The car-mbean-descriptor.xml file <?xml version="1.0"?> <!DOCTYPE mbeans-descriptors PUBLIC "-//Apache Software Foundation//DTD Model MBeans Configuration File" "http://jakarta.apache.org/commons/dtds/mbeans-descriptors.dtd"> <mbeans-descriptors> <mbean name="myMBean" className="javax.management.modelmbean.RequiredModelMBean" description="The ModelMBean that manages our Car object" type="ex20.pyrmont.modelmbeantest.Car"> <attribute name="Color" description="The car color"
    type="java.lang.String"/> <operation name="drive" description="drive method" impact="ACTION" returnType="void"> <parameter name="driver" description="the driver parameter" type="java.lang.String"/> </operation> </mbean> </mbeans-descriptors>
    Now, you need the agent class (ModelAgent.java) in Listing 20.9. 接下来需要如Listing20.9所示的代理类：
    Listing 20.9: The ModelAgent Class package ex20.pyrmont.modelmbeantest2; import java.io.InputStream; import java.net.URL; import javax.management.Attribute; import javax.management.MalformedObjectNameException; import javax.management.MBeanServer; import javax.management.ObjectName;
    import javax.management.modelmbean.ModelMBean; import org.apache.commons.modeler.ManagedBean; import org.apache.commons.modeler.Registry; public class ModelAgent { private Registry registry; private MBeanServer mBeanServer; public ModelAgent() { registry = createRegistry(); try { mBeanServer = Registry.getServer(); } catch (Throwable t) { t.printStackTrace(System.out); System.exit(1); } } public MBeanServer getMBeanServer() { return mBeanServer; } public Registry createRegistry() { Registry registry = null; try { URL url = ModelAgent.class.getResource ("/ex20/pyrmont/modelmbeantest2/car-mbean-descriptor.xml"); InputStream stream = url.openStream(); Registry.loadRegistry(stream); stream.close(); registry = Registry.getRegistry();
    } catch (Throwable t) { System.out.println(t.toString()); } return (registry); } public ModelMBean createModelMBean(String mBeanName) throws Exception { ManagedBean managed = registry.findManagedBean(mBeanName);
    if (managed == null) { System.out.println("ManagedBean null"); return null; } ModelMBean mbean = managed.createMBean(); ObjectName objectName = createObjectName(); return mbean; } private ObjectName createObjectName() { ObjectName objectName = null; String domain = mBeanServer.getDefaultDomain(); try { objectName = new ObjectName(domain + ":type=MyCar"); } catch (MalformedObjectNameException e) { e.printStackTrace(); } return objectName; } public static void main(String[] args) { ModelAgent agent = new ModelAgent(); MBeanServer mBeanServer = agent.getMBeanServer(); Car car = new Car(); System.out.println("Creating ObjectName"); ObjectName objectName = agent.createObjectName(); try { ModelMBean modelMBean = agent.createModelMBean("myMBean"); modelMBean.setManagedResource(car, "ObjectReference"); mBeanServer.registerMBean(modelMBean, objectName); } catch (Exception e) { System.out.println(e.toString()); } // manage the bean try { Attribute attribute = new Attribute("Color", "green"); mBeanServer.setAttribute(objectName, attribute); String color = (String) mBeanServer.getAttribute(objectName, "Color"); System.out.println("Color:" + color); attribute = new Attribute("Color", "blue");
    mBeanServer.setAttribute(objectName, attribute); color = (String) mBeanServer.getAttribute(objectName, "Color");
    System.out.println("Color:" + color); mBeanServer.invoke(objectName, "drive", null, null); } catch (Exception e) { e.printStackTrace(); } } }
    可以看到使用常用模型编写的代理类简短。
    Catalina's MBeans
    如在本章开头提到的，Catalina在org.apache.catalina.mbeans包中提供了一些MBean类。这些MBean类直接或间接的继承org.apache.commons.modeler.BaseModelMBean类。本节主要讨论Tomcat4中3个最重要的MBean类：ClassNameMBean, StandardServerMBean,和 MBeanFactory。如果你明白了这三个类，其它的MBean类就不难理解。另外本节还将介绍org.apache.catalina.mbeans包中的MBeanUtil类。
    ClassNameMBean类
    org.apache.catalina.mbeans.ClassNameMBean继承了org.apache.commons.modeler.BaseModelMBean。它提供了代表管理资源的类名的只写属性className。该类如Listing20.10所示：
    Listing 20.10: The ClassNameMBean class package org.apache.catalina.mbeans; import javax.management.MBeanException; import javax.management.RuntimeOperationsException; import org.apache.commons.modeler.BaseModelMBean; public class ClassNameMBean extends BaseModelMBean { public ClassNameMBean() throws MBeanException, RuntimeOperationsException { super(); } public String getClassName() {
    return (this.resource.getClass().getName()); }
    }
    ClassNameMBean是BaseModelMBean类的一个例子，它提供了一个在管理资源中不可用的属性。mbeans-descriptors.xml文件中的多个mbean元素使用这个类作为模型MBean的类型。
    StandardServerMBean
    StandardServerMBean继承了org.apache.commons.modeler.BaseModelMBean类，用于管理org.apache.catalina.core.StandardServer。如Listing20.11的StandardServerMBean类是一个模型MBean的例子，它覆盖了管理资源的一个方法（store方法）。当管理程序调用store方法的时候，会提交StandardServerMBean类中而不是它管理的StandardServer中的store方法。
    Listing 20.11: The StandardServerMBean class package org.apache.catalina.mbeans; import javax.management.InstanceNotFoundException; import javax.management.MBeanException; import javax.management.MBeanServer; import javax.management.RuntimeOperationsException; import org.apache.catalina.Server; import org.apache.catalina.ServerFactory; import org.apache.catalina.core.StandardServer; import org.apache.commons.modeler.BaseModelMBean; public class StandardServerMBean extends BaseModelMBean { private static MBeanServer mserver = MBeanUtils.createServer(); public StandardServerMBean() throws MBeanException, RuntimeOperationsException { super(); } public synchronized void stored throws InstanceNotFoundException, MBeanException, RuntimeOperationsException { Server server = ServerFactory.getServer(); if (server instanceof StandardServer) { try { ((StandardServer) server).store(); } catch (Exception e) { throw new MBeanException(e, "Error updating conf/server.xml"); }
    } } }
    StandardServerMBean是BaseModelMBean的子类，它覆盖管理资源中的方法。
    MBeanFactory
    MBeanFactory表示用于创建模型MBean的工厂对象，它管理Catalina中各种资源。MBeanFactory类还提供了用于删除这些MBeans。
    As an example, take a look at the createStandardContext method in Listing 20.12.
    Listing 20.12: The createStandardContext method public String createStandardContext(String parent, String path, String docBase) throws Exception { // Create a new StandardContext instance StandardContext context = new StandardContext(); path = getPathStr(path); context.setPath(path); context.setDocBase(docBase); ContextConfig contextConfig = new ContextConfig(); context.addLifecycleListener(contextConfig); // Add the new instance to its parent component ObjectName pname = new ObjectName(parent); Server server = ServerFactory.getServer(); Service service = server.findService(pname.getKeyProperty("service")); Engine engine = (Engine) service.getContainer(); Host host = (Host) engine.findChild(pname.getKeyProperty("host")); // Add context to the host host.addChild(context); // Return the corresponding MBean name ManagedBean managed = registry.findManagedBean("StandardContext"); ObjectName oname = MBeanUtils.createObjectName(managed.getDomain(), context); return (oname.toString()); }
    MBeanUtil
    org.apache.catalina.mbeans.MBeanUtil类是一个工具类，它提供了静态方法来创建Mbean以管理Catalina对象、删除MBean的静态方法以及创建对象名的静态方法。例如，如Listing20.13所示的createMBean方法创建一个org.apache.catalina.Server对象的模型MBean。
    Listing 20.13: The createMBean method that creates a model MBean that manages a Server object. public static ModelMBean createMBean(Server server) throws Exception { String mname = createManagedName(server); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception( "ManagedBean is not found with "+mname); throw new MBeanException(e); } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ModelMBean mbean = managed.createMBean(server); ObjectName oname = createObjectName(domain, server); mserver.registerMBean(mbean, oname); return (mbean); }
    Catalina创建MBean 现在熟悉了Catalina中的模型MBean，接下来看一下是怎么样创建这些MBean来管理应用程序的。 Tomcat的配置文件server.xml在Server元素中定义了Listener元素： <Server port="8005" shutdown="SHUTDOWN" debug="0"> <Listener c1assName="org.apache.catalina.mbeans.ServerLifecycleListener" debug="0"/> ... 它将给org.apache.catalina.core.StandardServer添加一个org.apache.catalina.mbeans.ServerLifecycleListener类型的监听器，当StandardServer实例启动的时候，会触发一个START_EVENT事件，如StandardServer类中定义的那样： public void start() throws LifecycleException { ...
    lifecycle.fireLifecycleEvent(START_EVENT, null); ... } StandardServer对象停止的时候，会触发STOP_EVENT事件，如stop方法中定义的那样： public void stop() throws LifecycleException { ... lifecycle.fireLifecycleEvent(STOP_EVENT, null); ... } 这些事件会导致ServerLifecycleListener中的lifecycleEvent方法被提交。Listing20.14展示了lifecycleEvent方法
    Listing 20.14: The lifecycleEvent method of the ServerLifecycleListener class public void lifecycleEvent(LifecycleEvent event) { Lifecycle lifecycle = event.getLifecycle(); if (Lifecycle.START_EVENT.equals(event.getType())) { if (lifecycle instanceof Server) { // Loading additional MBean descriptors loadMBeanDescriptors(); createMBeans(); } } else if (Lifecycle.STOP_EVENT.equals(event.getType())) { if (lifecycle instanceof Server) { destroyMBeans(); } } else if (Context.RELOAD_EVENT.equals(event.getType())) { if (lifecycle instanceof StandardContext) { StandardContext context = (StandardContext)lifecycle; if (context.getPrivileged()) { context.getServletContext().setAttribute (Globals.MBEAN_REGISTRY_ATTR, MBeanUtils.createRegistry()); context.getServletContext().setAttribute (Globals.MBEAN_SERVER_ATTR, MBeanUtils.createServer()); } } } }
    createMBeans是创建Catalina中所有MBeans方法。该方法首先创建一个
    MBeanFactory：
    Listing 20.15: The createMBeans method in ServerLifecycleListener protected void createMBeans() { try { MBeanFactory factory = new MBeanFactory(); createMBeans(factory); createMBeans(serverFactory.getserver()); } catch (MBeanException t) { Exception e = t.getTargetException(); if (e == null) e = t; log("createMBeans: MBeanException", e); } catch (Throwable t) { log("createMBeans: Throwable", t); } }
    第一个createMBeans方法使用MBeanUtil类给MBeanFactory创建一个ObjectName并将其向MBean服务器注册。 第二个createMBeans方法有一个org.apache.catalina.Server对象并为其创建模型MBean。阅读如Listing20.16所示的createMBeans方法的代码很有趣
    Listing 20.16: The createMBeans method that creates an MBean for a Server object protected void createMBeans(Server server) throws Exception { // Create the MBean for the Server itself if (debug >= 2) log("Creating MBean for Server " + server); MBeanUtils.createMBean(server); if (server instanceof StandardServer) { ((StandardServer) server).addPropertyChangeListener(this); } // Create the MBeans for the global NamingResources (if any) NamingResources resources = server.getGlobalNamingResources(); if (resources != null) { createMBeans(resources); } // Create the MBeans for each child Service Service services[] = server.findServices(); for (int i = 0; i < services.length; i++) {
    // FIXME - Warp object hierarchy not currently supported if (services[i].getContainer().getClass().getName().equals ("org.apache.catalina.connector.warp.WarpEngine")) { if (debug >= 1) {
    log("Skipping MBean for Service " + services[i]); } continue; } createMBeans(services[i]); } }
    注意如Listing20.16所示的createMBeans方法使用for循环来迭代StandardServer实例中的所有Service对象。 createMBeans(services[i]); 该方法为服务（Service）创建一个MBean实例并调用createMBeans方法来为该服务所有的连接器和引擎创建MBean对象。用于创建Service的MBean的createMBeans方法如Listing20.17所示：
    Listing 20.17: The createMBeans method that creates a Service MBean protected void createMBeans(Service service) throws Exception { // Create the MBean for the Service itself if (debug >= 2) log("Creating MBean for Service " + service); MBeanUtils.createMBean(service); if (service instanceof StandardService) { ((StandardService) service).addPropertyChangeListener(this); } // Create the MBeans for the corresponding Connectors Connector connectors[] = service.findConnectors(); for (int j = 0; j < connectors.length; j++) { createMBeans(connectors[j]); } // Create the MBean for the associated Engine and friends Engine engine = (Engine) service.getContainer(); if (engine != null) { createMBeans(engine); } }
    createMBeans (engine)调用为主机创建MBeans的createMBeans方法。
    protected void createMBeans(Engine engine) throws Exception { // Create the MBean for the Engine itself if (debug >= 2) { log("Creating MBean for Engine " + engine); } MBeanUtils.createMBean(engine); ...
    Container hosts[] = engine.findChildren(); for (int j = 0; j < hosts.length; j++) { createMBeans((Host) hosts[j]); } ... }
    The createMBeans (host) method in turns creates a ContextMBean, like the following: createMBeans方法又创建ContextMBean，如下： protected void createMBeans(Host host) throws Exception { ... MBeanUtils.createMBean(host); ... Container contexts[] = host.findChildren(); for (int k = 0; k < contexts.length; k++) { createMBeans((Context) contexts[k]); } ... }
    The createMBeans (context) method is as follows: createMBeans(context)如下所示： protected void createMBeans(Context context) throws Exception { ... MBeanUtils.createMBean(context); ... context.addContainerListener(this); if (context instanceof StandardContext) { ((StandardContext) context).addPropertyChangeListener(this); ((StandardContext) context).addLifecycleListener(this); } // If the context is privileged, give a reference to it // in a servlet context attribute if (context.getPrivileged()) {
    context.getServletContext().setAttribute (Globals.MBEAN_REGISTRY_ATTR, MBeanUtils.createRegistry()); context.getServletContext().setAttribute (Globals.MBEAN_SERVER_ATTR, MBeanUtils.createServer()); } ... } 如果上下文的privileged属性为真，会给该web应用程序创建和存储两个属性。属性的键为Globals.MBEAN_REGISTRY_ATTR和Globals.MBEAN_SERVER_ATTR。下面是org.apache.catalina.Globals类中的代码片段： /** * The servlet context attribute under which the managed bean Registry * will be stored for privileged contexts (if enabled). */
    public static final String MBEAN_REGISTRY_ATTR = "org.apache.catalina.Registry"; /** * The servlet context attribute under which the MBeanServer will be * stored for privileged contexts (if enabled). */ public static final String MBEAN_SERVER_ATTR = "org.apache.catalina.MBeanServer"; MBeanUtils.createRegistry返回一个Registry实例。MBeanUtils.createServer方法返回一个javax.management.MBeanServer实例，所有的Catalina的MBean都在上面注册。 另一句话说，可以获得privileged属性为真的web应验的Reigstry 和 MBeanServer的实例。下面一节将会讨论如何使用JMX管理应用程序来管理Tomcat。 应用程序 这里的应用程序时一个用于管理Tomcat的应用程序。它很简单但是足够你认识怎么使用MBeans暴露的Catalina。可以使用它它列出Catalina中所有的ObjectName实例，列出当前运行的所有上下文以及删除它们。 首先，需要为该应用程序创建一个描述文件如Listing20.18所示。必须将该文件放在%CATALINA_HOME%/webapps目录下。
    Listing 20.18: The myadmin.xml file <Context path="/myadmin" docBase="../server/webapps/myadmin" debug="8" privileged="true" reloadable="true"> </Context>
    你需要关系的一件事是确保Context元素的privileged属性为真。docBase属性被设置成该应用程序的地址。 该应用程序由一个Servlet，如Listing20.19所示
    Listing 20.19: The MyAdminServlet class package myadmin; import java.io.IOException;
    import java.io.PrintWriter; import java.net.URLEncoder; import java.util.Iterator; import java.util.Set; import javax.management.MBeanServer; import javax.management.ObjectName; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.modeler.Registry; public class MyAdminServlet extends HttpServlet { private Registry registry; private MBeanServer mBeanServer; public void init() throws ServletException { registry = (Registry) getServletContext().getAttribute("org.apache.catalina.Registry"); if(registry == null) { System.out.println("Registry not available"); return; } mBeanServer = (MBeanServer) getServletContext().getAttribute( "org.apache.catalina.MBeanServer"); if (mBeanServer==null) { System.out.println("MBeanServer not available"); return; } } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("text/html"); PrintWriter out = response.getWriter(); if (registry==null || mBeanServer==null) { out.println("Registry or MBeanServer not found"); return; } out.println("<html><head></head><body>"); String action = request.getParameter("action"); if ("listAllManagedBeans".equals(action)) { listAllManagedBeans(out); } else if ("listAllContexts".equals(action)) { listAllContexts(out); } else if ("removeContext".equals(action)) { String contextObjectName = request.getParameter("contextObjectName"); removeContext(contextObjectName, out); } else {
    out.println("Invalid command"); } out.println("</body></html>"); } private void listAllManagedBeans(PrintWriter out) { String[] managedBeanNames = registry.findManagedBeans(); for (int i=0; i<managedBeanNames.length; i++) { out.print(managedBeanNames[i] + "<br/>"); } } private void listAllContexts(PrintWriter out) { try { ObjectName objName = new ObjectName("Catalina:type=Context,*"); Set set = mBeanServer.queryNames(objName, null); Iterator it = set.iterator(); while (it.hasNext()) { ObjectName obj = (ObjectName) it.next(); out.print(obj + " <a href=?action=removeContext&contextObjectName=" + URLEncoder.encode (obj.toString(), "UTF-8") +
    ">remove</a><br/>"); } } catch (Exception e) { out.print(e.toString()); } } private void removeContext(String contextObjectName, PrintWriter out) { try { ObjectName mBeanFactoryObjectName = new ObjectName("Catalina:type=MBeanFactory"); if (mBeanFactoryObjectName!=null) { String operation = "removeContext"; String[] params = new String[1]; params[0] = contextObjectName; String signature[] = { "java.lang.String" }; try { mBeanServer.invoke(mBeanFactoryObjectName, operation, params, signature); out.println("context removed"); } catch (Exception e) { out.print(e.toString()); } } } catch (Exception e) { } } }
    最后，需要如Listing20.20所示的应用部署文件。
    Listing 20.20: The web.xml file <?xml version="1.0" encoding="ISO-8859-1"?> <!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"> <web-app> <servlet>
    <servlet-name>myAdmin</servlet-name> <servlet-class>myadmin.MyAdminServlet</servlet-class> </servlet> <servlet-mapping> <servlet-name>myAdmin</servlet-name> <url-pattern>/myAdmin</url-pattern> </servlet-mapping> </web-app>
    要列出所有的ObjectName实例，可以使用如下URL http://localhost:8080/myadmin/myAdmin?action=listAllMBeans 可以看到一系列的MBean对象，下面是前六个： MemoryUserDatabase DigestAuthenticator BasicAuthenticator UserDatabaseRealm SystemErrLogger Group 可以使用如下URL列出所有上下文容器： http://localhost:8080/myadmin/myAdmin?action=listAllContexts 可以看到所有的运行中的应用，可以点击remove超链接删除它们
    总结
    在本章中学习了如何使用JMX来管理Tomcat。本章介绍了两种类型的MBeans并展示了一个简单使用MBeans来管理Catalina的应用程序。